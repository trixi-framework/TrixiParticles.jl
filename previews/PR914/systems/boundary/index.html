<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary · TrixiParticles.jl</title><meta name="title" content="Boundary · TrixiParticles.jl"/><meta property="og:title" content="Boundary · TrixiParticles.jl"/><meta property="twitter:title" content="Boundary · TrixiParticles.jl"/><meta name="description" content="Documentation for TrixiParticles.jl."/><meta property="og:description" content="Documentation for TrixiParticles.jl."/><meta property="twitter:description" content="Documentation for TrixiParticles.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="https://cdn.jsdelivr.net/npm/asciinema-player@3.6.3/dist/bundle/asciinema-player.min.js"></script><link href="https://cdn.jsdelivr.net/npm/asciinema-player@3.6.3/dist/bundle/asciinema-player.min.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TrixiParticles.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../news/">News</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../development/">Development</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><span class="tocitem">Preprocessing</span><ul><li><a class="tocitem" href="../../preprocessing/preprocessing/">Sampling of Geometries</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../general/semidiscretization/">Semidiscretization</a></li><li><a class="tocitem" href="../../general/initial_condition/">Initial Condition and Setups</a></li><li><a class="tocitem" href="../../general/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../general/density_calculators/">Density Calculators</a></li><li><a class="tocitem" href="../../general/smoothing_kernels/">Smoothing Kernels</a></li><li><a class="tocitem" href="../../general/neighborhood_search/">Neighborhood Search</a></li><li><a class="tocitem" href="../../general/util/">Util</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox" checked/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-11-3-1" type="checkbox"/><label class="tocitem" for="menuitem-11-3-1"><span class="docs-label">Fluid Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../fluid/">Overview</a></li><li><a class="tocitem" href="../weakly_compressible_sph/">Weakly Compressible SPH (Fluid)</a></li><li><a class="tocitem" href="../entropically_damped_sph/">Entropically Damped Artificial Compressibility for SPH (Fluid)</a></li></ul></li><li><a class="tocitem" href="../dem/">Discrete Element Method (Solid)</a></li><li><a class="tocitem" href="../total_lagrangian_sph/">Total Lagrangian SPH (Elastic Structure)</a></li><li class="is-active"><a class="tocitem" href>Boundary</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#boundary_models"><span>Boundary Models</span></a></li><li><a class="tocitem" href="#Dummy-Particles"><span>Dummy Particles</span></a></li><li><a class="tocitem" href="#Repulsive-Particles"><span>Repulsive Particles</span></a></li><li class="toplevel"><a class="tocitem" href="#open_boundary"><span>Open Boundaries</span></a></li><li class="toplevel"><a class="tocitem" href="#open_boundary_models"><span>Open Boundary Models</span></a></li><li><a class="tocitem" href="#method_of_characteristics"><span>Method of characteristics</span></a></li><li><a class="tocitem" href="#mirroring"><span>Mirroring</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../time_integration/">Time Integration</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../reference-trixibase/">TrixiBase.jl API Reference</a></li><li><a class="tocitem" href="../../reference-pointneighbors/">PointNeighbors.jl API Reference</a></li></ul></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li><a class="is-disabled">Systems</a></li><li class="is-active"><a href>Boundary</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/TrixiParticles.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/main/docs/src/systems/boundary.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-System"><a class="docs-heading-anchor" href="#Boundary-System">Boundary System</a><a id="Boundary-System-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-System" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.WallBoundarySystem" href="#TrixiParticles.WallBoundarySystem"><code>TrixiParticles.WallBoundarySystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WallBoundarySystem(initial_condition, boundary_model;
                   prescribed_motion=nothing, adhesion_coefficient=0.0)</code></pre><p>System for boundaries modeled by boundary particles. The interaction between fluid and boundary particles is specified by the boundary model.</p><p><strong>Arguments</strong></p><ul><li><code>initial_condition</code>: Initial condition (see <a href="../../general/initial_condition/#TrixiParticles.InitialCondition"><code>InitialCondition</code></a>)</li><li><code>boundary_model</code>: Boundary model (see <a href="#boundary_models">Boundary Models</a>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_motion</code>: For moving boundaries, a <a href="#TrixiParticles.PrescribedMotion"><code>PrescribedMotion</code></a> can be passed.</li><li><code>adhesion_coefficient</code>: Coefficient specifying the adhesion of a fluid to the surface.  Note: currently it is assumed that all fluids have the same adhesion coefficient.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/wall_boundary/system.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.BoundaryDEMSystem" href="#TrixiParticles.BoundaryDEMSystem"><code>TrixiParticles.BoundaryDEMSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryDEMSystem(initial_condition, normal_stiffness)</code></pre><p>System for boundaries modeled by boundary particles. The interaction between fluid and boundary particles is specified by the boundary model.</p><div class="admonition is-warning" id="Experimental-Implementation-7d5a1ecc0b4e63f5"><header class="admonition-header">Experimental Implementation<a class="admonition-anchor" href="#Experimental-Implementation-7d5a1ecc0b4e63f5" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in a future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/dem_boundary/system.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.PrescribedMotion" href="#TrixiParticles.PrescribedMotion"><code>TrixiParticles.PrescribedMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrescribedMotion(movement_function, is_moving; moving_particles=nothing)</code></pre><p><strong>Arguments</strong></p><ul><li><code>movement_function</code>: Function of <code>(x, t)</code> where <code>x</code> is an <code>SVector</code> of the <em>initial</em>                      particle position and <code>t</code> is the time, returning an <code>SVector</code>                      of <span>$d$</span> dimensions for a <span>$d$</span>-dimensional problem containing                      the new particle position at time <code>t</code>.</li><li><code>is_moving</code>:         Function of <code>t</code> to determine in each timestep if the particles                      are moving or not. Its boolean return value determines                      if the neighborhood search will be updated.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>moving_particles</code>: Indices of moving particles. Default is each particle in the system.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Circular motion of particles for t &lt; 1.5
movement_function(x, t) = x + SVector(cos(2pi * t), sin(2pi * t))
is_moving(t) = t &lt; 1.5

motion = PrescribedMotion(movement_function, is_moving)

# Rotation around the origin
movement_function2(x, t) = SVector(cos(2pi * t) * x[1] - sin(2pi * t) * x[2],
                                   sin(2pi * t) * x[1] + cos(2pi * t) * x[2])
is_moving2(t) = true

motion2 = PrescribedMotion(movement_function2, is_moving2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/prescribed_motion.jl#L1-L34">source</a></section></article><h1 id="boundary_models"><a class="docs-heading-anchor" href="#boundary_models">Boundary Models</a><a id="boundary_models-1"></a><a class="docs-heading-anchor-permalink" href="#boundary_models" title="Permalink"></a></h1><h2 id="Dummy-Particles"><a class="docs-heading-anchor" href="#Dummy-Particles">Dummy Particles</a><a id="Dummy-Particles-1"></a><a class="docs-heading-anchor-permalink" href="#Dummy-Particles" title="Permalink"></a></h2><p>Boundaries modeled as dummy particles, which are treated like fluid particles, but their positions and velocities are not evolved in time. Since the force towards the fluid should not change with the material density when used with a <a href="../total_lagrangian_sph/#TrixiParticles.TotalLagrangianSPHSystem"><code>TotalLagrangianSPHSystem</code></a>, the dummy particles need to have a mass corresponding to the fluid&#39;s rest density, which we call &quot;hydrodynamic mass&quot;, as opposed to mass corresponding to the material density of a <a href="../total_lagrangian_sph/#TrixiParticles.TotalLagrangianSPHSystem"><code>TotalLagrangianSPHSystem</code></a>.</p><p>Here, <code>initial_density</code> and <code>hydrodynamic_mass</code> are vectors that contains the initial density and the hydrodynamic mass respectively for each boundary particle. Note that when used with <a href="../../general/density_calculators/#TrixiParticles.SummationDensity"><code>SummationDensity</code></a> (see below), this is only used to determine the element type and the number of boundary particles.</p><p>To establish a relationship between density and pressure, a <code>state_equation</code> has to be passed, which should be the same as for the adjacent fluid systems. To sum over neighboring particles, a <code>smoothing_kernel</code> and <code>smoothing_length</code> needs to be passed. This should be the same as for the adjacent fluid system with the largest smoothing length.</p><p>In the literature, this kind of boundary particles is referred to as &quot;dummy particles&quot; (<a href="../../references/#Adami2012">Adami et al., 2012</a> and <a href="../../references/#Valizadeh2015">Valizadeh &amp; Monaghan, 2015</a>), &quot;frozen fluid particles&quot; (<a href="../../references/#Akinci2012">Akinci et al., 2012</a>) or &quot;dynamic boundaries <a href="../../references/#Crespo2007">Crespo et al., 2007</a>. The key detail of this boundary condition and the only difference between the boundary models in these references is the way the density and pressure of boundary particles is computed.</p><p>Since boundary particles are treated like fluid particles, the force on fluid particle <span>$a$</span> due to boundary particle <span>$b$</span> is given by</p><p class="math-container">\[f_{ab} = m_a m_b \left( \frac{p_a}{\rho_a^2} + \frac{p_b}{\rho_b^2} \right) \nabla_{r_a} W(\Vert r_a - r_b \Vert, h).\]</p><p>The quantities to be defined here are the density <span>$\rho_b$</span> and pressure <span>$p_b$</span> of the boundary particle <span>$b$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.BoundaryModelDummyParticles" href="#TrixiParticles.BoundaryModelDummyParticles"><code>TrixiParticles.BoundaryModelDummyParticles</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryModelDummyParticles(initial_density, hydrodynamic_mass,
                            density_calculator, smoothing_kernel,
                            smoothing_length; viscosity=nothing,
                            state_equation=nothing, correction=nothing,
                            reference_particle_spacing=0.0)</code></pre><p>Boundary model for <a href="#TrixiParticles.WallBoundarySystem"><code>WallBoundarySystem</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>initial_density</code>: Vector holding the initial density of each boundary particle.</li><li><code>hydrodynamic_mass</code>: Vector holding the &quot;hydrodynamic mass&quot; of each boundary particle.                      See description above for more information.</li><li><code>density_calculator</code>: Strategy to compute the hydrodynamic density of the boundary particles.                       See description below for more information.</li><li><code>smoothing_kernel</code>: Smoothing kernel should be the same as for the adjacent fluid system.</li><li><code>smoothing_length</code>: Smoothing length should be the same as for the adjacent fluid system.</li></ul><p><strong>Keywords</strong></p><ul><li><code>state_equation</code>:             This should be the same as for the adjacent fluid system                               (see e.g. <a href="../weakly_compressible_sph/#TrixiParticles.StateEquationCole"><code>StateEquationCole</code></a>).</li><li><code>correction</code>:                 Correction method of the adjacent fluid system (see <a href="../fluid/#corrections">Corrections</a>).</li><li><code>viscosity</code>:                  Slip (default) or no-slip condition. See description below for further                               information.</li><li><code>reference_particle_spacing</code>: The reference particle spacing used for weighting values at the boundary,                               which currently is only needed when using surface tension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Free-slip condition
boundary_model = BoundaryModelDummyParticles(densities, masses, AdamiPressureExtrapolation(),
                                             smoothing_kernel, smoothing_length)

# No-slip condition
boundary_model = BoundaryModelDummyParticles(densities, masses, AdamiPressureExtrapolation(),
                                             smoothing_kernel, smoothing_length,
                                             viscosity=ViscosityAdami(nu=1e-6))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/wall_boundary/dummy_particles.jl#L1-L41">source</a></section></article><h3 id="Hydrodynamic-density-of-dummy-particles"><a class="docs-heading-anchor" href="#Hydrodynamic-density-of-dummy-particles">Hydrodynamic density of dummy particles</a><a id="Hydrodynamic-density-of-dummy-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrodynamic-density-of-dummy-particles" title="Permalink"></a></h3><p>We provide six options to compute the boundary density and pressure, determined by the <code>density_calculator</code>:</p><ol><li>(Recommended) With <a href="#TrixiParticles.AdamiPressureExtrapolation"><code>AdamiPressureExtrapolation</code></a>, the pressure is extrapolated from the pressure of the fluid according to <a href="../../references/#Adami2012">Adami et al., 2012</a>, and the density is obtained by applying the inverse of the state equation. This option usually yields the best results of the options listed here.</li><li>(Only relevant for FSI) With <a href="#TrixiParticles.BernoulliPressureExtrapolation"><code>BernoulliPressureExtrapolation</code></a>, the pressure is extrapolated from the pressure similar to the <a href="#TrixiParticles.AdamiPressureExtrapolation"><code>AdamiPressureExtrapolation</code></a>, but a relative velocity-dependent pressure part is calculated between moving bodies and fluids, which increases the boundary pressure in areas prone to penetrations.</li><li>With <a href="../../general/density_calculators/#TrixiParticles.SummationDensity"><code>SummationDensity</code></a>, the density is calculated by summation over the neighboring particles, and the pressure is computed from the density with the state equation.</li><li>With <a href="../../general/density_calculators/#TrixiParticles.ContinuityDensity"><code>ContinuityDensity</code></a>, the density is integrated from the continuity equation, and the pressure is computed from the density with the state equation. Note that this causes a gap between fluid and boundary where the boundary is initialized without any contact to the fluid. This is due to overestimation of the boundary density as soon as the fluid comes in contact with boundary particles that initially did not have contact to the fluid. Therefore, in dam break simulations, there is a visible &quot;step&quot;, even though the boundary is supposed to be flat. See also <a href="https://dual.sphysics.org/faq/#Q_13">dual.sphysics.org/faq/#Q_13</a>.</li><li>With <a href="#TrixiParticles.PressureZeroing"><code>PressureZeroing</code></a>, the density is set to the reference density and the pressure is computed from the density with the state equation. This option is not recommended. The other options yield significantly better results.</li><li>With <a href="#TrixiParticles.PressureMirroring"><code>PressureMirroring</code></a>, the density is set to the reference density. The pressure is not used. Instead, the fluid pressure is mirrored as boundary pressure in the momentum equation. This option is not recommended due to stability issues. See <a href="#TrixiParticles.PressureMirroring"><code>PressureMirroring</code></a> for more details.</li></ol><h4 id="1.-[AdamiPressureExtrapolation](@ref)"><a class="docs-heading-anchor" href="#1.-[AdamiPressureExtrapolation](@ref)">1. <a href="#TrixiParticles.AdamiPressureExtrapolation"><code>AdamiPressureExtrapolation</code></a></a><a id="1.-[AdamiPressureExtrapolation](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-[AdamiPressureExtrapolation](@ref)" title="Permalink"></a></h4><p>The pressure of the boundary particles is obtained by extrapolating the pressure of the fluid according to <a href="../../references/#Adami2012">Adami et al., 2012</a>. The pressure of a boundary particle <span>$b$</span> is given by</p><p class="math-container">\[p_b = \frac{\sum_f (p_f + \rho_f (\bm{g} - \bm{a}_b) \cdot \bm{r}_{bf}) W(\Vert r_{bf} \Vert, h)}{\sum_f W(\Vert r_{bf} \Vert, h)},\]</p><p>where the sum is over all fluid particles, <span>$\rho_f$</span> and <span>$p_f$</span> denote the density and pressure of fluid particle <span>$f$</span>, respectively, <span>$r_{bf} = r_b - r_f$</span> denotes the difference of the coordinates of particles <span>$b$</span> and <span>$f$</span>, <span>$\bm{g}$</span> denotes the gravitational acceleration acting on the fluid, and <span>$\bm{a}_b$</span> denotes the acceleration of the boundary particle <span>$b$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.AdamiPressureExtrapolation" href="#TrixiParticles.AdamiPressureExtrapolation"><code>TrixiParticles.AdamiPressureExtrapolation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdamiPressureExtrapolation(; pressure_offset=0, allow_loop_flipping=true)</code></pre><p><code>density_calculator</code> for <code>BoundaryModelDummyParticles</code>.</p><p><strong>Keywords</strong></p><ul><li><code>pressure_offset=0</code>: Sometimes it is necessary to artificially increase the boundary pressure                      to prevent penetration, which is possible by increasing this value.</li><li><code>allow_loop_flipping=true</code>: Allow to flip the loop order for the pressure extrapolation.                             Disable to prevent error variations between simulations with                             different numbers of threads.                             Usually, the first (multithreaded) loop is over the boundary                             particles and the second loop over the fluid neighbors.                             When the number of boundary particles is larger than                             <code>ceil(0.5 * nthreads())</code> times the number of fluid particles,                             it is usually more efficient to flip the loop order and loop                             over the fluid particles first.                             The factor depends on the number of threads, as the flipped                             loop is not thread parallelizable.                             This can cause error variations between simulations with                             different numbers of threads.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/wall_boundary/dummy_particles.jl#L89-L111">source</a></section></article><h4 id="2.-[BernoulliPressureExtrapolation](@ref)"><a class="docs-heading-anchor" href="#2.-[BernoulliPressureExtrapolation](@ref)">2. <a href="#TrixiParticles.BernoulliPressureExtrapolation"><code>BernoulliPressureExtrapolation</code></a></a><a id="2.-[BernoulliPressureExtrapolation](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#2.-[BernoulliPressureExtrapolation](@ref)" title="Permalink"></a></h4><p>Identical to the pressure <span>$p_b$</span> calculated via <a href="#TrixiParticles.AdamiPressureExtrapolation"><code>AdamiPressureExtrapolation</code></a>, but it adds the dynamic pressure component of the Bernoulli equation:</p><p class="math-container">\[p_b = \frac{\sum_f (p_f + \frac{1}{2} \, \rho_{\text{neighbor}} \left( \frac{ (\mathbf{v}_f - \mathbf{v}_{\text{body}}) \cdot (\mathbf{x}_f - \mathbf{x}_{\text{neighbor}}) }{ \left\| \mathbf{x}_f - \mathbf{x}_{\text{neighbor}} \right\| } \right)^2 \times \text{factor} +\rho_f (\bm{g} - \bm{a}_b) \cdot \bm{r}_{bf}) W(\Vert r_{bf} \Vert, h)}{\sum_f W(\Vert r_{bf} \Vert, h)}\]</p><p>where <span>$\mathbf{v}_f$</span> is the velocity of the fluid and <span>$\mathbf{v}_{\text{body}}$</span> is the velocity of the body. This adjustment provides a higher boundary pressure for bodies moving with a relative velocity to the fluid to prevent penetration. This modification is original and not derived from any literature source.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.BernoulliPressureExtrapolation" href="#TrixiParticles.BernoulliPressureExtrapolation"><code>TrixiParticles.BernoulliPressureExtrapolation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BernoulliPressureExtrapolation(; pressure_offset=0, factor=1)</code></pre><p><code>density_calculator</code> for <code>BoundaryModelDummyParticles</code>.</p><p><strong>Keywords</strong></p><ul><li><code>pressure_offset=0</code>:   Sometimes it is necessary to artificially increase the boundary pressure                        to prevent penetration, which is possible by increasing this value.</li><li><code>factor=1</code>         :   Setting <code>factor</code> allows to just increase the strength of the dynamic                        pressure part.</li><li><code>allow_loop_flipping=true</code>: Allow to flip the loop order for the pressure extrapolation.                             Disable to prevent error variations between simulations with                             different numbers of threads.                             Usually, the first (multithreaded) loop is over the boundary                             particles and the second loop over the fluid neighbors.                             When the number of boundary particles is larger than                             <code>ceil(0.5 * nthreads())</code> times the number of fluid particles,                             it is usually more efficient to flip the loop order and loop                             over the fluid particles first.                             The factor depends on the number of threads, as the flipped                             loop is not thread parallelizable.                             This can cause error variations between simulations with                             different numbers of threads.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/wall_boundary/dummy_particles.jl#L121-L145">source</a></section></article><h4 id="5.-[PressureZeroing](@ref)"><a class="docs-heading-anchor" href="#5.-[PressureZeroing](@ref)">5. <a href="#TrixiParticles.PressureZeroing"><code>PressureZeroing</code></a></a><a id="5.-[PressureZeroing](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#5.-[PressureZeroing](@ref)" title="Permalink"></a></h4><p>This is the simplest way to implement dummy boundary particles. The density of each particle is set to the reference density and the pressure to the reference pressure (the corresponding pressure to the reference density by the state equation).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.PressureZeroing" href="#TrixiParticles.PressureZeroing"><code>TrixiParticles.PressureZeroing</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PressureZeroing()</code></pre><p><code>density_calculator</code> for <code>BoundaryModelDummyParticles</code>.</p><div class="admonition is-info" id="Note-20770501a58f62b2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-20770501a58f62b2" title="Permalink"></a></header><div class="admonition-body"><p>This boundary model produces significantly worse results than all other models and is only included for research purposes.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/wall_boundary/dummy_particles.jl#L172-L180">source</a></section></article><h4 id="6.-[PressureMirroring](@ref)"><a class="docs-heading-anchor" href="#6.-[PressureMirroring](@ref)">6. <a href="#TrixiParticles.PressureMirroring"><code>PressureMirroring</code></a></a><a id="6.-[PressureMirroring](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#6.-[PressureMirroring](@ref)" title="Permalink"></a></h4><p>Instead of calculating density and pressure for each boundary particle, we modify the momentum equation,</p><p class="math-container">\[\frac{\mathrm{d}v_a}{\mathrm{d}t} = -\sum_b m_b \left( \frac{p_a}{\rho_a^2} + \frac{p_b}{\rho_b^2} \right) \nabla_a W_{ab}\]</p><p>to replace the unknown density <span>$\rho_b$</span> if <span>$b$</span> is a boundary particle by the reference density and the unknown pressure <span>$p_b$</span> if <span>$b$</span> is a boundary particle by the pressure <span>$p_a$</span> of the interacting fluid particle. The momentum equation therefore becomes</p><p class="math-container">\[\frac{\mathrm{d}v_a}{\mathrm{d}t} = -\sum_f m_f \left( \frac{p_a}{\rho_a^2} + \frac{p_f}{\rho_f^2} \right) \nabla_a W_{af}
-\sum_b m_b \left( \frac{p_a}{\rho_a^2} + \frac{p_a}{\rho_0^2} \right) \nabla_a W_{ab},\]</p><p>where the first sum is over all fluid particles and the second over all boundary particles.</p><p>This approach was first mentioned by <a href="../../references/#Akinci2012">Akinci et al. (2012)</a> and written down in this form by <a href="../../references/#Band2018">Band et al. (2018)</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.PressureMirroring" href="#TrixiParticles.PressureMirroring"><code>TrixiParticles.PressureMirroring</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PressureMirroring()</code></pre><p><code>density_calculator</code> for <code>BoundaryModelDummyParticles</code>.</p><div class="admonition is-info" id="Note-a518627fd3d119b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a518627fd3d119b" title="Permalink"></a></header><div class="admonition-body"><p>This boundary model requires high viscosity for stability with WCSPH. It also produces significantly worse results than <a href="#TrixiParticles.AdamiPressureExtrapolation"><code>AdamiPressureExtrapolation</code></a> and is not more efficient because smaller time steps are required due to more noise in the pressure. We added this model only for research purposes and for comparison with <a href="https://github.com/InteractiveComputerGraphics/SPlisHSPlasH">SPlisHSPlasH</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/wall_boundary/dummy_particles.jl#L157-L169">source</a></section></article><h3 id="No-slip-conditions"><a class="docs-heading-anchor" href="#No-slip-conditions">No-slip conditions</a><a id="No-slip-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#No-slip-conditions" title="Permalink"></a></h3><p>For the interaction of dummy particles and fluid particles, <a href="../../references/#Adami2012">Adami et al. (2012)</a> impose a no-slip boundary condition by assigning a wall velocity <span>$v_w$</span> to the dummy particle.</p><p>The wall velocity of particle <span>$a$</span> is calculated from the prescribed boundary particle velocity <span>$v_a$</span> and the smoothed velocity field</p><p class="math-container">\[v_w = 2 v_a - \frac{\sum_b v_b W_{ab}}{\sum_b W_{ab}},\]</p><p>where the sum is over all fluid particles.</p><p>By choosing the viscosity model <a href="../fluid/#ViscosityAdami"><code>ViscosityAdami</code></a> for <code>viscosity</code>, a no-slip condition is imposed. It is recommended to choose <code>nu</code> in the order of either the kinematic viscosity parameter of the adjacent fluid or the equivalent from the artificial parameter <code>alpha</code> of the adjacent fluid (<span>$\nu = \frac{\alpha h c }{2d + 4}$</span>). When omitting the viscous interaction (default <code>viscosity=nothing</code>), a free-slip wall boundary condition is applied.</p><div class="admonition is-warning" id="Warning-13910445ad04928d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-13910445ad04928d" title="Permalink"></a></header><div class="admonition-body"><p>The viscosity model <a href="../fluid/#ArtificialViscosityMonaghan"><code>ArtificialViscosityMonaghan</code></a> for <a href="#TrixiParticles.BoundaryModelDummyParticles"><code>BoundaryModelDummyParticles</code></a> has not been verified yet.</p></div></div><h2 id="Repulsive-Particles"><a class="docs-heading-anchor" href="#Repulsive-Particles">Repulsive Particles</a><a id="Repulsive-Particles-1"></a><a class="docs-heading-anchor-permalink" href="#Repulsive-Particles" title="Permalink"></a></h2><p>Boundaries modeled as boundary particles which exert forces on the fluid particles (<a href="../../references/#Monaghan2009">Monaghan, Kajtar, 2009</a>). The force on fluid particle <span>$a$</span> due to boundary particle <span>$b$</span> is given by</p><p class="math-container">\[f_{ab} = m_a \left(\tilde{f}_{ab} - m_b \Pi_{ab} \nabla_{r_a} W(\Vert r_a - r_b \Vert, h)\right)\]</p><p>with</p><p class="math-container">\[\tilde{f}_{ab} = \frac{K}{\beta^{n-1}} \frac{r_{ab}}{\Vert r_{ab} \Vert (\Vert r_{ab} \Vert - d)} \Phi(\Vert r_{ab} \Vert, h)
\frac{2 m_b}{m_a + m_b},\]</p><p>where <span>$m_a$</span> and <span>$m_b$</span> are the masses of fluid particle <span>$a$</span> and boundary particle <span>$b$</span> respectively, <span>$r_{ab} = r_a - r_b$</span> is the difference of the coordinates of particles <span>$a$</span> and <span>$b$</span>, <span>$d$</span> denotes the boundary particle spacing and <span>$n$</span> denotes the number of dimensions (see <a href="../../references/#Monaghan2009">Monaghan &amp; Kajtar, 2009</a>, Equation (3.1) and <a href="../../references/#Valizadeh2015">Valizadeh &amp; Monaghan, 2015</a>). Note that the repulsive acceleration <span>$\tilde{f}_{ab}$</span> does not depend on the masses of the boundary particles. Here, <span>$\Phi$</span> denotes the 1D Wendland C4 kernel, normalized to <span>$1.77$</span> for <span>$q=0$</span> (<a href="../../references/#Monaghan2009">Monaghan &amp; Kajtar, 2009</a>, Section 4), with <span>$\Phi(r, h) = w(r/h)$</span> and</p><p class="math-container">\[w(q) =
\begin{cases}
  (1.77/32) (1 + (5/2)q + 2q^2)(2 - q)^5  &amp; \text{if } 0 \leq q &lt; 2 \\
  0                                       &amp; \text{if } q \geq 2.
\end{cases}\]</p><p>The boundary particles are assumed to have uniform spacing by the factor <span>$\beta$</span> smaller than the expected fluid particle spacing. For example, if the fluid particles have an expected spacing of <span>$0.3$</span> and the boundary particles have a uniform spacing of <span>$0.1$</span>, then this parameter should be set to <span>$\beta = 3$</span>. According to <a href="../../references/#Monaghan2009">Monaghan &amp; Kajtar (2009)</a>, a value of <span>$\beta = 3$</span> for the Wendland C4 that we use here is reasonable for most computing purposes.</p><p>The parameter <span>$K$</span> is used to scale the force exerted by the boundary particles. In <a href="../../references/#Monaghan2009">Monaghan &amp; Kajtar (2009)</a>, a value of <span>$gD$</span> is used for static tank simulations, where <span>$g$</span> is the gravitational acceleration and <span>$D$</span> is the depth of the fluid.</p><p>The viscosity <span>$\Pi_{ab}$</span> is calculated according to the viscosity used in the simulation, where the density of the boundary particle if needed is assumed to be identical to the density of the fluid particle.</p><h3 id="No-slip-condition"><a class="docs-heading-anchor" href="#No-slip-condition">No-slip condition</a><a id="No-slip-condition-1"></a><a class="docs-heading-anchor-permalink" href="#No-slip-condition" title="Permalink"></a></h3><p>By choosing the viscosity model <a href="../fluid/#ArtificialViscosityMonaghan"><code>ArtificialViscosityMonaghan</code></a> for <code>viscosity</code>, a no-slip condition is imposed. When omitting the viscous interaction (default <code>viscosity=nothing</code>), a free-slip wall boundary condition is applied.</p><div class="admonition is-warning" id="Warning-3c644fc70c4e623c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3c644fc70c4e623c" title="Permalink"></a></header><div class="admonition-body"><p>The no-slip conditions for <code>BoundaryModelMonaghanKajtar</code> have not been verified yet.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.BoundaryModelMonaghanKajtar" href="#TrixiParticles.BoundaryModelMonaghanKajtar"><code>TrixiParticles.BoundaryModelMonaghanKajtar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryModelMonaghanKajtar(K, beta, boundary_particle_spacing, mass;
                            viscosity=nothing)</code></pre><p>Boundary model for <a href="#TrixiParticles.WallBoundarySystem"><code>WallBoundarySystem</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>K</code>: Scaling factor for repulsive force.</li><li><code>beta</code>: Ratio of fluid particle spacing to boundary particle spacing.</li><li><code>boundary_particle_spacing</code>: Boundary particle spacing.</li><li><code>mass</code>: Vector holding the mass of each boundary particle.</li></ul><p><strong>Keywords</strong></p><ul><li><code>viscosity</code>:  Free-slip (default) or no-slip condition. See description above for further               information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/wall_boundary/monaghan_kajtar.jl#L1-L16">source</a></section></article><h1 id="open_boundary"><a class="docs-heading-anchor" href="#open_boundary">Open Boundaries</a><a id="open_boundary-1"></a><a class="docs-heading-anchor-permalink" href="#open_boundary" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.OpenBoundarySystem" href="#TrixiParticles.OpenBoundarySystem"><code>TrixiParticles.OpenBoundarySystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpenBoundarySystem(boundary_zone::BoundaryZone;
                   fluid_system::AbstractFluidSystem, buffer_size::Integer,
                   boundary_model)</code></pre><p>Open boundary system for in- and outflow particles.</p><p><strong>Arguments</strong></p><ul><li><code>boundary_zone</code>: See <a href="#TrixiParticles.BoundaryZone"><code>BoundaryZone</code></a>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fluid_system</code>: The corresponding fluid system</li><li><code>boundary_model</code>: Boundary model (see <a href="#open_boundary_models">Open Boundary Models</a>)</li><li><code>buffer_size</code>: Number of buffer particles.</li></ul><div class="admonition is-warning" id="Experimental-Implementation-4c84b787f3b86233"><header class="admonition-header">Experimental Implementation<a class="admonition-anchor" href="#Experimental-Implementation-4c84b787f3b86233" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in any future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/open_boundary/system.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.BoundaryZone" href="#TrixiParticles.BoundaryZone"><code>TrixiParticles.BoundaryZone</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryZone(; boundary_face, face_normal, density, particle_spacing,
             initial_condition=nothing, extrude_geometry=nothing,
             open_boundary_layers::Integer, average_inflow_velocity=true,
             boundary_type=BidirectionalFlow(),
             reference_density=nothing, reference_pressure=nothing,
             reference_velocity=nothing)</code></pre><p>Boundary zone for <a href="#TrixiParticles.OpenBoundarySystem"><code>OpenBoundarySystem</code></a>.</p><p>The specified <code>boundary_face</code> (line in 2D or rectangle in 3D) will be extruded in the direction opposite to <code>face_normal</code> to create a box for the boundary zone. To specify the <code>boundary_face</code>, pass the required vertices as described below. For complex 3D simulations, these vertices can also be extracted from an STL file (see <a href="#TrixiParticles.planar_geometry_to_face-Tuple{TrixiParticles.TriangleMesh}"><code>planar_geometry_to_face</code></a>). There are three ways to specify the actual shape of the boundary zone:</p><ol><li>Don&#39;t pass <code>initial_condition</code> or <code>extrude_geometry</code>. The boundary zone box will then be filled with boundary particles (default).</li><li>Specify <code>extrude_geometry</code> by passing a 1D shape in 2D or a 2D shape in 3D, which is then extruded in the direction opposite to <code>face_normal</code> to create the boundary particles.<ul><li>In 2D, the shape must be either an initial condition with 2D coordinates, which lies on the line specified by <code>boundary_face</code>, or an initial condition with 1D coordinates, which lies on the line specified by <code>boundary_face</code> when a y-coordinate of <code>0</code> is added.</li><li>In 3D, the shape must be either an initial condition with 3D coordinates, which lies in the rectangle specified by <code>boundary_face</code>, or an initial condition with 2D coordinates, which lies in the rectangle specified by <code>boundary_face</code> when a z-coordinate of <code>0</code> is added.</li></ul></li><li>Specify <code>initial_condition</code> by passing a 2D initial condition in 2D or a 3D initial condition in 3D, which will be used for the boundary particles.</li></ol><div class="admonition is-info" id="Note-6f122264f5d91d89"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6f122264f5d91d89" title="Permalink"></a></header><div class="admonition-body"><p>Particles outside the boundary zone box will be removed.</p></div></div><p><strong>Keywords</strong></p><ul><li><code>boundary_face</code>: Tuple of vertices defining a part of the surface of the domain.                  The vertices must either span a line in 2D or a rectangle in 3D.                  This line or rectangle is then extruded in upstream direction to obtain                  the boundary zone.                  In 2D, pass two vertices <span>$(A, B)$</span>, so that the interval <span>$[A, B]$</span> is                  the inflow surface.                  In 3D, pass three vertices <span>$(A, B, C)$</span>, so that the rectangular inflow surface                  is spanned by the vectors <span>$\widehat{AB}$</span> and <span>$\widehat{AC}$</span>.                  These two vectors must be orthogonal.</li><li><code>face_normal</code>: Vector defining the normal of the <code>boundary_face</code>. It always points inside the fluid domain.</li><li><code>boundary_type=BidirectionalFlow()</code>: Specify the type of the boundary. Available types are<ul><li><code>InFlow()</code> for an inflow boundary</li><li><code>OutFlow()</code> for an outflow boundary</li><li><code>BidirectionalFlow()</code> (default) for an bidirectional flow boundary</li></ul></li><li><code>open_boundary_layers</code>: Number of particle layers in the direction opposite to <code>face_normal</code>.</li><li><code>particle_spacing</code>: The spacing between the particles (see <a href="../../general/initial_condition/#TrixiParticles.InitialCondition"><code>InitialCondition</code></a>).</li><li><code>density</code>: Particle density (see <a href="../../general/initial_condition/#TrixiParticles.InitialCondition"><code>InitialCondition</code></a>).</li><li><code>initial_condition=nothing</code>: <code>InitialCondition</code> for the inflow particles.                              Particles outside the boundary zone will be removed.                              Do not use together with <code>extrude_geometry</code>.</li><li><code>extrude_geometry=nothing</code>: 1D shape in 2D or 2D shape in 3D, which lies on the <code>boundary_face</code>                             and is extruded upstream to obtain the inflow particles.                             See point 2 above for more details.</li><li><code>average_inflow_velocity=true</code>: If <code>true</code>, the extrapolated inflow velocity is averaged                                 to impose a uniform inflow profile.                                 When no velocity is prescribed at the inflow,                                 the velocity is extrapolated from the fluid domain.                                 Thus, turbulent flows near the inflow can lead to                                 anisotropic buffer-particles distribution,                                 resulting in a potential numerical instability.                                 Averaging mitigates these effects.</li><li><code>reference_velocity</code>: Reference velocity is either a function mapping each particle&#39;s coordinates                       and time to its velocity, or, for a constant fluid velocity,                       a vector holding this velocity.</li><li><code>reference_pressure</code>: Reference pressure is either a function mapping each particle&#39;s coordinates                       and time to its pressure, or a scalar for a constant pressure over all particles.</li><li><code>reference_density</code>: Reference density is either a function mapping each particle&#39;s coordinates                      and time to its density, or a scalar for a constant density over all particles.</li></ul><div class="admonition is-info" id="Note-8cf3a7de03ed4874"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8cf3a7de03ed4874" title="Permalink"></a></header><div class="admonition-body"><p>The reference values (<code>reference_velocity</code>, <code>reference_pressure</code>, <code>reference_density</code>) can also be set to <code>nothing</code>. In this case, they will either be extrapolated from the fluid domain (<a href="#TrixiParticles.BoundaryModelMirroringTafuni">BoundaryModelMirroringTafuni</a>) or evolved using the characteristic flow variables (<a href="#TrixiParticles.BoundaryModelCharacteristicsLastiwka">BoundaryModelCharacteristicsLastiwka</a>).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 2D
face_vertices = ([0.0, 0.0], [0.0, 1.0])
face_normal = [1.0, 0.0]

# Constant reference velocity:
velocity_const = [1.0, 0.0]

inflow_1 = BoundaryZone(; boundary_face=face_vertices, face_normal, particle_spacing=0.1,
                        density=1.0, open_boundary_layers=4, boundary_type=InFlow(),
                        reference_velocity=velocity_const)

# Reference velocity as a function (parabolic velocity profile):
velocity_func = (pos, t) -&gt; SVector(4.0 * pos[2] * (1.0 - pos[2]), 0.0)

inflow_2 = BoundaryZone(; boundary_face=face_vertices, face_normal, particle_spacing=0.1,
                        density=1.0, open_boundary_layers=4, boundary_type=InFlow(),
                        reference_velocity=velocity_func)

# 3D
face_vertices = ([0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0])
face_normal = [0.0, 0.0, 1.0]

# Constant reference pressure:
pressure_const = 0.0

outflow_1 = BoundaryZone(; boundary_face=face_vertices, face_normal, particle_spacing=0.1,
                         density=1.0, open_boundary_layers=4, boundary_type=OutFlow(),
                         reference_pressure=pressure_const)

# Reference pressure as a function (y-dependent profile, sinusoidal in time):
pressure_func = (pos, t) -&gt; pos[2] * sin(2pi * t)

outflow_2 = BoundaryZone(; boundary_face=face_vertices, face_normal, particle_spacing=0.1,
                         density=1.0, open_boundary_layers=4, boundary_type=OutFlow(),
                         reference_pressure=pressure_func)

# 3D particles sampled as cylinder
circle = SphereShape(0.1, 0.5, (0.5, 0.5), 1.0, sphere_type=RoundSphere())

bidirectional_flow = BoundaryZone(; boundary_face=face_vertices, face_normal,
                                  particle_spacing=0.1, density=1.0,
                                  boundary_type=BidirectionalFlow(),
                                  extrude_geometry=circle, open_boundary_layers=4)</code></pre><div class="admonition is-warning" id="Experimental-Implementation-4c84b787f3b86233"><header class="admonition-header">Experimental Implementation<a class="admonition-anchor" href="#Experimental-Implementation-4c84b787f3b86233" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in any future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/open_boundary/boundary_zones.jl#L7-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.planar_geometry_to_face-Tuple{TrixiParticles.TriangleMesh}" href="#TrixiParticles.planar_geometry_to_face-Tuple{TrixiParticles.TriangleMesh}"><code>TrixiParticles.planar_geometry_to_face</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">planar_geometry_to_face(planar_geometry::TriangleMesh)</code></pre><p>Extracts a simplified rectangular face and its normal vector from an arbitrary planar geometry (<code>TriangleMesh</code> loaded via <a href="../../preprocessing/preprocessing/#TrixiParticles.load_geometry-Tuple{Any}"><code>load_geometry</code></a>) for use as a boundary zone interface in <a href="#TrixiParticles.BoundaryZone"><code>BoundaryZone</code></a>. This function computes the corner points of an oriented bounding box that best represents the essential orientation and extent of the input geometry. The geometry must be planar (all vertices should lie in the same plane), but can have complex or non-rectangular boundaries.</p><div class="admonition is-info" id="Face-Normal-Orientation-a9bc56e181f0a760"><header class="admonition-header">Face Normal Orientation<a class="admonition-anchor" href="#Face-Normal-Orientation-a9bc56e181f0a760" title="Permalink"></a></header><div class="admonition-body"><p>All face normals of the input geometry must point inside the fluid domain. The returned plane normal is computed by averaging all face normals, so consistent orientation is required.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>planar_geometry</code>: A planar geometry (<code>TriangleMesh</code> loaded via <a href="../../preprocessing/preprocessing/#TrixiParticles.load_geometry-Tuple{Any}"><code>load_geometry</code></a>).</li></ul><p><strong>Returns</strong></p><ul><li><code>face_vertices</code>: Tuple of three vertices defining the rectangular face (corner points of the oriented bounding box).</li><li><code>face_normal</code>: Normalized normal vector of the face.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">file = pkgdir(TrixiParticles, &quot;test&quot;, &quot;preprocessing&quot;, &quot;data&quot;)
planar_geometry = load_geometry(joinpath(file, &quot;inflow_geometry.stl&quot;))

face, face_normal = planar_geometry_to_face(planar_geometry)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/preprocessing/geometries/geometries.jl#L59-L91">source</a></section></article><h1 id="open_boundary_models"><a class="docs-heading-anchor" href="#open_boundary_models">Open Boundary Models</a><a id="open_boundary_models-1"></a><a class="docs-heading-anchor-permalink" href="#open_boundary_models" title="Permalink"></a></h1><p>We offer two models for open boundaries, with the choice depending on the specific problem and flow characteristics near the boundary:</p><ol><li><a href="#method_of_characteristics"><strong>Method of characteristics</strong></a>: The method of characteristics is typically used in problems where tracking of wave propagation  or flow in a domain that interacts with open boundaries (e.g., shock waves, wave fronts, or any behavior that depends on the direction of propagation) is needed.  It avoids artificial reflections that could arise from boundary conditions.</li><li><a href="#mirroring"><strong>Mirroring</strong></a>: The mirroring method is often applied when the flow near the boundary is expected to behave in a way that is easier to model by using symmetry  or when the fluid does not exhibit complex wave behavior near the boundary (e.g., free-surface flows and simple outflow).</li></ol><h2 id="method_of_characteristics"><a class="docs-heading-anchor" href="#method_of_characteristics">Method of characteristics</a><a id="method_of_characteristics-1"></a><a class="docs-heading-anchor-permalink" href="#method_of_characteristics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.BoundaryModelCharacteristicsLastiwka" href="#TrixiParticles.BoundaryModelCharacteristicsLastiwka"><code>TrixiParticles.BoundaryModelCharacteristicsLastiwka</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryModelCharacteristicsLastiwka(; extrapolate_reference_values=nothing)</code></pre><p>Boundary model for <a href="#TrixiParticles.OpenBoundarySystem"><code>OpenBoundarySystem</code></a>. This model uses the characteristic variables to propagate the appropriate values to the outlet or inlet and was proposed by Lastiwka et al. (2009). It requires a specific flow direction to be passed to the <a href="#TrixiParticles.BoundaryZone"><code>BoundaryZone</code></a>. For more information about the method see <a href="#method_of_characteristics">description below</a>.</p><p><strong>Keywords</strong></p><ul><li><p><code>extrapolate_reference_values=nothing</code>: If one of the following mirroring methods is selected, the reference values are extrapolated from the fluid domain to the boundary particles:</p><ul><li><a href="#TrixiParticles.ZerothOrderMirroring"><code>ZerothOrderMirroring</code></a></li><li><a href="#TrixiParticles.FirstOrderMirroring"><code>FirstOrderMirroring</code></a></li><li><a href="#TrixiParticles.SimpleMirroring"><code>SimpleMirroring</code></a></li></ul><p><strong>Note:</strong> This feature is experimental and has not been fully validated yet. As of now, we are not aware of any published literature supporting its use. Note that even without this extrapolation feature, the reference values don&#39;t need to be prescribed - they&#39;re computed from the characteristics.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/open_boundary/method_of_characteristics.jl#L1-L21">source</a></section></article><p>The difficulty in non-reflecting boundary conditions, also called open boundaries, is to determine the appropriate boundary values of the exact characteristics of the Euler equations. Assuming the flow near the boundaries is normal to the boundary and free of shock waves and significant viscous effects, it can be shown that three characteristic variables exist:</p><ul><li><span>$J_1$</span>, associated with convection of entropy and propagates at flow velocity,</li><li><span>$J_2$</span>, downstream-running characteristics,</li><li><span>$J_3$</span>, upstream-running characteristics.</li></ul><p><a href="../../references/#Giles1990">Giles (1990)</a> derived those variables based on a linearized set of governing equations:</p><p class="math-container">\[J_1 = -c_s^2 (\rho - \rho_{\text{ref}}) + (p - p_{\text{ref}})\]</p><p class="math-container">\[J_2 = \rho c_s (v - v_{\text{ref}}) + (p - p_{\text{ref}})\]</p><p class="math-container">\[J_3 = - \rho c_s (v - v_{\text{ref}}) + (p - p_{\text{ref}})\]</p><p>where the subscript &quot;ref&quot; denotes the reference flow near the boundaries, which can be prescribed.</p><p>Specifying the reference variables is <strong>not</strong> equivalent to prescription of <span>$\rho$</span>, <span>$v$</span> and <span>$p$</span> directly, since the perturbation from the reference flow is allowed.</p><p><a href="../../references/#Lastiwka2008">Lastiwka et al. (2009)</a> applied the method of characteristic to SPH and determined the number of variables that should be <strong>prescribed</strong> at the boundary and the number which should be <strong>propagated</strong> from the fluid domain to the boundary:</p><ul><li><p>For an <strong>inflow</strong> boundary:</p><ul><li>Prescribe <em>downstream</em>-running characteristics <span>$J_1$</span> and <span>$J_2$</span></li><li>Transmit <span>$J_3$</span> from the fluid domain (allow <span>$J_3$</span> to propagate upstream to the boundary).</li></ul></li><li><p>For an <strong>outflow</strong> boundary:</p><ul><li>Prescribe <em>upstream</em>-running characteristic <span>$J_3$</span></li><li>Transmit <span>$J_1$</span> and <span>$J_2$</span> from the fluid domain.</li></ul></li></ul><p>Prescribing is done by simply setting the characteristics to zero. To transmit the characteristics from the fluid domain, or in other words, to carry the information of the fluid to the boundaries, <a href="../../references/#Negi2020">Negi et al. (2020)</a> use a Shepard Interpolation</p><p class="math-container">\[f_i = \frac{\sum_j^N f_j W_{ij}}{\sum_j^N W_{ij}},\]</p><p>where the <span>$i$</span>-th particle is a boundary particle, <span>$f$</span> is either  <span>$J_1$</span>, <span>$J_2$</span> or <span>$J_3$</span> and <span>$N$</span> is the set of neighboring fluid particles.</p><p>To express pressure <span>$p$</span>, density <span>$\rho$</span> and velocity <span>$v$</span> as functions of the characteristic variables, the system of equations from the characteristic variables is inverted and gives</p><p class="math-container">\[ \rho - \rho_{\text{ref}} = \frac{1}{c_s^2} \left( -J_1 + \frac{1}{2} J_2 + \frac{1}{2} J_3 \right),\]</p><p class="math-container">\[u - u_{\text{ref}}= \frac{1}{2\rho c_s} \left( J_2 - J_3 \right),\]</p><p class="math-container">\[p - p_{\text{ref}} = \frac{1}{2} \left( J_2 + J_3 \right).\]</p><p>With <span>$J_1$</span>, <span>$J_2$</span> and <span>$J_3$</span> determined, we can easily solve for the actual variables for each particle.</p><h2 id="mirroring"><a class="docs-heading-anchor" href="#mirroring">Mirroring</a><a id="mirroring-1"></a><a class="docs-heading-anchor-permalink" href="#mirroring" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.BoundaryModelMirroringTafuni" href="#TrixiParticles.BoundaryModelMirroringTafuni"><code>TrixiParticles.BoundaryModelMirroringTafuni</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryModelMirroringTafuni(; mirror_method=FirstOrderMirroring())</code></pre><p>Boundary model for the <a href="#TrixiParticles.OpenBoundarySystem"><code>OpenBoundarySystem</code></a>. This model implements the method of <a href="../../references/#Tafuni2018">Tafuni et al. (2018)</a> to extrapolate the properties from the fluid domain to the buffer zones (inflow and outflow) using ghost nodes. The position of the ghost nodes is obtained by mirroring the boundary particles into the fluid along a direction that is normal to the open boundary. Fluid properties are then interpolated at these ghost node positions using surrounding fluid particles. The values are then mirrored back to the boundary particles. We provide three different mirroring methods:     - <a href="#TrixiParticles.ZerothOrderMirroring"><code>ZerothOrderMirroring</code></a>: Uses a Shepard interpolation to interpolate the values.     - <a href="#TrixiParticles.FirstOrderMirroring"><code>FirstOrderMirroring</code></a>: Uses a first order correction based on the gradient of the interpolated values .     - <a href="#TrixiParticles.SimpleMirroring"><code>SimpleMirroring</code></a>: Similar to the first order mirroring, but does not use the gradient of the interpolated values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/open_boundary/mirroring.jl#L49-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.FirstOrderMirroring" href="#TrixiParticles.FirstOrderMirroring"><code>TrixiParticles.FirstOrderMirroring</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FirstOrderMirroring(; firstorder_tolerance=1f-3)</code></pre><p>Fluid properties are extrapolated onto ghost nodes using the method proposed by <a href="../../references/#Liu2006">Liu and Liu (2006)</a>, to extend the gradient into the boundary zone.</p><p><strong>Keywords</strong></p><ul><li><code>firstorder_tolerance=1f-3</code>: If the determinant of the correction matrix is smaller than this value,                              the method falls back to <a href="#TrixiParticles.ZerothOrderMirroring"><code>ZerothOrderMirroring</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/open_boundary/mirroring.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.SimpleMirroring" href="#TrixiParticles.SimpleMirroring"><code>TrixiParticles.SimpleMirroring</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleMirroring(; firstorder_tolerance=1f-3))</code></pre><p>This method is similar to <a href="#TrixiParticles.FirstOrderMirroring"><code>FirstOrderMirroring</code></a>, but does not use the corrected gradient as proposed by <a href="../../references/#Negi2022">Negi et al. (2022)</a>.</p><p><strong>Keywords</strong></p><ul><li><code>firstorder_tolerance=1f-3</code>: If the determinant of the correction matrix is smaller than this value,                              the method falls back to <a href="#TrixiParticles.ZerothOrderMirroring"><code>ZerothOrderMirroring</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/open_boundary/mirroring.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TrixiParticles.ZerothOrderMirroring" href="#TrixiParticles.ZerothOrderMirroring"><code>TrixiParticles.ZerothOrderMirroring</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZerothOrderMirroring()</code></pre><p>Fluid properties are interpolated onto ghost nodes using Shepard interpolation. (See slide 6 from the 4th DualSPHysics Users Workshop: <a href="https://dual.sphysics.org/4thusersworkshop/data/_uploaded/PDF_Talks_4thWorkshop/Tafuni_Lisbon2018.pdf">Tafuni, Lisbon 2018</a>). The position of the ghost nodes is obtained by mirroring the boundary particles into the fluid along a direction that is normal to the open boundary. The interpolated values at the ghost nodes are then assigned to the corresponding boundary particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/07b7fef588f4e95a9b71588d381ac9b9934f86e9/src/schemes/boundary/open_boundary/mirroring.jl#L37-L46">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../total_lagrangian_sph/">« Total Lagrangian SPH (Elastic Structure)</a><a class="docs-footer-nextpage" href="../../time_integration/">Time Integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 19 September 2025 11:52">Friday 19 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
