"""
    fill_circle(R, x_center, y_center, particle_spacing;
                x_recess=[typemax(Int), typemax(Int)],
                y_recess=[typemax(Int), typemax(Int)])

Particle filled circle.

The arguments are as follows:
- `R`:                      Radius of the circle
- `x_center`, `y_center`:   Center of the circle in x and y direction, respectively.
- `particle_spacing`:       Spacing betweeen the particles.

The keyword arguments are as follows:
- `x_recess`, `y_recess`:   Vector for recess start and end coordinates in x and y direction, respectively.

The particles are arranged in an equidistiant grid
where the distance between the points is determined by the `particle_spacing`.

For adding a recess in the circle see example below and for only drawing the circumference see [`draw_circle`](@ref).

# Example
```julia
circle = fill_circle(2.5, 0.0, 0.0, particle_spacing,
                     x_recess=[0.5, recess_length], y_recess=[0.0, recess_height])
```
"""
struct CircularShape{NDIMS, ELTYPE<:Real}
    coordinates             ::Array{ELTYPE, 2}
    masses                  ::Vector{ELTYPE}
    densities               ::Vector{ELTYPE}
    particle_spacing        ::ELTYPE
    spacing_ratio           ::ELTYPE
    n_particles_x           ::Int
    n_particles_y           ::Int

    function RectangularShape(particle_spacing, n_particles_x, n_particles_y,
                              x_position, y_position; density=0.0)
        NDIMS = 2
        ELTYPE = eltype(particle_spacing)

        n_particles = n_particles_y * n_particles_x

        coordinates = Array{Float64, 2}(undef, 2, n_particles)

        densities = density * ones(ELTYPE, n_particles)
        masses = density * particle_spacing^2 * ones(ELTYPE, n_particles)

        initialize_rectangular!(coordinates, x_position, y_position, particle_spacing,
                                n_particles_x, n_particles_y)


        return new{NDIMS, ELTYPE}(coordinates, masses, densities,
                                  particle_spacing,
                                  n_particles_x, n_particles_y)
    end
end
function fill_circle(R, x_center, y_center, particle_spacing;
                     x_recess=[typemax(Int), typemax(Int)],
                     y_recess=[typemax(Int), typemax(Int)])

    x_vec = Vector{Float64}(undef,0)
    y_vec = Vector{Float64}(undef,0)

    r(x,y) = sqrt( (x - x_center)^2 + (y - y_center)^2 )

    # recess condition
    recess(x,y) = y_recess[2] >= y >= y_recess[1] && x_recess[2] >= x >= x_recess[1]

    n_particles = round(Int, R/particle_spacing)

    for j in -n_particles : n_particles,
            i in -n_particles : n_particles

            x = x_center + i * particle_spacing
            y = y_center + j * particle_spacing

        if r(x,y) < R && !recess(x,y)
            append!(x_vec, x)
            append!(y_vec, y)
        end
    end

    particle_coords = Array{Float64, 2}(undef, 2, length(x_vec))
    particle_coords[1,:] = x_vec
    particle_coords[2,:] = y_vec

    return particle_coords
end


"""
    draw_circle(R, x_center, y_center, particle_spacing)

Circumference drawn by particles.
Unlike in [`fill_circle`](@ref), the particles are parametrized in a way
that the distance between each particle yields the `particle_spacing`.

The arguments are the same as in [`fill_circle`](@ref).

Mulitple layers are generated by calling the function additonally with the number of layers (see examples below).
Note that the radius of the circle increases by `particle_spacing` which each additional layer.

# Examples

One layer:
```julia
circle = draw_circle(2.5, 0.0, 0.0, particle_spacing)
```

Multiple layers:
```julia
circle = draw_circle(2.5, 0.0, 0.0, particle_spacing, 5)
```
"""
function draw_circle(R, x_center, y_center, particle_spacing)

    # particle_spacing = sqrt( (r_x1 - r_x2)^2 + (r_y1 - r_y2)^2 )
    # particle_spacing = sqrt( ( (R*cos(t)+R) - (R*cos(t+ Δ)+R) )^2 + ( (R*sin(t)+R) - (R*sin(t+ Δ)+R) )^2 )
    delta_t =  acos((2*R^2 - particle_spacing^2)/(2*R^2))

    t = collect(0:delta_t:2*pi-delta_t)

    # force equidistant spacing
    t = LinRange(0, 2*pi-delta_t, length(t))

    particle_coords = Array{Float64,2}(undef, 2, length(t));

    for i in eachindex(t)
        particle_coords[1, i] = R * cos(t[i]) + x_center
        particle_coords[2, i] = R * sin(t[i]) + y_center
    end

    return particle_coords
end

function draw_circle(R, x_center, y_center, particle_spacing, n_layers)

    x_vec = Vector{Float64}(undef,0)
    y_vec = Vector{Float64}(undef,0)

    for layer in 0:n_layers-1
        coords = draw_circle(R + particle_spacing*layer, x_center, y_center, particle_spacing)
        append!(x_vec, coords[1,:])
        append!(y_vec, coords[2,:])
    end

    particle_coords = Array{Float64, 2}(undef, 2, size(x_vec,1))
    particle_coords[1,:] = x_vec
    particle_coords[2,:] = y_vec

    return particle_coords
end
