"""
    SphereShape(particle_spacing, radius, center_position, density;
                  shape_type=FillSphere(), init_velocity=(0.0, 0.0))

Either a circle filled with particles or a circumference drawn by particles.

# Arguments
- `particle_spacing`:           Spacing between the particles.
- `R`:                          Radius of the circle.
- `center_position::Tuple`:     The position of the circle center as `(x,y)`.
- `density`:                    Initial density of particles.

# Keywords
- `shape_type`:    `Type` to specify the circular shape (see [`FillSphere`](@ref) and [`HollowSphere`](@ref)).
- `init_velocity`: The initial velocity of the fluid particles as `(vel_x, vel_y)`.

# Fields
- `coordinates::Matrix`:    Coordinates of the particles.
- `masses::Vector`:         Masses of the particles.
- `densities::Vector`:      Densities of the particles.

For adding a recess in the particle filled circle or for only drawing the circumference
see [`FillSphere`](@ref) and [`HollowSphere`](@ref) respectively.
"""
function SphereShape(particle_spacing, radius, center_position, density;
                     shape_type=FillSphere(), init_velocity=zeros(length(center_position)))
    if particle_spacing < eps()
        throw(ArgumentError("`particle_spacing` needs to be positive and larger than $(eps())"))
    end

    if density < eps()
        throw(ArgumentError("`density` needs to be positive and larger than $(eps())"))
    end

    NDIMS = length(center_position)
    ELTYPE = eltype(particle_spacing)

    coordinates = circular_shape_coords(shape_type, particle_spacing, radius,
                                        SVector{NDIMS}(center_position))

    n_particles = size(coordinates, 2)
    densities = density * ones(ELTYPE, n_particles)
    masses = density * particle_spacing^NDIMS * ones(ELTYPE, n_particles)
    velocities = init_velocity .* ones(ELTYPE, size(coordinates))

    return InitialCondition(coordinates, velocities, masses, densities)
end

"""
    FillSphere(; x_recess = (typemax(Int), typemax(Int)),
                 y_recess = (typemax(Int), typemax(Int)))

Particle filled circle (required by [`SphereShape`](@ref)).

The particles are arranged in an equidistiant grid
where the distance between the points is determined by the `particle_spacing`.
For adding a recess see example below.

# Keywords
- `x_recess`: Tuple for recess start and end coordinates in x direction
- `y_recess`: Tuple for recess start and end coordinates in y direction

# Example

Particle filled circle with recess:
```julia
FillSphere(x_recess=(0.5, recess_length), y_recess=(0.0, recess_height))
```

"""
struct FillSphere{ELTYPE <: Real}
    has_cutout::Bool
    cutout_min::Vector{ELTYPE}
    cutout_max::Vector{ELTYPE}

    function FillSphere(; cutout_min=[0.0, 0.0], cutout_max=[0.0, 0.0])
        # Convert tuples to vectors
        cutout_min_ = collect(cutout_min)
        cutout_max_ = collect(cutout_max)

        has_cutout = norm(cutout_max - cutout_min) > eps()
        return new{eltype(cutout_min)}(has_cutout, cutout_min_, cutout_max_)
    end
end

"""
    HollowSphere(; n_layers=1, layer_inwards=false)

Circumference drawn by particles (required by [`SphereShape`](@ref)).

Unlike in [`FillSphere`](@ref), the particles are parametrized in a way
that the distance between neighboring particles is the `particle_spacing`.

Multiple layers are generated by calling the function additionally with the number of layers (see example).

# Keywords
- `n_layers`: Number of layers
- `layer_inwards`: Boolean to extend layers inwards.

# Example

Circumference with one layer:
```julia
HollowSphere()
```

Circumference with multiple layers extending outwards:
```julia
HollowSphere(n_layers=3)
```

Circumference with multiple layers extending inwards:
```julia
HollowSphere(n_layers=3, layer_inwards=true)
```
"""
struct HollowSphere
    n_layers      :: Int
    layer_inwards :: Bool

    function HollowSphere(; n_layers=1, layer_inwards=false)
        return new{}(n_layers, layer_inwards)
    end
end

function circular_shape_coords(shape::FillSphere, particle_spacing, radius, center_position)
    @unpack has_cutout, cutout_min, cutout_max = shape

    NDIMS = length(center_position)
    ELTYPE = typeof(particle_spacing)
    coords = SVector{NDIMS, ELTYPE}[]

    n_particles = round(Int, radius / particle_spacing)

    in_cutout(x) = has_cutout && all(cutout_min .<= x .<= cutout_max)

    # Loop over all indices in [-n_particles, n_particle]^NDIMS
    for i in CartesianIndices(ntuple(_ -> (-n_particles):n_particles, NDIMS))
        x = center_position + particle_spacing * SVector(Tuple(i))

        # If `x` lies within the radius and not in the cutout
        if norm(x - center_position) < radius && !in_cutout(x)
            push!(coords, x)
        end
    end

    return reinterpret(reshape, ELTYPE, coords)
end

function circular_shape_coords(shape::HollowSphere, particle_spacing, radius, center)
    @unpack n_layers, layer_inwards = shape

    coords = zeros(3, 0)

    layers = if layer_inwards
        (-n_layers + 1):0
    else
        0:(n_layers - 1)
    end

    for layer in layers
        sphere_coords = hollow_sphere(particle_spacing, radius + particle_spacing * layer,
                                      center)
        coords = hcat(coords, sphere_coords)
    end

    return coords
end

function hollow_sphere(particle_spacing, radius, center::SVector{2})
    n_particles = round(Int, 2pi * radius / particle_spacing)

    if n_particles == 0
        # When the radius is approximately zero, just return one particle at the center
        return collect(reshape(center, (2, 1)))
    end

    # Remove the last particle at 2pi, which overlaps with the first at 0
    t = LinRange(0, 2pi, n_particles + 1)[1:(end - 1)]

    particle_coords = Array{Float64, 2}(undef, 2, length(t))

    for i in axes(particle_coords, 2)
        particle_coords[:, i] = center + radius * SVector(cos(t[i]), sin(t[i]))
    end

    return particle_coords
end

function hollow_sphere(particle_spacing, radius, center::SVector{3})
    # Number of circles from North Pole to South Pole (including the poles)
    n_circles = round(Int, pi * radius / particle_spacing + 1)
    polar_angle_increment = pi / (n_circles - 1)

    particle_coords = zeros(3, 0)

    for circle in 1:n_circles
        polar_angle = (circle - 1) * polar_angle_increment

        z = radius * cos(polar_angle)
        circle_radius = sqrt(radius^2 - z^2)

        circle_coords_2d = hollow_sphere(particle_spacing, circle_radius,
                                         SVector(center[1], center[2]))
        circle_coords_3d = vcat(circle_coords_2d,
                                center[3] .+ z * ones(1, size(circle_coords_2d, 2)))

        particle_coords = hcat(particle_coords, circle_coords_3d)
    end

    return particle_coords
end
