"""
    fill_circle(R, x_center, y_center, particle_spacing)

Circle filled with particles.

The arguments are as follows:
- `R`:                      Radius of the circle
- `x_center`, `y_center`:   Center of the circle in x and y direction, respectively.
- `particle_spacing`:       Spacing betweeen the particles.

The particles are arranged in an equidistiant grid
where the distance between the points is determined by the `particle_spacing`.

For only drawing the circumference see [`draw_circle`](@ref)
and for adding a recess in the circle see [`fill_circle_with_recess`](@ref).
"""
function fill_circle(R, x_center, y_center, particle_spacing)

    x_vec = Vector{Float64}(undef,0)
    y_vec = Vector{Float64}(undef,0)

    r(x,y) = sqrt( (x - x_center)^2 + (y - y_center)^2 )

    n_particles = round(Int, R/particle_spacing)

    for j in -n_particles : n_particles,
            i in -n_particles : n_particles

            x = x_center + i * particle_spacing
            y = y_center + j * particle_spacing

        if r(x,y) < R
            append!(x_vec, x)
            append!(y_vec, y)
        end
    end

    particle_coords = Array{Float64, 2}(undef, 2, length(x_vec))
    particle_coords[1,:] = x_vec
    particle_coords[2,:] = y_vec

    return particle_coords
end


"""
    fill_circle_with_recess(R, x_center, y_center, x_recess, y_recess, particle_spacing)

Particle filled circle with recess.

The arguments are the same as in [`fill_circle`](@ref) except:
- `x_recess`, `y_recess`:   Vector for recess start and end coordinates in x and y direction, respectively.

# Example
```julia
circle = fill_circle_with_recess(2.5, 0.0, 0.0,
                                 [0.5, recess_length], [0.0, recess_height],
                                 particle_spacing)
```
"""
function fill_circle_with_recess(R, x_center, y_center, x_recess, y_recess, particle_spacing)

    x_vec = Vector{Float64}(undef,0)
    y_vec = Vector{Float64}(undef,0)

    r(x,y) = sqrt( (x - x_center)^2 + (y - y_center)^2 )

    n_particles = round(Int, R/particle_spacing)

    for j in -n_particles : n_particles,
            i in -n_particles : n_particles

            x = x_center + i * particle_spacing
            y = y_center + j * particle_spacing

        # recess conditions
        recess     = y_recess[2] >= y >= y_recess[1] && x_recess[2] >= x >= x_recess[1]
        if r(x,y) < R && !recess
            append!(x_vec, x)
            append!(y_vec, y)
        end
    end

    particle_coords = Array{Float64, 2}(undef, 2, size(x_vec,1))
    particle_coords[1,:] = x_vec
    particle_coords[2,:] = y_vec

    return particle_coords
end


"""
    draw_circle(R, x_center, y_center, particle_spacing)

Circumference drawn by particles.
Unlike in [`fill_circle`](@ref), the particles are parametrized in a way
that the distance between each particle yields the `particle_spacing`.

The arguments are the same as in [`fill_circle`](@ref).

Mulitple layers are generated by calling the function additonally with the number of layers (see examples below).
Note that the radius of the circle increases by `particle_spacing` which each additional layer.

# Examples

One layer:
```julia
circle = draw_circle(2.5, 0.0, 0.0, particle_spacing)
```

Multiple layers:
```julia
circle = draw_circle(2.5, 0.0, 0.0, particle_spacing, 5)
```
"""
function draw_circle(R, x_center, y_center, particle_spacing)

    # particle_spacing = sqrt( (r_x1 - r_x2)^2 + (r_y1 - r_y2)^2 )
    # particle_spacing = sqrt( ( (R*cos(t)+R) - (R*cos(t+ Δ)+R) )^2 + ( (R*sin(t)+R) - (R*sin(t+ Δ)+R) )^2 )
    delta_t =  acos((2*R^2 - particle_spacing^2)/(2*R^2))

    t = collect(0:delta_t:2*pi-delta_t)

    # force equidistant spacing
    t = LinRange(0, 2*pi-delta_t, length(t))

    particle_coords = Array{Float64,2}(undef, 2, length(t));

    for i in eachindex(t)
        particle_coords[1, i] = R * cos(t[i]) + x_center
        particle_coords[2, i] = R * sin(t[i]) + y_center
    end

    return particle_coords
end

function draw_circle(R, x_center, y_center, particle_spacing, n_layers)

    x_vec = Vector{Float64}(undef,0)
    y_vec = Vector{Float64}(undef,0)

    for layer in 0:n_layers-1
        coords = draw_circle(R + particle_spacing*layer, x_center, y_center, particle_spacing)
        append!(x_vec, coords[1,:])
        append!(y_vec, coords[2,:])
    end

    particle_coords = Array{Float64, 2}(undef, 2, size(x_vec,1))
    particle_coords[1,:] = x_vec
    particle_coords[2,:] = y_vec

    return particle_coords
end
