"""
    CircularShape(R, x_center, y_center, particle_spacing;
                  shape_type=FillCircle(), density=0.0)

Either a circle filled with particles or a circumference drawn by particles.

# Arguments
- `R`:                      Radius of the circle
- `x_center`, `y_center`:   Center of the circle in x and y direction, respectively.
- `particle_spacing`:       Spacing betweeen the particles.

# Keywords
- `shape_type`:    `Type` to specify the circular shape (see [`FillCircle`](@ref) and [`DrawCircle`](@ref))
- `density`:       Specify the density if the `densities` or `masses` fields will be used

# Fields
- `coordinates::Array{ELTYPE, 2}`: Array containing the coordinates of the particles
- `masses::Vector{ELTYPE}`: Vector containing the masses of the particles
- `densities::Vector{ELTYPE}`: Vector containing the densities of the particles

For adding a recess in the particle filled circle or for only drawing the circumference
see [`FillCircle`](@ref) and [`DrawCircle`](@ref) respectively.
"""
struct CircularShape{NDIMS, ELTYPE<:Real}
    coordinates                 ::Array{ELTYPE, 2}
    masses                      ::Vector{ELTYPE}
    densities                   ::Vector{ELTYPE}
    particle_spacing            ::ELTYPE
    n_particles                 ::Int64

    function CircularShape(R, x_center, y_center, particle_spacing;
                           shape_type=FillCircle(), density=0.0)
        NDIMS = 2
        ELTYPE = eltype(particle_spacing)

        coordinates = generate_particles(shape_type, R, x_center, y_center, particle_spacing)

        n_particles = size(coordinates, 2)
        densities = density * ones(ELTYPE, n_particles)
        masses = density * particle_spacing^2 * ones(ELTYPE, n_particles)

        return new{NDIMS, ELTYPE}(coordinates, masses, densities,
                                  particle_spacing, n_particles)
    end
end


"""
    FillCircle()

Particle filled circle (required by [`CircularShape`](@ref)).

The particles are arranged in an equidistiant grid
where the distance between the points is determined by the `particle_spacing`.
For adding a recess see example below.

# Example

Particle filled circle with recess:
```julia
x_recess = (0.5, recess_length)
y_recess = (0.0, recess_height)
FillCircle(x_recess, y_recess)
```

"""
struct FillCircle{ELTYPE<:Real}
    x_recess ::NTuple
    y_recess ::NTuple

    function FillCircle()
        x_recess = (typemax(Int), typemax(Int))
        y_recess = (typemax(Int), typemax(Int))

        return new{Int}(x_recess, y_recess)
    end

    function FillCircle(x_recess, y_recess)

        return new{eltype(x_recess)}(x_recess, y_recess)
    end
end


"""
    DrawCircle()

Circumference drawn by particles (required by [`CircularShape`](@ref)).

Unlike in [`FillCircle`](@ref), the particles are parametrized in a way
that the distance between each particle yields the `particle_spacing`.

Mulitple layers are generated by calling the function additonally with the number of layers (see example).
Note that the radius of the circle increases by `particle_spacing` with each additional layer.

# Example

Circumference with one layer:
```julia
DrawCircle()
```

Circumference with multiple layers:
```julia
DrawCircle(n_layers)
```
"""
struct DrawCircle{}
    n_layers ::Int

    function DrawCircle()
        n_layers = 1
        return new{}(n_layers)
    end

    function DrawCircle(n_layers)

        return new{}(n_layers)
    end
end


function generate_particles(shape::FillCircle, R, x_center, y_center, particle_spacing)
    @unpack x_recess, y_recess = shape

    x_vec = Vector{Float64}(undef,0)
    y_vec = Vector{Float64}(undef,0)

    r(x,y) = sqrt( (x - x_center)^2 + (y - y_center)^2 )

    # recess condition
    recess(x,y) = (y_recess[2] >= y >= y_recess[1] &&
                   x_recess[2] >= x >= x_recess[1])

    n_particles = round(Int, R/particle_spacing)

    for j in -n_particles : n_particles,
            i in -n_particles : n_particles

            x = x_center + i * particle_spacing
            y = y_center + j * particle_spacing

        if r(x,y) < R && !recess(x,y)
            append!(x_vec, x)
            append!(y_vec, y)
        end
    end

    particle_coords = Array{Float64, 2}(undef, 2, length(x_vec))
    particle_coords[1,:] = x_vec
    particle_coords[2,:] = y_vec

    return particle_coords
end

function generate_particles(shape::DrawCircle, R, x_center, y_center, particle_spacing)
    @unpack n_layers = shape

    x_vec = Vector{Float64}(undef,0)
    y_vec = Vector{Float64}(undef,0)

    for layer in 0:n_layers-1
        coords = draw_circle(R + particle_spacing*layer, x_center, y_center, particle_spacing)
        append!(x_vec, coords[1,:])
        append!(y_vec, coords[2,:])
    end

    particle_coords = Array{Float64, 2}(undef, 2, size(x_vec,1))
    particle_coords[1,:] = x_vec
    particle_coords[2,:] = y_vec

    return particle_coords
end


function draw_circle(R, x_center, y_center, particle_spacing)

    # particle_spacing = sqrt( (r_x1 - r_x2)^2 + (r_y1 - r_y2)^2 )
    # particle_spacing = sqrt( ( (R*cos(t)+R) - (R*cos(t+ Δ)+R) )^2 + ( (R*sin(t)+R) - (R*sin(t+ Δ)+R) )^2 )
    delta_t =  acos((2*R^2 - particle_spacing^2)/(2*R^2))

    t = collect(0:delta_t:2*pi-delta_t)

    # force equidistant spacing
    t = LinRange(0, 2*pi-delta_t, length(t))

    particle_coords = Array{Float64,2}(undef, 2, length(t));

    for i in eachindex(t)
        particle_coords[1, i] = R * cos(t[i]) + x_center
        particle_coords[2, i] = R * sin(t[i]) + y_center
    end

    return particle_coords
end
