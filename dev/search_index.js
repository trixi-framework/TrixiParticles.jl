var documenterSearchIndex = {"docs":
[{"location":"tutorials/tut_beam_replaced/","page":"Example file","title":"Example file","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/docs/src/tutorials/tut_beam.md\"","category":"page"},{"location":"tutorials/tut_beam_replaced/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_beam_replaced/","page":"Example file","title":"Example file","text":"using TrixiParticles\nusing OrdinaryDiffEq\n\n# ==========================================================================================\n# ==== Resolution\nn_particles_y = 5\n\n# ==========================================================================================\n# ==== Experiment Setup\ngravity = 2.0\ntspan = (0.0, 5.0)\n\nelastic_beam = (length=0.35, thickness=0.02)\nmaterial = (density=1000.0, E=1.4e6, nu=0.4)\nclamp_radius = 0.05\n\n# The structure starts at the position of the first particle and ends\n# at the position of the last particle.\nparticle_spacing = elastic_beam.thickness / (n_particles_y - 1)\n\n# Add particle_spacing/2 to the clamp_radius to ensure that particles are also placed on the radius\nfixed_particles = SphereShape(particle_spacing, clamp_radius + particle_spacing / 2,\n                              (0.0, elastic_beam.thickness / 2), material.density,\n                              cutout_min=(0.0, 0.0),\n                              cutout_max=(clamp_radius, elastic_beam.thickness),\n                              tlsph=true)\n\nn_particles_clamp_x = round(Int, clamp_radius / particle_spacing)\n\n# Beam and clamped particles\nn_particles_per_dimension = (round(Int, elastic_beam.length / particle_spacing) +\n                             n_particles_clamp_x + 1, n_particles_y)\n\n# Note that the `RectangularShape` puts the first particle half a particle spacing away\n# from the boundary, which is correct for fluids, but not for solids.\n# We therefore need to pass `tlsph=true`.\nbeam = RectangularShape(particle_spacing, n_particles_per_dimension,\n                        (0.0, 0.0), density=material.density, tlsph=true)\n\nsolid = union(beam, fixed_particles)\n\n# ==========================================================================================\n# ==== Solid\n# The kernel in the reference uses a differently scaled smoothing length,\n# so this is equivalent to the smoothing length of `sqrt(2) * particle_spacing` used in the paper.\nsmoothing_length = 2 * sqrt(2) * particle_spacing\nsmoothing_kernel = WendlandC2Kernel{2}()\n\nsolid_system = TotalLagrangianSPHSystem(solid, smoothing_kernel, smoothing_length,\n                                        material.E, material.nu,\n                                        n_fixed_particles=nparticles(fixed_particles),\n                                        acceleration=(0.0, -gravity),\n                                        penalty_force=nothing)\n\n# ==========================================================================================\n# ==== Simulation\nsemi = Semidiscretization(solid_system)\node = semidiscretize(semi, tspan)\n\ninfo_callback = InfoCallback(interval=100)\n\n# Track the position of the particle in the middle of the tip of the beam.\nmiddle_particle_id = Int(n_particles_per_dimension[1] * (n_particles_per_dimension[2] + 1) /\n                         2)\nstartposition_x = beam.coordinates[1, middle_particle_id]\nstartposition_y = beam.coordinates[2, middle_particle_id]\n\nfunction deflection_x(v, u, t, system)\n    return system.current_coordinates[1, middle_particle_id] - startposition_x\nend\n\nfunction deflection_y(v, u, t, system)\n    return system.current_coordinates[2, middle_particle_id] - startposition_y\nend\n\nsaving_callback = SolutionSavingCallback(dt=0.02, prefix=\"\",\n                                         deflection_x=deflection_x,\n                                         deflection_y=deflection_y)\n\ncallbacks = CallbackSet(info_callback, saving_callback)\n\n# Use a Runge-Kutta method with automatic (error based) time step size control\nsol = solve(ode, RDPK3SpFSAL49(), save_everystep=false, callback=callbacks);\n\n","category":"page"},{"location":"general/smoothing_kernels/#smoothing_kernel","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"","category":"section"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"The following smoothing kernels are currently available:","category":"page"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"Smoothing Kernel Compact Support Typ. Smoothing Length Recommended Application Stability\nSchoenbergCubicSplineKernel 0 2h 11 to 13 General + sharp waves ++\nSchoenbergQuarticSplineKernel 0 25h 11 to 15 General +++\nSchoenbergQuinticSplineKernel 0 3h 11 to 15 General ++++\nGaussianKernel 0 3h 10 to 15 Literature +++++\nWendlandC2Kernel 0 1h 25 to 40 General (recommended) ++++\nWendlandC4Kernel 0 1h 30 to 45 General +++++\nWendlandC6Kernel 0 1h 35 to 50 General +++++\nPoly6Kernel 0 1h 15 to 25 Literature +\nSpikyKernel 0 1h 15 to 30 Sharp corners + waves +","category":"page"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"We recommend to use the WendlandC2Kernel for most applications. If less smoothing is needed, try SchoenbergCubicSplineKernel, for more smoothing try WendlandC6Kernel.","category":"page"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"note: Usage\nThe kernel can be called asTrixiParticles.kernel(smoothing_kernel, r, h)The length of the compact support can be obtained asTrixiParticles.compact_support(smoothing_kernel, h)Note that r has to be a scalar, so in the context of SPH, the kernel should be used asW(Vert r_a - r_b Vert h)The gradient required in SPH,    nabla_r_a W(Vert r_a - r_b Vert h)can be called asTrixiParticles.kernel_grad(smoothing_kernel, pos_diff, distance, h)where pos_diff is r_a - r_b and distance is Vert r_a - r_b Vert.","category":"page"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"general\", \"smoothing_kernels.jl\")]","category":"page"},{"location":"general/smoothing_kernels/#TrixiParticles.GaussianKernel","page":"Smoothing Kernels","title":"TrixiParticles.GaussianKernel","text":"GaussianKernel{NDIMS}()\n\nGaussian kernel given by\n\nW(r h) = fracsigma_dh^d e^-r^2h^2\n\nwhere d is the number of dimensions and\n\nsigma_2 = frac1pi for 2D,\nsigma_3 = frac1pi^32 for 3D.\n\nThis kernel function has an infinite support, but in practice, it's often truncated at a certain multiple of h, such as 3h.\n\nIn this implementation, the kernel is truncated at 3h, so this kernel function has a compact support of 0 3h.\n\nThe smoothing length is typically in the range 10delta 15delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nNote: This truncation makes this Kernel not conservative, which is beneficial in regards to stability but makes it less accurate.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.Poly6Kernel","page":"Smoothing Kernels","title":"TrixiParticles.Poly6Kernel","text":"Poly6Kernel{NDIMS}()\n\nPoly6 kernel, a commonly used kernel in SPH literature, especially in computer graphics contexts. It is defined as\n\nW(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (1 - q^2)^3     textif  0 leq q  1 \n    0               textif  q geq 1\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor that depends on the dimension. The normalization factor sigma is 4  pi in two dimensions or 315  64pi in three dimensions.\n\nThis kernel function has a compact support of 0 h.\n\nPoly6 is well-known for its computational simplicity, though it's worth noting that there are other kernels that might offer better accuracy for hydrodynamic simulations. Furthermore, its derivatives are not that smooth, which can lead to stability problems. It is also susceptible to clumping.\n\nThe smoothing length is typically in the range 15delta 25delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nMatthias Müller, David Charypar, and Markus Gross. \"Particle-based fluid simulation for interactive applications\". In: Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation. Eurographics Association. 2003, pages 154-159. doi: 10.5555/846276.846298\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SchoenbergCubicSplineKernel","page":"Smoothing Kernels","title":"TrixiParticles.SchoenbergCubicSplineKernel","text":"SchoenbergCubicSplineKernel{NDIMS}()\n\nCubic spline kernel by Schoenberg (Schoenberg, 1946), given by\n\n    W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    frac14 (2 - q)^3 - (1 - q)^3    textif  0 leq q  1 \n    frac14 (2 - q)^3                textif  1 leq q  2 \n    0                                    textif  q geq 2 \nendcases\n\nwhere d is the number of dimensions and sigma is a normalization constant given by sigma =frac23 frac107 pi frac1pi in 1 2 3 dimensions.\n\nThis kernel function has a compact support of 0 2h.\n\nFor an overview of Schoenberg cubic, quartic and quintic spline kernels including normalization factors, see (Price, 2012). For an analytic formula for higher order Schoenberg kernels, see (Monaghan, 1985). The largest disadvantage of Schoenberg Spline Kernel is the rather non-smooth first derivative, which can lead to increased noise compared to other kernel variants.\n\nThe smoothing length is typically in the range 11delta 13delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nDaniel J. Price. \"Smoothed particle hydrodynamics and magnetohydrodynamics\". In: Journal of Computational Physics 231.3 (2012), pages 759-794. doi: 10.1016/j.jcp.2010.12.011\nJoseph J. Monaghan. \"Particle methods for hydrodynamics\". In: Computer Physics Reports 3.2 (1985), pages 71–124. doi: 10.1016/0167-7977(85)90010-3\nIsaac J. Schoenberg. \"Contributions to the problem of approximation of equidistant data by analytic functions. Part B. On the problem of osculatory interpolation. A second class of analytic approximation formulae.\" In: Quarterly of Applied Mathematics 4.2 (1946), pages 112–141. doi: 10.1090/QAM/16705\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SchoenbergQuarticSplineKernel","page":"Smoothing Kernels","title":"TrixiParticles.SchoenbergQuarticSplineKernel","text":"SchoenbergQuarticSplineKernel{NDIMS}()\n\nQuartic spline kernel by Schoenberg (Schoenberg, 1946), given by\n\n    W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    left(52 - q right)^4 - 5left(32 - q right)^4\n    + 10left(12 - q right)^4  textif  0 leq q  frac12 \n    left(52 - q right)^4 - 5left(32 - q right)^4\n     textif  frac12 leq q  frac32 \n    left(52 - q right)^4  textif  frac32 leq q  frac52 \n    0  textif  q geq frac52\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization constant given by sigma =frac124 frac961199 pi frac120pi in 1 2 3 dimensions.\n\nThis kernel function has a compact support of 0 25h.\n\nFor an overview of Schoenberg cubic, quartic and quintic spline kernels including normalization factors, see (Price, 2012). For an analytic formula for higher order Schoenberg kernels, see (Monaghan, 1985).\n\nThe largest disadvantage of Schoenberg Spline Kernel are the rather non-smooth first derivative, which can lead to increased noise compared to other kernel variants.\n\nThe smoothing length is typically in the range 11delta 15delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nDaniel J. Price. \"Smoothed particle hydrodynamics and magnetohydrodynamics\". In: Journal of Computational Physics 231.3 (2012), pages 759-794. doi: 10.1016/j.jcp.2010.12.011\nJoseph J. Monaghan. \"Particle methods for hydrodynamics\". In: Computer Physics Reports 3.2 (1985), pages 71–124. doi: 10.1016/0167-7977(85)90010-3\nIsaac J. Schoenberg. \"Contributions to the problem of approximation of equidistant data by analytic functions. Part B. On the problem of osculatory interpolation. A second class of analytic approximation formulae.\" In: Quarterly of Applied Mathematics 4.2 (1946), pages 112–141. doi: 10.1090/QAM/16705\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SchoenbergQuinticSplineKernel","page":"Smoothing Kernels","title":"TrixiParticles.SchoenbergQuinticSplineKernel","text":"SchoenbergQuinticSplineKernel{NDIMS}()\n\nQuintic spline kernel by Schoenberg (Schoenberg, 1946), given by\n\n    W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (3 - q)^5 - 6(2 - q)^5 + 15(1 - q)^5     textif  0 leq q  1 \n    (3 - q)^5 - 6(2 - q)^5                   textif  1 leq q  2 \n    (3 - q)^5                                textif  2 leq q  3 \n    0                                        textif  q geq 3\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization constant given by sigma =frac1120 frac7478 pi frac1120pi in 1 2 3 dimensions.\n\nThis kernel function has a compact support of 0 3h.\n\nFor an overview of Schoenberg cubic, quartic and quintic spline kernels including normalization factors, see (Price, 2012). For an analytic formula for higher order Schoenberg kernels, see (Monaghan, 1985).\n\nThe largest disadvantage of Schoenberg Spline Kernel are the rather non-smooth first derivative, which can lead to increased noise compared to other kernel variants.\n\nThe smoothing length is typically in the range 11delta 15delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nDaniel J. Price. \"Smoothed particle hydrodynamics and magnetohydrodynamics\". In: Journal of Computational Physics 231.3 (2012), pages 759-794. doi: 10.1016/j.jcp.2010.12.011\nJoseph J. Monaghan. \"Particle methods for hydrodynamics\". In: Computer Physics Reports 3.2 (1985), pages 71–124. doi: 10.1016/0167-7977(85)90010-3\nIsaac J. Schoenberg. \"Contributions to the problem of approximation of equidistant data by analytic functions. Part B. On the problem of osculatory interpolation. A second class of analytic approximation formulae.\" In: Quarterly of Applied Mathematics 4.2 (1946), pages 112–141. doi: 10.1090/QAM/16705\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SpikyKernel","page":"Smoothing Kernels","title":"TrixiParticles.SpikyKernel","text":"SpikyKernel{NDIMS}()\n\nThe Spiky kernel is another frequently used kernel in SPH, especially due to its desirable properties in preserving features near boundaries in fluid simulations. It is defined as:\n\n W(r h) = frac1h^d w(rh)\n\nwith:\n\nw(q) = sigma begincases\n    (1 - q)^3     textif  0 leq q  1 \n    0             textif  q geq 1\nendcases\n\nwhere d is the number of dimensions and the normalization factor sigma is 10  pi in two dimensions or 15  pi in three dimensions.\n\nThis kernel function has a compact support of 0 h.\n\nThe Spiky kernel is particularly known for its sharp gradients, which can help to preserve sharp features in fluid simulations, especially near solid boundaries. These sharp gradients at the boundary are also the largest disadvantage as they can lead to instability.\n\nThe smoothing length is typically in the range 15delta 30delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nMatthias Müller, David Charypar, and Markus Gross. \"Particle-based fluid simulation for interactive applications\". In: Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation. Eurographics Association. 2003, pages 154-159. doi: 10.5555/846276.846298\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.WendlandC2Kernel","page":"Smoothing Kernels","title":"TrixiParticles.WendlandC2Kernel","text":"WendlandC2Kernel{NDIMS}()\n\nWendland C2 kernel (Wendland, 1995), a piecewise polynomial function designed to have compact support and to be twice continuously differentiable everywhere. Given by\n\n W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (1 - q)^4 (4q + 1)     textif  0 leq q  1 \n    0                      textif  q geq 1\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor dependent on the dimension. The normalization factor sigma is 407pi in two dimensions or 212pi in three dimensions.\n\nThis kernel function has a compact support of 0 h.\n\nFor a detailed discussion on Wendland functions and their applications in SPH, see (Dehnen & Aly, 2012). The smoothness of these functions is also the largest disadvantage as they lose details at sharp corners.\n\nThe smoothing length is typically in the range 25delta 40delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nWalter Dehnen & Hassan Aly. \"Improving convergence in smoothed particle hydrodynamics simulations without pairing instability\". In: Monthly Notices of the Royal Astronomical Society 425.2 (2012), pages 1068-1082. doi: 10.1111/j.1365-2966.2012.21439.x\nHolger Wendland. \"Piecewise polynomial, positive definite and compactly supported radial functions of minimal degree.\" In: Advances in computational Mathematics 4 (1995), pages 389-396. doi: 10.1007/BF02123482\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.WendlandC4Kernel","page":"Smoothing Kernels","title":"TrixiParticles.WendlandC4Kernel","text":"WendlandC4Kernel{NDIMS}()\n\nWendland C4 kernel, a piecewise polynomial function designed to have compact support and to be four times continuously differentiable everywhere. Given by\n\n W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (1 - q)^6 (35q^2  3 + 6q + 1)    textif  0 leq q  1 \n    0                                   textif  q geq 1\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor dependent on the dimension. The normalization factor sigma is 9  pi in two dimensions or 495  32pi in three dimensions.\n\nThis kernel function has a compact support of 0 h.\n\nFor a detailed discussion on Wendland functions and their applications in SPH, see (Dehnen & Aly, 2012). The smoothness of these functions is also the largest disadvantage as they loose details at sharp corners.\n\nThe smoothing length is typically in the range 30delta 45delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nWalter Dehnen & Hassan Aly. \"Improving convergence in smoothed particle hydrodynamics simulations without pairing instability\". In: Monthly Notices of the Royal Astronomical Society 425.2 (2012), pages 1068-1082. doi: 10.1111/j.1365-2966.2012.21439.x\nHolger Wendland. \"Piecewise polynomial, positive definite and compactly supported radial functions of minimal degree.\" In: Advances in computational Mathematics 4 (1995): 389-396. doi: 10.1007/BF02123482\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.WendlandC6Kernel","page":"Smoothing Kernels","title":"TrixiParticles.WendlandC6Kernel","text":"WendlandC6Kernel{NDIMS}()\n\nWendland C6 kernel, a piecewise polynomial function designed to have compact support and to be six times continuously differentiable everywhere. Given by:\n\nW(r h) = frac1h^d w(rh)\n\nwith:\n\nw(q) = sigma begincases\n    (1 - q)^8 (32q^3 + 25q^2 + 8q + 1)     textif  0 leq q  1 \n    0                                      textif  q geq 1\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor dependent on the dimension. The normalization factor sigma is 78  7 pi in two dimensions or 1365  64pi in three dimensions.\n\nThis kernel function has a compact support of 0 h.\n\nFor a detailed discussion on Wendland functions and their applications in SPH, see (Dehnen & Aly, 2012). The smoothness of these functions is also the largest disadvantage as they loose details at sharp corners.\n\nThe smoothing length is typically in the range 35delta 50delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nReferences\n\nWalter Dehnen & Hassan Aly. \"Improving convergence in smoothed particle hydrodynamics simulations without pairing instability\". In: Monthly Notices of the Royal Astronomical Society 425.2 (2012), pages 1068-1082. doi: 10.1111/j.1365-2966.2012.21439.x\nHolger Wendland. \"Piecewise polynomial, positive definite and compactly supported radial functions of minimal degree.\" In: Advances in computational Mathematics 4 (1995): 389-396. doi: 10.1007/BF02123482\n\n\n\n\n\n","category":"type"},{"location":"reference-trixibase/#TrixiBase.jl-API","page":"TrixiBase.jl API Reference","title":"TrixiBase.jl API","text":"","category":"section"},{"location":"reference-trixibase/","page":"TrixiBase.jl API Reference","title":"TrixiBase.jl API Reference","text":"CurrentModule = TrixiBase","category":"page"},{"location":"reference-trixibase/","page":"TrixiBase.jl API Reference","title":"TrixiBase.jl API Reference","text":"Modules = [TrixiBase]","category":"page"},{"location":"reference-trixibase/#TrixiBase.trixi_include-Tuple{Module, AbstractString}","page":"TrixiBase.jl API Reference","title":"TrixiBase.trixi_include","text":"trixi_include([mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. Its basic purpose is to make it easier to modify some parameters while running simulations from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nBefore replacing assignments in elixir, the keyword argument maxiters is inserted into calls to solve with it's default value used in the SciML ecosystem for ODEs, see the \"Miscellaneous\" section of the documentation.\n\nExamples\n\njulia> using TrixiBase, Trixi\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\n0.1\n\n\n\n\n\n","category":"method"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TrixiParticles.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TrixiParticles.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Setting-up-Julia","page":"Installation","title":"Setting up Julia","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you have not yet installed Julia, please follow the instructions for your operating system. TrixiParticles.jl works with Julia v1.9 and newer. We recommend using the latest stable release of Julia.","category":"page"},{"location":"install/#Installation-for-users","page":"Installation","title":"Installation for users","text":"","category":"section"},{"location":"install/#for-developers","page":"Installation","title":"Installation for developers","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you plan on editing TrixiParticles.jl itself, you can download TrixiParticles.jl to a local folder and use the code from the cloned directory:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone git@github.com:trixi-framework/TrixiParticles.jl.git\ncd TrixiParticles.jl\nmkdir run\njulia --project=run -e 'using Pkg; Pkg.develop(PackageSpec(path=\".\"))' # Install locally\njulia --project=run -e 'using Pkg; Pkg.add(\"OrdinaryDiffEq\")' # Add TrixiParticles.jl to `run` project","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you installed TrixiParticles.jl this way, you always have to start Julia with the --project flag set to your run directory, e.g.,","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia --project=run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"from the TrixiParticles.jl root directory.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The advantage of using a separate run directory is that you can also add other related packages (e.g., OrdinaryDiffEq.jl, see above) to the project in the run folder and always have a reproducible environment at hand to share with others.","category":"page"},{"location":"install/#Optional-software/packages","page":"Installation","title":"Optional software/packages","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"OrdinaryDiffEq.jl – A Julia package of ordinary differential equation solvers that is used in the examples\nPlots.jl – Julia Plotting library that is used in some examples\nPythonPlot.jl – Plotting library that can be used instead of Plots.jl\nParaView – Software that can be used for visualization of results","category":"page"},{"location":"install/#Common-issues","page":"Installation","title":"Common issues","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you followed the installation instructions for developers and you run into any problems with packages when pulling the latest version of TrixiParticles.jl, start Julia with the project in the run folder,","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"   julia --project=run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"update all packages in that project, resolve all conflicts in the project, and install all new dependencies:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg\n\njulia> Pkg.update()\n\njulia> Pkg.resolve()\n\njulia> Pkg.instantiate()","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/#Export-VTK-files","page":"Visualization","title":"Export VTK files","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"You can export particle data as VTK files by using the SolutionSavingCallback. All our predefined examples are already using this callback to export VTK files to the out directory (relative to the directory that you are running Julia from). VTK files can be read by visualization tools like ParaView and VisIt.","category":"page"},{"location":"visualization/#ParaView","page":"Visualization","title":"ParaView","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Follow these steps to view the exported VTK files in ParaView:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Click File -> Open.\nNavigate to the out directory (relative to the directory that you are running Julia from).\nOpen both boundary_1.pvd and fluid_1.pvd.\nClick \"Apply\", which by default is on the left pane below the \"Pipeline Browser\".\nHold the left mouse button to move the solution around.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"You will now see the following: (Image: image)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To now view the result variables first make sure you have \"fluid_1.pvd\" highlighted in the \"Pipeline Browser\" then select them in the variable selection combo box (see picture below). Let's, for example, pick \"density\". To now view the time progression of the result hit the \"play button\" (see picture below). (Image: image)","category":"page"},{"location":"visualization/#API","page":"Visualization","title":"API","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Modules = [TrixiParticles]\nPages = map(file -> joinpath(\"visualization\", file), readdir(joinpath(\"..\", \"src\", \"visualization\")))","category":"page"},{"location":"visualization/#TrixiParticles.trixi2vtk-Tuple{Any, Any, Any}","page":"Visualization","title":"TrixiParticles.trixi2vtk","text":"trixi2vtk(vu_ode, semi, t; iter=nothing, output_directory=\"out\", prefix=\"\",\n          write_meta_data=true, custom_quantities...)\n\nConvert Trixi simulation data to VTK format.\n\nArguments\n\nvu_ode: Solution of the TrixiParticles ODE system at one time step. This expects an ArrayPartition as returned in the examples as sol.\nsemi:   Semidiscretization of the TrixiParticles simulation.\nt:      Current time of the simulation.\n\nKeywords\n\niter:                 Iteration number when multiple iterations are to be stored in separate files.\noutput_directory:     Output directory path. Defaults to \"out\".\nprefix:               Prefix for output files. Defaults to an empty string.\nwrite_meta_data:      Write meta data.\ncustom_quantities...: Additional custom quantities to include in the VTK output. TODO.\nmax_coordinates=Inf   The coordinates of particles will be clipped if their absolute values exceed this threshold.\n\nExample\n\ntrixi2vtk(sol.u[end], semi, 0.0, iter=1, output_directory=\"output\", prefix=\"solution\")\n\nTODO: example for custom_quantities\n\n\n\n\n\n","category":"method"},{"location":"visualization/#TrixiParticles.trixi2vtk-Tuple{Any}","page":"Visualization","title":"TrixiParticles.trixi2vtk","text":"trixi2vtk(coordinates; output_directory=\"out\", prefix=\"\", filename=\"coordinates\")\n\nConvert coordinate data to VTK format.\n\nArguments\n\ncoordinates: Coordinates to be saved.\n\nKeywords\n\noutput_directory=\"out\": Output directory path.\nprefix=\"\":              Prefix for the output file.\nfilename=\"coordinates\": Name of the output file.\n\nReturns\n\nfile::AbstractString: Path to the generated VTK file.\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#initial_condition","page":"Initial Condition and Setups","title":"Initial Condition","text":"","category":"section"},{"location":"general/initial_condition/","page":"Initial Condition and Setups","title":"Initial Condition and Setups","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"general\", \"initial_condition.jl\")]","category":"page"},{"location":"general/initial_condition/#TrixiParticles.InitialCondition","page":"Initial Condition and Setups","title":"TrixiParticles.InitialCondition","text":"InitialCondition(; coordinates, density, velocity=zeros(size(coordinates, 1)),\n                 mass=nothing, pressure=0.0, particle_spacing=-1.0)\n\nStruct to hold the initial configuration of the particles.\n\nThe following setups return InitialConditions for commonly used setups:\n\nRectangularShape\nSphereShape\nRectangularTank\n\nInitialConditions support the set operations union, setdiff and intersect in order to build more complex geometries.\n\nArguments\n\ncoordinates: An array where the i-th column holds the coordinates of particle i.\ndensity:     Either a vector holding the density of each particle,                or a function mapping each particle's coordinates to its density,                or a scalar for a constant density over all particles.\n\nKeywords\n\nvelocity:   Either an array where the i-th column holds the velocity of particle i,               or a function mapping each particle's coordinates to its velocity,               or, for a constant fluid velocity, a vector holding this velocity.               Velocity is constant zero by default.\nmass:       Either nothing (default) to automatically compute particle mass from particle               density and spacing, or a vector holding the mass of each particle,               or a function mapping each particle's coordinates to its mass,               or a scalar for a constant mass over all particles.\npressure:   Either a vector holding the pressure of each particle,               or a function mapping each particle's coordinates to its pressure,               or a scalar for a constant pressure over all particles. This is optional and               only needed when using the EntropicallyDampedSPHSystem.\nparticle_spacing: The spacing between the particles. This is a scalar, as the spacing                     is assumed to be uniform. This is only needed when using                     set operations on the InitialCondition or for automatic mass calculation.\n\nExamples\n\n# Rectangle filled with particles\ninitial_condition = RectangularShape(0.1, (3, 4), (-1.0, 1.0), density=1.0)\n\n# Two spheres in one initial condition\ninitial_condition = union(SphereShape(0.15, 0.5, (-1.0, 1.0), 1.0),\n                          SphereShape(0.15, 0.2, (0.0, 1.0), 1.0))\n\n# Rectangle with a spherical hole\nshape1 = RectangularShape(0.1, (16, 13), (-0.8, 0.0), density=1.0)\nshape2 = SphereShape(0.1, 0.35, (0.0, 0.6), 1.0, sphere_type=RoundSphere())\ninitial_condition = setdiff(shape1, shape2)\n\n# Intersect of a rectangle with a sphere. Note that this keeps the particles of the\n# rectangle that are in the intersect, while `intersect(shape2, shape1)` would consist of\n# the particles of the sphere that are in the intersect.\nshape1 = RectangularShape(0.1, (16, 13), (-0.8, 0.0), density=1.0)\nshape2 = SphereShape(0.1, 0.35, (0.0, 0.6), 1.0, sphere_type=RoundSphere())\ninitial_condition = intersect(shape1, shape2)\n\n# Build `InitialCondition` manually\ncoordinates = [0.0 1.0 1.0\n               0.0 0.0 1.0]\nvelocity = zero(coordinates)\nmass = ones(3)\ndensity = 1000 * ones(3)\ninitial_condition = InitialCondition(; coordinates, velocity, mass, density)\n\n# With functions\ninitial_condition = InitialCondition(; coordinates, velocity=x -> 2x, mass=1.0, density=1000.0)\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#Setups","page":"Initial Condition and Setups","title":"Setups","text":"","category":"section"},{"location":"general/initial_condition/","page":"Initial Condition and Setups","title":"Initial Condition and Setups","text":"Modules = [TrixiParticles]\nPages = map(file -> joinpath(\"setups\", file), readdir(joinpath(\"..\", \"src\", \"setups\")))","category":"page"},{"location":"general/initial_condition/#TrixiParticles.RectangularShape-Tuple{Any, Any, Any}","page":"Initial Condition and Setups","title":"TrixiParticles.RectangularShape","text":"RectangularShape(particle_spacing, n_particles_per_dimension, min_coordinates;\n                 velocity=zeros(length(n_particles_per_dimension)),\n                 mass=nothing, density=nothing, pressure=0.0,\n                 acceleration=nothing, state_equation=nothing,\n                 tlsph=false, loop_order=nothing)\n\nRectangular shape filled with particles. Returns an InitialCondition.\n\nArguments\n\nparticle_spacing:           Spacing between the particles.\nn_particles_per_dimension:  Tuple containing the number of particles in x, y and z                               (only 3D) direction, respectively.\nmin_coordinates:            Coordinates of the corner in negative coordinate directions.\n\nKeywords\n\nvelocity:       Either a function mapping each particle's coordinates to its velocity,                   or, for a constant fluid velocity, a vector holding this velocity.                   Velocity is constant zero by default.\nmass:           Either nothing (default) to automatically compute particle mass from particle                   density and spacing, or a function mapping each particle's coordinates to its mass,                   or a scalar for a constant mass over all particles.\ndensity:        Either a function mapping each particle's coordinates to its density,                   or a scalar for a constant density over all particles.                   Obligatory when not using a state equation. Cannot be used together with                   state_equation.\npressure:       Scalar to set the pressure of all particles to this value.                   This is only used by the EntropicallyDampedSPHSystem and                   will be overwritten when using an initial pressure function in the system.                   Cannot be used together with hydrostatic pressure gradient.\nacceleration:   In order to initialize particles with a hydrostatic pressure gradient,                   an acceleration vector can be passed. Note that only accelerations                   in one coordinate direction and no diagonal accelerations are supported.                   This will only change the pressure of the particles. When using the                   WeaklyCompressibleSPHSystem, pass a state_equation as well                   to initialize the particles with the corresponding density and mass.                   When using the EntropicallyDampedSPHSystem, the pressure                   will be overwritten when using an initial pressure function in the system.                   This cannot be used together with the pressure keyword argument.\nstate_equation: When calculating a hydrostatic pressure gradient by setting acceleration,                   the state_equation will be used to set the corresponding density.                   Cannot be used together with density.\ntlsph:          With the TotalLagrangianSPHSystem, particles need to be placed                   on the boundary of the shape and not one particle radius away, as for fluids.                   When tlsph=true, particles will be placed on the boundary of the shape.\n\nExamples\n\n# 2D\nrectangular = RectangularShape(particle_spacing, (5, 4), (1.0, 2.0), density=1000.0)\n\n# 2D with hydrostatic pressure gradient.\n# `state_equation` has to be the same as for the WCSPH system.\nstate_equation = StateEquationCole(sound_speed=20.0, exponent=7, reference_density=1000.0)\nrectangular = RectangularShape(particle_spacing, (5, 4), (1.0, 2.0),\n                               acceleration=(0.0, -9.81), state_equation=state_equation)\n\n# 3D\nrectangular = RectangularShape(particle_spacing, (5, 4, 7), (1.0, 2.0, 3.0), density=1000.0)\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#TrixiParticles.RectangularTank","page":"Initial Condition and Setups","title":"TrixiParticles.RectangularTank","text":"RectangularTank(particle_spacing, fluid_size, tank_size, fluid_density;\n                velocity=zeros(length(fluid_size)), fluid_mass=nothing,\n                pressure=0.0,\n                acceleration=nothing, state_equation=nothing,\n                boundary_density=fluid_density,\n                n_layers=1, spacing_ratio=1.0,\n                min_coordinates=zeros(length(fluid_size)),\n                faces=Tuple(trues(2 * length(fluid_size))))\n\nRectangular tank filled with a fluid to set up dam-break-style simulations.\n\nArguments\n\nparticle_spacing:   Spacing between the fluid particles.\nfluid_size:         The dimensions of the fluid as (x, y) (or (x, y, z) in 3D).\ntank_size:          The dimensions of the tank as (x, y) (or (x, y, z) in 3D).\nfluid_density:      The rest density of the fluid. Will only be used as default for                       boundary_density when using a state equation.\n\nKeywords\n\nvelocity:       Either a function mapping each particle's coordinates to its velocity,                   or, for a constant fluid velocity, a vector holding this velocity.                   Velocity is constant zero by default.\nfluid_mass:     Either nothing (default) to automatically compute particle mass from particle                   density and spacing, or a function mapping each particle's coordinates to its mass,                   or a scalar for a constant mass over all particles.\npressure:       Scalar to set the pressure of all particles to this value.                   This is only used by the EntropicallyDampedSPHSystem and                   will be overwritten when using an initial pressure function in the system.                   Cannot be used together with hydrostatic pressure gradient.\nacceleration:   In order to initialize particles with a hydrostatic pressure gradient,                   an acceleration vector can be passed. Note that only accelerations                   in one coordinate direction and no diagonal accelerations are supported.                   This will only change the pressure of the particles. When using the                   WeaklyCompressibleSPHSystem, pass a state_equation as well                   to initialize the particles with the corresponding density and mass.                   When using the EntropicallyDampedSPHSystem, the pressure                   will be overwritten when using an initial pressure function in the system.                   This cannot be used together with the pressure keyword argument.\nstate_equation: When calculating a hydrostatic pressure gradient by setting acceleration,                   the state_equation will be used to set the corresponding density.                   Cannot be used together with density.\nboundary_density:   Density of each boundary particle (by default set to the fluid density)\nn_layers:           Number of boundary layers.\nspacing_ratio:      Ratio of particle_spacing to boundary particle spacing.                       A value of 2 means that the boundary particle spacing will be                       half the fluid particle spacing.\nmin_coordinates:    Coordinates of the corner in negative coordinate directions.\nfaces:              By default all faces are generated. Set faces by passing a                       bit-array of length 4 (2D) or 6 (3D) to generate the faces in the                       normal direction: -x,+x,-y,+y,-z,+z.\n\nFields\n\nfluid::InitialCondition:    InitialCondition for the fluid.\nboundary::InitialCondition: InitialCondition for the boundary.\nfluid_size::Tuple:          Tuple containing the size of the fluid in each dimension after rounding.\ntank_size::Tuple:           Tuple containing the size of the tank in each dimension after rounding.\n\nExamples\n\n# 2D\nsetup = RectangularTank(particle_spacing, (water_width, water_height),\n                        (container_width, container_height), fluid_density,\n                        n_layers=2, spacing_ratio=3)\n\n# 2D with hydrostatic pressure gradient.\n# `state_equation` has to be the same as for the WCSPH system.\nstate_equation = StateEquationCole(sound_speed=10.0, exponent=1, reference_density=1000.0)\nsetup = RectangularTank(particle_spacing, (water_width, water_height),\n                        (container_width, container_height), fluid_density,\n                        acceleration=(0.0, -9.81), state_equation=state_equation)\n\n# 3D\nsetup = RectangularTank(particle_spacing, (water_width, water_height, water_depth),\n                        (container_width, container_height, container_depth), fluid_density,\n                        n_layers=2)\n\nSee also: reset_wall!.\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#TrixiParticles.reset_wall!-Tuple{Any, Any, Any}","page":"Initial Condition and Setups","title":"TrixiParticles.reset_wall!","text":"reset_wall!(rectangular_tank::RectangularTank, reset_faces, positions)\n\nThe selected walls of the tank will be placed at the new positions.\n\nArguments\n\nreset_faces: Boolean tuple of 4 (in 2D) or 6 (in 3D) dimensions, similar to faces in RectangularTank.\npositions: Tuple of new positions\n\nwarning: Warning\nThere are overlapping particles when adjacent walls are moved inwards simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#TrixiParticles.RoundSphere","page":"Initial Condition and Setups","title":"TrixiParticles.RoundSphere","text":"RoundSphere(; start_angle=0.0, end_angle=2π)\n\nConstruct a sphere (or sphere segment) by nesting perfectly round concentric spheres. The resulting ball will be perfectly round, but will not have a regular inner structure.\n\nKeywords\n\nstart_angle: The starting angle of the sphere segment in radians. It determines the                beginning point of the segment. The default is set to 0.0 representing                the positive x-axis.\nend_angle: The ending angle of the sphere segment in radians. It defines the termination              point of the segment. The default is set to 2pi, completing a full sphere.\n\nnote: Usage\nSee SphereShape on how to use this.\n\nwarning: Warning\nThe sphere segment is intended for 2D geometries and hollow spheres. If used for filled spheres or in a 3D context, results may not be accurate.\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#TrixiParticles.VoxelSphere","page":"Initial Condition and Setups","title":"TrixiParticles.VoxelSphere","text":"VoxelSphere()\n\nConstruct a sphere of voxels (where particles are placed in the voxel center) with a regular inner structure but corners on the surface. Essentially, a grid of particles is generated and all particles outside the sphere are removed. The resulting sphere will have a perfect inner structure, but is not perfectly round, as it will have corners (like a sphere in Minecraft).\n\nnote: Usage\nSee SphereShape on how to use this.\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#TrixiParticles.SphereShape-NTuple{4, Any}","page":"Initial Condition and Setups","title":"TrixiParticles.SphereShape","text":"SphereShape(particle_spacing, radius, center_position, density;\n            sphere_type=VoxelSphere(), n_layers=-1, layer_outwards=false,\n            cutout_min=(0.0, 0.0), cutout_max=(0.0, 0.0), tlsph=false,\n            velocity=zeros(length(center_position)), mass=nothing, pressure=0.0)\n\nGenerate a sphere that is either completely filled (by default) or hollow (by passing n_layers).\n\nWith the sphere type VoxelSphere, a sphere of voxels (where particles are placed in the voxel center) with a regular inner structure but corners on the surface is created. Essentially, a grid of particles is generated and all particles outside the sphere are removed. With the sphere type RoundSphere, a perfectly round sphere with an imperfect inner structure is created.\n\nA cuboid can be cut out of the sphere by specifying the two corners in negative and positive coordinate directions as cutout_min and cutout_max.\n\nArguments\n\nparticle_spacing:   Spacing between the particles.\nradius:             Radius of the sphere.\ncenter_position:    The coordinates of the center of the sphere.\ndensity:            Either a function mapping each particle's coordinates to its density,                       or a scalar for a constant density over all particles.\n\nKeywords\n\nsphere_type:    Either VoxelSphere or RoundSphere (see                   explanation above).\nn_layers:       Set to an integer greater than zero to generate a hollow sphere,                   where the shell consists of n_layers layers.\nlayer_outwards: When set to false (by default), radius is the outer radius                   of the sphere. When set to true, radius is the inner radius                   of the sphere. This is only used when n_layers > 0.\ncutout_min:     Corner in negative coordinate directions of a cuboid that is to be                   cut out of the sphere.\ncutout_max:     Corner in positive coordinate directions of a cuboid that is to be                   cut out of the sphere.\ntlsph:          With the TotalLagrangianSPHSystem, particles need to be placed                   on the boundary of the shape and not one particle radius away, as for fluids.                   When tlsph=true, particles will be placed on the boundary of the shape.\nvelocity:   Either a function mapping each particle's coordinates to its velocity,               or, for a constant fluid velocity, a vector holding this velocity.               Velocity is constant zero by default.\nmass:       Either nothing (default) to automatically compute particle mass from particle               density and spacing, or a function mapping each particle's coordinates to its mass,               or a scalar for a constant mass over all particles.\npressure:   Either a function mapping each particle's coordinates to its pressure,               or a scalar for a constant pressure over all particles. This is optional and               only needed when using the EntropicallyDampedSPHSystem.\n\nExamples\n\n# Filled circle with radius 0.5, center in (0.2, 0.4) and a particle spacing of 0.1\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0)\n\n# Same as before, but perfectly round\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, sphere_type=RoundSphere())\n\n# Hollow circle with ~3 layers, outer radius 0.5, center in (0.2, 0.4) and a particle\n# spacing of 0.1.\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, n_layers=3)\n\n# Same as before, but perfectly round\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, n_layers=3, sphere_type=RoundSphere())\n\n# Hollow circle with 3 layers, inner radius 0.5, center in (0.2, 0.4) and a particle spacing\n# of 0.1.\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, n_layers=3, layer_outwards=true)\n\n# Filled circle with radius 0.1, center in (0.0, 0.0), particle spacing 0.1, but the\n# rectangle [0, 1] x [-0.2, 0.2] is cut out.\nSphereShape(0.1, 1.0, (0.0, 0.0), 1000.0, cutout_min=(0.0, -0.2), cutout_max=(1.0, 0.2))\n\n# Filled 3D sphere with radius 0.5, center in (0.2, 0.4, 0.3) and a particle spacing of 0.1\nSphereShape(0.1, 0.5, (0.2, 0.4, 0.3), 1000.0)\n\n# Same as before, but perfectly round\nSphereShape(0.1, 0.5, (0.2, 0.4, 0.3), 1000.0, sphere_type=RoundSphere())\n\n\n\n\n\n","category":"method"},{"location":"systems/weakly_compressible_sph/#wcsph","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Weakly compressible SPH as introduced by Monaghan (1994). This formulation relies on a stiff equation of state that generates large pressure changes for small density variations.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"fluid\", \"weakly_compressible_sph\", \"system.jl\")]","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.WeaklyCompressibleSPHSystem","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.WeaklyCompressibleSPHSystem","text":"WeaklyCompressibleSPHSystem(initial_condition,\n                            density_calculator, state_equation,\n                            smoothing_kernel, smoothing_length;\n                            viscosity=nothing, density_diffusion=nothing,\n                            acceleration=ntuple(_ -> 0.0, NDIMS),\n                            correction=nothing, source_terms=nothing)\n\nSystem for particles of a fluid. The weakly compressible SPH (WCSPH) scheme is used, wherein a stiff equation of state generates large pressure changes for small density variations. See Weakly Compressible SPH for more details on the method.\n\nArguments\n\ninitial_condition:  InitialCondition representing the system's particles.\ndensity_calculator: Density calculator for the system.                       See ContinuityDensity and SummationDensity.\nstate_equation:     Equation of state for the system. See StateEquationCole.\nsmoothing_kernel:   Smoothing kernel to be used for this system.                       See Smoothing Kernels.\nsmoothing_length:   Smoothing length to be used for this system.                       See Smoothing Kernels.\n\nKeyword Arguments\n\nviscosity:      Viscosity model for this system (default: no viscosity).                   See ArtificialViscosityMonaghan or ViscosityAdami.\ndensity_diffusion: Density diffusion terms for this system. See DensityDiffusion.\nacceleration:   Acceleration vector for the system. (default: zero vector)\ncorrection:     Correction method used for this system. (default: no correction, see Corrections)\nsource_terms:   Additional source terms for this system. Has to be either nothing                   (by default), or a function of (coords, velocity, density, pressure)                   (which are the quantities of a single particle), returning a Tuple                   or SVector that is to be added to the acceleration of that particle.                   See, for example, SourceTermDamping.                   Note that these source terms will not be used in the calculation of the                   boundary pressure when using a boundary with                   BoundaryModelDummyParticles and AdamiPressureExtrapolation.                   The keyword argument acceleration should be used instead for                   gravity-like source terms.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#References","page":"Weakly Compressible SPH (Fluid)","title":"References","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Joseph J. Monaghan. \"Simulating Free Surface Flows in SPH\". In: Journal of Computational Physics 110 (1994), pages 399–406. doi: 10.1006/jcph.1994.1034","category":"page"},{"location":"systems/weakly_compressible_sph/#equation_of_state","page":"Weakly Compressible SPH (Fluid)","title":"Equation of State","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The equation of state is used to relate fluid density to pressure and thus allow an explicit simulation of the WCSPH system. The equation in the following formulation was introduced by Cole (Cole 1948, pp. 39 and 43). The pressure p is calculated as","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"    p = B left(left(fracrhorho_0right)^gamma - 1right) + p_textbackground","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"where rho denotes the density, rho_0 the reference density, and p_textbackground the background pressure, which is set to zero when applied to free-surface flows (Adami et al., 2012).","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The bulk modulus, B =  fracrho_0 c^2gamma, is calculated from the artificial speed of sound c and the isentropic exponent gamma.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"An ideal gas equation of state with a linear relationship between pressure and density can be obtained by choosing exponent=1, i.e.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"    p = B left( fracrhorho_0 -1 right) = c^2(rho - rho_0)","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"For higher Reynolds numbers, exponent=7 is recommended, whereas at lower Reynolds numbers exponent=1 yields more accurate pressure estimates since pressure and density are proportional.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"When using SummationDensity (or DensityReinitializationCallback) and free surfaces, initializing particles with equal spacing will cause underestimated density and therefore strong attractive forces between particles at the free surface. Setting clip_negative_pressure=true can avoid this.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"fluid\", \"weakly_compressible_sph\", \"state_equations.jl\")]","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.StateEquationCole","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.StateEquationCole","text":"StateEquationCole(; sound_speed, reference_density, exponent,\n                  background_pressure=0.0, clip_negative_pressure=false)\n\nEquation of state to describe the relationship between pressure and density of water up to high pressures.\n\nKeywords\n\nsound_speed: Artificial speed of sound.\nreference_density: Reference density of the fluid.\nexponent: A value of 7 is usually used for most simulations.\nbackground_pressure=0.0: Background pressure.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#References-2","page":"Weakly Compressible SPH (Fluid)","title":"References","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Robert H. Cole. \"Underwater Explosions\". Princeton University Press, 1948.\nJ. P. Morris, P. J. Fox, Y. Zhu \"Modeling Low Reynolds Number Incompressible Flows Using SPH \". In: Journal of Computational Physics , Vol. 136, No. 1, pages 214–226. doi: 10.1006/jcph.1997.5776\nS. Adami, X. Y. Hu, N. A. Adams. \"A generalized wall boundary condition for smoothed particle hydrodynamics\". In: Journal of Computational Physics 231, 21 (2012), pages 7057–7075. doi: 10.1016/J.JCP.2012.05.005","category":"page"},{"location":"systems/weakly_compressible_sph/#viscosity_wcsph","page":"Weakly Compressible SPH (Fluid)","title":"Viscosity","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"TODO: Explain viscosity.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"fluid\", \"viscosity.jl\")]","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.ArtificialViscosityMonaghan","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.ArtificialViscosityMonaghan","text":"ArtificialViscosityMonaghan(; alpha, beta, epsilon=0.01)\n\nKeywords\n\nalpha: A value of 0.02 is usually used for most simulations. For a relation with the          kinematic viscosity, see description below.\nbeta: A value of 0.0 works well for simulations with shocks of moderate strength.         In simulations where the Mach number can be very high, eg. astrophysical calculation,         good results can be obtained by choosing a value of beta=2 and alpha=1.\nepsilon=0.01: Parameter to prevent singularities.\n\nArtificial viscosity by Monaghan (Monaghan 1992, Monaghan 1989), given by\n\nPi_ab =\nbegincases\n    -(alpha c mu_ab + beta mu_ab^2)  barrho_ab  textif  v_ab cdot r_ab  0 \n    0  textotherwise\nendcases\n\nwith\n\nmu_ab = frach v_ab cdot r_abVert r_ab Vert^2 + epsilon h^2\n\nwhere alpha beta epsilon are parameters, c is the speed of sound, h is the smoothing length, r_ab = r_a - r_b is the difference of the coordinates of particles a and b, v_ab = v_a - v_b is the difference of their velocities, and barrho_ab is the arithmetic mean of their densities.\n\nNote that alpha needs to adjusted for different resolutions to maintain a specific Reynolds Number. To do so, Monaghan (Monaghan 2005) defined an equivalent effective physical kinematic viscosity nu by\n\n    nu = fracalpha h c 2d + 4\n\nwhere d is the dimension.\n\nReferences\n\nJoseph J. Monaghan. \"Smoothed Particle Hydrodynamics\". In: Annual Review of Astronomy and Astrophysics 30.1 (1992), pages 543-574. doi: 10.1146/ANNUREV.AA.30.090192.002551\nJoseph J. Monaghan. \"Smoothed Particle Hydrodynamics\". In: Reports on Progress in Physics (2005), pages 1703-1759. doi: 10.1088/0034-4885/68/8/r01\nJoseph J. Monaghan. \"On the Problem of Penetration in Particle Methods\". In: Journal of Computational Physics 82.1, pages 1–15. doi: 10.1016/0021-9991(89)90032-6\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.ViscosityAdami","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.ViscosityAdami","text":"ViscosityAdami(; nu, epsilon=0.01)\n\nViscosity by Adami (Adami et al. 2012). The viscous interaction is calculated with the shear force for incompressible flows given by\n\nf_ab = sum_w bareta_ab left( V_a^2 + V_b^2 right) fracv_abr_ab^2+epsilon h_ab^2  nabla W_ab cdot r_ab\n\nwhere r_ab = r_a - r_b is the difference of the coordinates of particles a and b, v_ab = v_a - v_b is the difference of their velocities, h is the smoothing length and V is the particle volume. The parameter epsilon prevents singularities (see Ramachandran et al. 2019). The inter-particle-averaged shear stress  is\n\n    bareta_ab =frac2 eta_a eta_beta_a + eta_b\n\nwhere eta_a = rho_a nu_a with nu as the kinematic viscosity.\n\nKeywords\n\nnu: Kinematic viscosity\nepsilon=0.01: Parameter to prevent singularities\n\nReferences\n\nS. Adami et al. \"A generalized wall boundary condition for smoothed particle hydrodynamics\". In: Journal of Computational Physics 231 (2012), pages 7057-7075. doi: 10.1016/j.jcp.2012.05.005\nP. Ramachandran et al. \"Entropically damped artificial compressibility for SPH\". In: Journal of Computers and Fluids 179 (2019), pages 579-594. doi: 10.1016/j.compfluid.2018.11.023\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#Density-Diffusion","page":"Weakly Compressible SPH (Fluid)","title":"Density Diffusion","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Density diffusion can be used with ContinuityDensity to remove the noise in the pressure field. It is highly recommended to use density diffusion when using WCSPH.","category":"page"},{"location":"systems/weakly_compressible_sph/#Formulation","page":"Weakly Compressible SPH (Fluid)","title":"Formulation","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"All density diffusion terms extend the continuity equation (see ContinuityDensity) by an additional term","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"fracmathrmdrho_amathrmdt = sum_b m_b v_ab cdot nabla_r_a W(Vert r_ab Vert h)\n    + delta h c sum_b V_b psi_ab cdot nabla_r_a W(Vert r_ab Vert h)","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"where V_b = m_b  rho_b is the volume of particle b and psi_ab depends on the density diffusion method (see DensityDiffusion for available terms). Also, rho_a denotes the density of particle a and r_ab = r_a - r_b is the difference of the coordinates, v_ab = v_a - v_b of the velocities of particles a and b.","category":"page"},{"location":"systems/weakly_compressible_sph/#Numerical-Results","page":"Weakly Compressible SPH (Fluid)","title":"Numerical Results","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"All density diffusion terms remove numerical noise in the pressure field and produce more accurate results than weakly commpressible SPH without density diffusion. This can be demonstrated with dam break examples in 2D and 3D. Here, δ = 01 has been used for all terms. Note that, due to added stability, the adaptive time integration method that was used here can choose higher time steps in the simulations with density diffusion. For the cheap DensityDiffusionMolteniColagrossi, this results in reduced runtime.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"<figure>\n  <img src=\"https://lh3.googleusercontent.com/drive-viewer/AK7aPaBL-tqW6p9ry3NHvNnHVNufRfh_NSz0Le4vJ4n2rS-10Vr3Dkm2Cjb4T861vk6yhnvqMgS_PLXeZsNoVepIfYgpw-hlgQ=s1600\" alt=\"density_diffusion_2d\"/>\n  <figcaption>Dam break in 2D with different density diffusion terms</figcaption>\n</figure>","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"<figure>\n  <img src=\"https://lh3.googleusercontent.com/drive-viewer/AK7aPaDKc0DCJfFH606zWFkjutMYzs70Y4Ot_33avjcIRxV3xNbrX1gqx6EpeSmysai338aRsOoqJ8B1idUs5U30SA_o12OQ=s1600\" alt=\"density_diffusion_3d\"/>\n  <figcaption>Dam break in 3D with different density diffusion terms</figcaption>\n</figure>","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The simpler terms DensityDiffusionMolteniColagrossi and DensityDiffusionFerrari do not solve the hydrostatic problem and lead to incorrect solutions in long-running steady-state hydrostatic simulations with free surfaces (Antuono et al., 2012). This can be seen when running the simple rectangular tank example until t = 40 (again using δ = 01):","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"<figure>\n  <img src=\"https://lh3.googleusercontent.com/drive-viewer/AK7aPaCf1gDlbxkQjxpyffPJ-ijx-DdVxlwUVb_DLYIW4X5E0hkDeJcuAqCae6y4eDydgTKe752zWa08tKVL5yhB-ad8Uh8J=s1600\" alt=\"density_diffusion_tank\"/>\n  <figcaption>Tank in rest under gravity in 3D with different density diffusion terms</figcaption>\n</figure>","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"DensityDiffusionAntuono adds a correction term to solve this problem, but this term is very expensive and adds about 40–50% of computational cost.","category":"page"},{"location":"systems/weakly_compressible_sph/#References-3","page":"Weakly Compressible SPH (Fluid)","title":"References","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"M. Antuono, A. Colagrossi, S. Marrone. \"Numerical Diffusive Terms in Weakly-Compressible SPH Schemes.\" In: Computer Physics Communications 183.12 (2012), pages 2570–2580. doi: 10.1016/j.cpc.2012.07.006","category":"page"},{"location":"systems/weakly_compressible_sph/#API","page":"Weakly Compressible SPH (Fluid)","title":"API","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"fluid\", \"weakly_compressible_sph\", \"density_diffusion.jl\")]","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusion","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusion","text":"DensityDiffusion\n\nAn abstract supertype of all density diffusion formulations.\n\nCurrently, the following formulations are available:\n\nFormulation Suitable for Steady-State Simulations Low Computational Cost\nDensityDiffusionMolteniColagrossi ❌ ✅\nDensityDiffusionFerrari ❌ ✅\nDensityDiffusionAntuono ✅ ❌\n\nSee Density Diffusion for a comparison and more details.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusionAntuono","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusionAntuono","text":"DensityDiffusionAntuono(initial_condition; delta)\n\nThe commonly used density diffusion terms by Antuono et al. (2010), also referred to as δ-SPH. The density diffusion term by Molteni & Colagrossi (2009) is extended by a second term, which is nicely written down by Antuono et al. (2012).\n\nThe term psi_ab in the continuity equation in DensityDiffusion is defined by\n\npsi_ab = 2left(rho_a - rho_b - frac12big(nablarho^L_a + nablarho^L_bbig) cdot r_abright)\n    fracr_abVert r_ab Vert^2\n\nwhere rho_a and rho_b denote the densities of particles a and b respectively and r_ab = r_a - r_b is the difference of the coordinates of particles a and b. The symbol nablarho^L_a denotes the renormalized density gradient defined as\n\nnablarho^L_a = -sum_b (rho_a - rho_b) V_b L_a nabla_r_a W(Vert r_ab Vert h)\n\nwith\n\nL_a = left( -sum_b V_b r_ab otimes nabla_r_a W(Vert r_ab Vert h) right)^-1 in R^d times d\n\nwhere d is the number of dimensions.\n\nSee DensityDiffusion for an overview and comparison of implemented density diffusion terms.\n\nReferences\n\nM. Antuono, A. Colagrossi, S. Marrone, D. Molteni. \"Free-Surface Flows Solved by Means of SPH Schemes with Numerical Diffusive Terms.\" In: Computer Physics Communications 181.3 (2010), pages 532–549. doi: 10.1016/j.cpc.2009.11.002\nM. Antuono, A. Colagrossi, S. Marrone. \"Numerical Diffusive Terms in Weakly-Compressible SPH Schemes.\" In: Computer Physics Communications 183.12 (2012), pages 2570–2580. doi: 10.1016/j.cpc.2012.07.006\nDiego Molteni, Andrea Colagrossi. \"A Simple Procedure to Improve the Pressure Evaluation in Hydrodynamic Context Using the SPH.\" In: Computer Physics Communications 180.6 (2009), pages 861–872. doi: 10.1016/j.cpc.2008.12.004\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusionFerrari","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusionFerrari","text":"DensityDiffusionFerrari()\n\nA density diffusion term by Ferrari et al. (2009).\n\nThe term psi_ab in the continuity equation in DensityDiffusion is defined by\n\npsi_ab = fracrho_a - rho_b2h fracr_abVert r_ab Vert\n\nwhere rho_a and rho_b denote the densities of particles a and b respectively, r_ab = r_a - r_b is the difference of the coordinates of particles a and b and h is the smoothing length.\n\nSee DensityDiffusion for an overview and comparison of implemented density diffusion terms.\n\nReferences\n\nAngela Ferrari, Michael Dumbser, Eleuterio F. Toro, Aronne Armanini. \"A New 3D Parallel SPH Scheme for Free Surface Flows.\" In: Computers & Fluids 38.6 (2009), pages 1203–1217. doi: 10.1016/j.compfluid.2008.11.012.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusionMolteniColagrossi","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusionMolteniColagrossi","text":"DensityDiffusionMolteniColagrossi(; delta)\n\nThe commonly used density diffusion term by Molteni & Colagrossi (2009).\n\nThe term psi_ab in the continuity equation in DensityDiffusion is defined by\n\npsi_ab = 2(rho_a - rho_b) fracr_abVert r_ab Vert^2\n\nwhere rho_a and rho_b denote the densities of particles a and b respectively and r_ab = r_a - r_b is the difference of the coordinates of particles a and b.\n\nSee DensityDiffusion for an overview and comparison of implemented density diffusion terms.\n\nReferences\n\nDiego Molteni, Andrea Colagrossi. \"A Simple Procedure to Improve the Pressure Evaluation in Hydrodynamic Context Using the SPH.\" In: Computer Physics Communications 180.6 (2009), pages 861–872. doi: 10.1016/j.cpc.2008.12.004\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#corrections","page":"Weakly Compressible SPH (Fluid)","title":"Corrections","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"general\", \"corrections.jl\")]","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.AkinciFreeSurfaceCorrection","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.AkinciFreeSurfaceCorrection","text":"AkinciFreeSurfaceCorrection(rho0)\n\nFree surface correction according to Akinci et al. (2013). At a free surface, the mean density is typically lower than the reference density, resulting in reduced surface tension and viscosity forces. The free surface correction adjusts the viscosity, pressure, and surface tension forces near free surfaces to counter this effect. It's important to note that this correlation is unphysical and serves as an approximation. The computation time added by this method is about 2–3%.\n\nMathematically the idea is quite simple. If we have an SPH particle in the middle of a volume at rest, its density will be identical to the rest density rho_0. If we now consider an SPH particle at a free surface at rest, it will have neighbors missing in the direction normal to the surface, which will result in a lower density. If we calculate the correction factor\n\nk = rho_0rho_textmean\n\nthis value will be about ~1.5 for particles at the free surface and can then be used to increase the pressure and viscosity accordingly.\n\nArguments\n\nrho0: Rest density.\n\nReferences\n\nAkinci, N., Akinci, G., & Teschner, M. (2013). \"Versatile Surface Tension and Adhesion for SPH Fluids\". ACM Transactions on Graphics (TOG), 32(6), 182. doi: 10.1145/2508363.2508405\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.BlendedGradientCorrection","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.BlendedGradientCorrection","text":"BlendedGradientCorrection()\n\nCalculate a blended gradient to reduce the stability issues of the GradientCorrection.\n\nThis calculates the following,\n\ntildenabla A_i = (1-lambda) nabla A_i + lambda L_i nabla A_i\n\nwith 0 leq lambda leq 1 being the blending factor.\n\nArguments\n\nblending_factor: Blending factor between corrected and regular SPH gradient.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.GradientCorrection","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.GradientCorrection","text":"GradientCorrection()\n\nCompute the corrected gradient of particle interactions based on their relative positions.\n\nMathematical Details\n\nGiven the standard SPH representation, the gradient of a field A at particle a is given by\n\nnabla A_a = sum_b m_b fracA_b - A_arho_b nabla_r_a W(Vert r_a - r_b Vert h)\n\nwhere m_b is the mass of particle b and rho_b is the density of particle b.\n\nThe gradient correction, as commonly proposed, involves multiplying this gradient with a correction matrix L:\n\ntildenabla A_a = bmL_a nabla A_a\n\nThe correction matrix  bmL_a is computed based on the provided particle configuration, aiming to make the corrected gradient more accurate, especially near domain boundaries.\n\nTo satisfy\n\nsum_b V_b r_ba otimes tildenablaW_b(r_a) = left( sum_b V_b r_ba otimes nabla W_b(r_a) right) bmL_a^T = bmI\n\nthe correction matrix bmL_a is evaluated explicitly as\n\nbmL_a = left( sum_b V_b nabla W_b(r_a) otimes r_ba right)^-1\n\nnote: Note\nStability issues arise, especially when particles separate into small clusters.\nDoubles the computational effort.\n\nBetter stability with smoother smoothing Kernels with larger support, e.g. SchoenbergQuinticSplineKernel or WendlandC6Kernel.\nSet dt_max =< 1e-3 for stability.\n\nReferences\n\nJ. Bonet, T.-S.L. Lok. \"Variational and momentum preservation aspects of Smooth Particle Hydrodynamic formulations\". In: Computer Methods in Applied Mechanics and Engineering 180 (1999), pages 97–115. doi: 10.1016/S0045-7825(99)00051-1\nMihai Basa, Nathan Quinlan, Martin Lastiwka. \"Robustness and accuracy of SPH formulations for viscous flow\". In: International Journal for Numerical Methods in Fluids 60 (2009), pages 1127–1148. doi: 10.1002/fld.1927\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.KernelCorrection","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.KernelCorrection","text":"KernelCorrection()\n\nKernel correction uses Shepard interpolation to obtain a 0-th order accurate result, which was first proposed by Li et al. This can be further extended to obtain a kernel corrected gradient as shown by Basa et al.\n\nThe kernel correction coefficient is determined by\n\nc(x) = sum_b=1 V_b W_b(x)\n\nThe gradient of corrected kernel is determined by\n\nnabla tildeW_b(r) =fracnabla W_b(r) - W_b(r) gamma(r)sum_b=1 V_b W_b(r)  quad  textwhere quad\ngamma(r) = fracsum_b=1 V_b nabla W_b(r)sum_b=1 V_b W_b(r)\n\nThis correction can be applied with SummationDensity and ContinuityDensity, which leads to an improvement, especially at free surfaces.\n\nnote: Note\nThis only works when the boundary model uses SummationDensity (yet).\nIt is also referred to as \"0th order correction\".\nIn 2D, we can expect an increase of about 10–15% in computation time.\n\nReferences\n\nJ. Bonet, T.-S.L. Lok. \"Variational and momentum preservation aspects of Smooth Particle Hydrodynamic formulations\". In: Computer Methods in Applied Mechanics and Engineering 180 (1999), pages 97-115. doi: 10.1016/S0045-7825(99)00051-1\nMihai Basa, Nathan Quinlan, Martin Lastiwka. \"Robustness and accuracy of SPH formulations for viscous flow\". In: International Journal for Numerical Methods in Fluids 60 (2009), pages 1127–1148. doi: 10.1002/fld.1927\nShaofan Li, Wing Kam Liu. \"Moving least-square reproducing kernel method Part II: Fourier analysis\". In: Computer Methods in Applied Mechanics and Engineering 139 (1996), pages 159-193. doi:10.1016/S0045-7825(96)01082-1\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.MixedKernelGradientCorrection","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.MixedKernelGradientCorrection","text":"MixedKernelGradientCorrection()\n\nCombines GradientCorrection and KernelCorrection, which results in a 1st-order-accurate SPH method.\n\nNotes:\n\nStability issues, especially when particles separate into small clusters.\nDoubles the computational effort.\n\nReferences\n\nJ. Bonet, T.-S.L. Lok. \"Variational and momentum preservation aspects of Smooth Particle Hydrodynamic formulations\". In: Computer Methods in Applied Mechanics and Engineering 180 (1999), pages 97–115. doi: 10.1016/S0045-7825(99)00051-1\nMihai Basa, Nathan Quinlan, Martin Lastiwka. \"Robustness and accuracy of SPH formulations for viscous flow\". In: International Journal for Numerical Methods in Fluids 60 (2009), pages 1127–1148. doi: 10.1002/fld.1927\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.ShepardKernelCorrection","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.ShepardKernelCorrection","text":"ShepardKernelCorrection()\n\nKernel correction uses Shepard interpolation to obtain a 0-th order accurate result, which was first proposed by Li et al.\n\nThe kernel correction coefficient is determined by\n\nc(x) = sum_b=1 V_b W_b(x)\n\nwhere V_b = m_b  rho_b is the volume of particle b.\n\nThis correction is applied with SummationDensity to correct the density and leads to an improvement, especially at free surfaces.\n\nnote: Note\nIt is also referred to as \"0th order correction\".\nIn 2D, we can expect an increase of about 5–6% in computation time.\n\nReferences\n\nJ. Bonet, T.-S.L. Lok. \"Variational and momentum preservation aspects of Smooth Particle Hydrodynamic formulations\". In: Computer Methods in Applied Mechanics and Engineering 180 (1999), pages 97-115. doi: 10.1016/S0045-7825(99)00051-1\nMihai Basa, Nathan Quinlan, Martin Lastiwka. \"Robustness and accuracy of SPH formulations for viscous flow\". In: International Journal for Numerical Methods in Fluids 60 (2009), pages 1127–1148. doi: 10.1002/fld.1927\nShaofan Li, Wing Kam Liu. \"Moving least-square reproducing kernel method Part II: Fourier analysis\". In: Computer Methods in Applied Mechanics and Engineering 139 (1996), pages 159–193. doi:10.1016/S0045-7825(96)01082-1\n\n\n\n\n\n","category":"type"},{"location":"tutorials/tut_dam_break/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_dam_break/","page":"Example file","title":"Example file","text":"!!include:examples/fluid/dam_break_2d.jl!!\n","category":"page"},{"location":"general/neighborhood_search/#Neighborhood-Search","page":"Neighborhood Search","title":"Neighborhood Search","text":"","category":"section"},{"location":"general/neighborhood_search/","page":"Neighborhood Search","title":"Neighborhood Search","text":"Modules = [TrixiParticles]\nPages = map(file -> joinpath(\"neighborhood_search\", file), readdir(joinpath(\"..\", \"src\", \"neighborhood_search\")))","category":"page"},{"location":"general/neighborhood_search/#TrixiParticles.GridNeighborhoodSearch","page":"Neighborhood Search","title":"TrixiParticles.GridNeighborhoodSearch","text":"GridNeighborhoodSearch{NDIMS}(search_radius, n_particles;\n                              periodic_box_min_corner=nothing,\n                              periodic_box_max_corner=nothing)\n\nSimple grid-based neighborhood search with uniform search radius. The domain is divided into a regular grid. For each (non-empty) grid cell, a list of particles in this cell is stored. Instead of representing a finite domain by an array of cells, a potentially infinite domain is represented by storing cell lists in a hash table (using Julia's Dict data structure), indexed by the cell index tuple\n\nleft( leftlfloor fracxd rightrfloor leftlfloor fracyd rightrfloor right) quad textor quad\nleft( leftlfloor fracxd rightrfloor leftlfloor fracyd rightrfloor leftlfloor fraczd rightrfloor right)\n\nwhere x y z are the space coordinates and d is the search radius.\n\nTo find particles within the search radius around a point, only particles in the neighboring cells are considered.\n\nSee also (Chalela et al., 2021), (Ihmsen et al. 2011, Section 4.4).\n\nAs opposed to (Ihmsen et al. 2011), we do not sort the particles in any way, since not sorting makes our implementation a lot faster (although less parallelizable).\n\nArguments\n\nNDIMS:          Number of dimensions.\nsearch_radius:  The uniform search radius.\nn_particles:    Total number of particles.\n\nKeywords\n\nperiodic_box_min_corner:    In order to use a (rectangular) periodic domain, pass the                               coordinates of the domain corner in negative coordinate                               directions.\nperiodic_box_max_corner:    In order to use a (rectangular) periodic domain, pass the                               coordinates of the domain corner in positive coordinate                               directions.\n\nwarning: Internal use only\nPlease note that this constructor is intended for internal use only. It is not part of the public API of TrixiParticles.jl, and it thus can altered (or be removed) at any time without it being considered a breaking change.To run a simulation with this neighborhood search, just pass the type to the constructor of Semidiscretization:semi = Semidiscretization(system1, system2,\n                          neighborhood_search=GridNeighborhoodSearch)The keyword arguments periodic_box_min_corner and periodic_box_max_corner explained above can also be passed to the Semidiscretization and will internally be forwarded to the neighborhood search:semi = Semidiscretization(system1, system2,\n                          neighborhood_search=GridNeighborhoodSearch,\n                          periodic_box_min_corner=[0.0, -0.25],\n                          periodic_box_max_corner=[1.0, 0.75])\n\nReferences\n\nM. Chalela, E. Sillero, L. Pereyra, M.A. Garcia, J.B. Cabral, M. Lares, M. Merchán. \"GriSPy: A Python package for fixed-radius nearest neighbors search\". In: Astronomy and Computing 34 (2021). doi: 10.1016/j.ascom.2020.100443\nMarkus Ihmsen, Nadir Akinci, Markus Becker, Matthias Teschner. \"A Parallel SPH Implementation on Multi-Core CPUs\". In: Computer Graphics Forum 30.1 (2011), pages 99–112. doi: 10.1111/J.1467-8659.2010.01832.X\n\n\n\n\n\n","category":"type"},{"location":"general/neighborhood_search/#TrixiParticles.TrivialNeighborhoodSearch","page":"Neighborhood Search","title":"TrixiParticles.TrivialNeighborhoodSearch","text":"TrivialNeighborhoodSearch{NDIMS}(search_radius, eachparticle)\n\nTrivial neighborhood search that simply loops over all particles. The search radius still needs to be passed in order to sort out particles outside the search radius in the internal function for_particle_neighbor, but it's not used in the internal function eachneighbor.\n\nArguments\n\nNDIMS:          Number of dimensions.\nsearch_radius:  The uniform search radius.\neachparticle:   UnitRange of all particle indices. Usually just 1:n_particles.\n\nKeywords\n\nperiodic_box_min_corner:    In order to use a (rectangular) periodic domain, pass the                               coordinates of the domain corner in negative coordinate                               directions.\nperiodic_box_max_corner:    In order to use a (rectangular) periodic domain, pass the                               coordinates of the domain corner in positive coordinate                               directions.\n\nwarning: Internal use only\nPlease note that this constructor is intended for internal use only. It is not part of the public API of TrixiParticles.jl, and it thus can altered (or be removed) at any time without it being considered a breaking change.To run a simulation with this neighborhood search, just pass the type to the constructor of Semidiscretization:semi = Semidiscretization(system1, system2,\n                          neighborhood_search=TrivialNeighborhoodSearch)The keyword arguments periodic_box_min_corner and periodic_box_max_corner explained above can also be passed to the Semidiscretization and will internally be forwarded to the neighborhood search:semi = Semidiscretization(system1, system2,\n                          neighborhood_search=TrivialNeighborhoodSearch,\n                          periodic_box_min_corner=[0.0, -0.25],\n                          periodic_box_max_corner=[1.0, 0.75])\n\n\n\n\n\n","category":"type"},{"location":"tutorials/tut_falling/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_falling/","page":"Example file","title":"Example file","text":"!!include:examples/fsi/falling_spheres_2d.jl!!\n","category":"page"},{"location":"tutorials/tut_beam/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_beam/","page":"Example file","title":"Example file","text":"!!include:examples/solid/oscillating_beam_2d.jl!!\n","category":"page"},{"location":"general/density_calculators/#density_calculator","page":"Density Calculators","title":"Density Calculators","text":"","category":"section"},{"location":"general/density_calculators/","page":"Density Calculators","title":"Density Calculators","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"general\", \"density_calculators.jl\")]","category":"page"},{"location":"general/density_calculators/#TrixiParticles.ContinuityDensity","page":"Density Calculators","title":"TrixiParticles.ContinuityDensity","text":"ContinuityDensity()\n\nDensity calculator to integrate the density from the continuity equation\n\nfracmathrmdrho_amathrmdt = sum_b m_b v_ab cdot nabla_r_a W(Vert r_a - r_b Vert h)\n\nwhere rho_a denotes the density of particle a and r_ab = r_a - r_b is the difference of the coordinates, v_ab = v_a - v_b of the velocities of particles a and b.\n\n\n\n\n\n","category":"type"},{"location":"general/density_calculators/#TrixiParticles.SummationDensity","page":"Density Calculators","title":"TrixiParticles.SummationDensity","text":"SummationDensity()\n\nDensity calculator to use the summation formula\n\nrho(r) = sum_b m_b W(Vert r - r_b Vert h)\n\nfor the density estimation, where r_b denotes the coordinates and m_b the mass of particle b.\n\n\n\n\n\n","category":"type"},{"location":"general/semidiscretization/#Semidiscretization","page":"Semidiscretization","title":"Semidiscretization","text":"","category":"section"},{"location":"general/semidiscretization/","page":"Semidiscretization","title":"Semidiscretization","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"general\", \"semidiscretization.jl\")]","category":"page"},{"location":"general/semidiscretization/#TrixiParticles.Semidiscretization","page":"Semidiscretization","title":"TrixiParticles.Semidiscretization","text":"Semidiscretization(systems...; neighborhood_search=GridNeighborhoodSearch,\n                   periodic_box_min_corner=nothing, periodic_box_max_corner=nothing)\n\nThe semidiscretization couples the passed systems to one simulation.\n\nThe type of neighborhood search to be used in the simulation can be specified with the keyword argument neighborhood_search. A value of nothing means no neighborhood search.\n\nArguments\n\nsystems: Systems to be coupled in this semidiscretization\n\nKeywords\n\nneighborhood_search:    The type of neighborhood search to be used in the simulation.                           By default, the GridNeighborhoodSearch is used.                           Use TrivialNeighborhoodSearch or nothing to loop                           over all particles (no neighborhood search).\nperiodic_box_min_corner:    In order to use a (rectangular) periodic domain, pass the                               coordinates of the domain corner in negative coordinate                               directions.\nperiodic_box_max_corner:    In order to use a (rectangular) periodic domain, pass the                               coordinates of the domain corner in positive coordinate                               directions.\n\nExamples\n\nsemi = Semidiscretization(fluid_system, boundary_system)\n\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=TrivialNeighborhoodSearch)\n\n\n\n\n\n","category":"type"},{"location":"general/semidiscretization/#TrixiParticles.SourceTermDamping","page":"Semidiscretization","title":"TrixiParticles.SourceTermDamping","text":"SourceTermDamping(; damping_coefficient)\n\nA source term to be used when a damping step is required before running a full simulation. The term -c cdot v_a is added to the acceleration fracmathrmdv_amathrmdt of particle a, where c is the damping coefficient and v_a is the velocity of particle a.\n\nKeywords\n\ndamping_coefficient:    The coefficient d above. A higher coefficient means more                           damping. A coefficient of 1e-4 is a good starting point for                           damping a fluid at rest.\n\nExamples\n\nsource_terms = SourceTermDamping(; damping_coefficient=1e-4)\n\n\n\n\n\n","category":"type"},{"location":"general/semidiscretization/#TrixiParticles.restart_with!-Tuple{Any, Any}","page":"Semidiscretization","title":"TrixiParticles.restart_with!","text":"restart_with!(semi, sol)\n\nSet the initial coordinates and velocities of all systems in semi to the final values in the solution sol. semidiscretize has to be called again afterwards, or another Semidiscretization can be created with the updated systems.\n\nArguments\n\nsemi:   The semidiscretization\nsol:    The ODESolution returned by solve of OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"general/semidiscretization/#TrixiParticles.semidiscretize-Tuple{Any, Any}","page":"Semidiscretization","title":"TrixiParticles.semidiscretize","text":"semidiscretize(semi, tspan; reset_threads=true)\n\nCreate an ODEProblem from the semidiscretization with the specified tspan.\n\nArguments\n\nsemi: A Semidiscretization holding the systems involved in the simulation.\ntspan: The time span over which the simulation will be run.\n\nKeywords\n\nreset_threads: A boolean flag to reset Polyester.jl threads before the simulation (default: true). After an error within a threaded loop, threading might be disabled. Resetting the threads before the simulation ensures that threading is enabled again for the simulation. See also trixi-framework/Trixi.jl#1583.\n\nReturns\n\nA DynamicalODEProblem (see the OrdinaryDiffEq.jl docs) to be integrated with OrdinaryDiffEq.jl. Note that this is not a true DynamicalODEProblem where the acceleration does not depend on the velocity. Therefore, not all integrators designed for DynamicalODEProblems will work properly. However, all integrators designed for ODEProblems can be used.\n\nExamples\n\nsemi = Semidiscretization(fluid_system, boundary_system)\ntspan = (0.0, 1.0)\node_problem = semidiscretize(semi, tspan)\n\n\n\n\n\n","category":"method"},{"location":"systems/boundary/#Boundary-System","page":"Boundary","title":"Boundary System","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"    BoundarySPHSystem","category":"page"},{"location":"systems/boundary/#TrixiParticles.BoundarySPHSystem","page":"Boundary","title":"TrixiParticles.BoundarySPHSystem","text":"BoundarySPHSystem(initial_condition, boundary_model; movement=nothing)\n\nSystem for boundaries modeled by boundary particles. The interaction between fluid and boundary particles is specified by the boundary model.\n\nArguments\n\ninitial_condition: Initial condition (see InitialCondition)\nboundary_model: Boundary model (see Boundary Models)\n\nKeyword Arguments\n\nmovement: For moving boundaries, a BoundaryMovement can be passed.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"    BoundaryMovement","category":"page"},{"location":"systems/boundary/#TrixiParticles.BoundaryMovement","page":"Boundary","title":"TrixiParticles.BoundaryMovement","text":"BoundaryMovement(movement_function, is_moving; moving_particles=nothing)\n\nArguments\n\nmovement_function: Time-dependent function returning an SVector of d dimensions                      for a d-dimensional problem.\nis_moving: Function to determine in each timestep if the particles are moving or not. Its   boolean return value is mandatory to determine if the neighborhood search will be updated.\n\nKeyword Arguments\n\nmoving_particles: Indices of moving particles. Default is each particle in BoundarySPHSystem.\n\nIn the example below, movement describes particles moving in a circle as long as the time is lower than 1.5.\n\nExamples\n\nmovement_function(t) = SVector(cos(2pi*t), sin(2pi*t))\nis_moving(t) = t < 1.5\n\nmovement = BoundaryMovement(movement_function, is_moving)\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#boundary_models","page":"Boundary","title":"Boundary Models","text":"","category":"section"},{"location":"systems/boundary/#Dummy-Particles","page":"Boundary","title":"Dummy Particles","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Boundaries modeled as dummy particles, which are treated like fluid particles, but their positions and velocities are not evolved in time. Since the force towards the fluid should not change with the material density when used with a TotalLagrangianSPHSystem, the dummy particles need to have a mass corresponding to the fluid's rest density, which we call \"hydrodynamic mass\", as opposed to mass corresponding to the material density of a TotalLagrangianSPHSystem.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Here, initial_density and hydrodynamic_mass are vectors that contains the initial density and the hydrodynamic mass respectively for each boundary particle. Note that when used with SummationDensity (see below), this is only used to determine the element type and the number of boundary particles.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"To establish a relationship between density and pressure, a state_equation has to be passed, which should be the same as for the adjacent fluid systems. To sum over neighboring particles, a smoothing_kernel and smoothing_length needs to be passed. This should be the same as for the adjacent fluid system with the largest smoothing length.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"In the literature, this kind of boundary particles is referred to as \"dummy particles\" (Adami et al., 2012 and Valizadeh & Monaghan, 2015), \"frozen fluid particles\" (Akinci et al., 2012) or \"dynamic boundaries (Crespo et al., 2007). The key detail of this boundary condition and the only difference between the boundary models in these references is the way the density and pressure of boundary particles is computed.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Since boundary particles are treated like fluid particles, the force on fluid particle a due to boundary particle b is given by","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"f_ab = m_a m_b left( fracp_arho_a^2 + fracp_brho_b^2 right) nabla_r_a W(Vert r_a - r_b Vert h)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The quantities to be defined here are the density rho_b and pressure p_b of the boundary particle b.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"    BoundaryModelDummyParticles","category":"page"},{"location":"systems/boundary/#TrixiParticles.BoundaryModelDummyParticles","page":"Boundary","title":"TrixiParticles.BoundaryModelDummyParticles","text":"BoundaryModelDummyParticles(initial_density, hydrodynamic_mass,\n                            density_calculator, smoothing_kernel,\n                            smoothing_length; viscosity=nothing,\n                            state_equation=nothing, correction=nothing)\n\nboundary_model for BoundarySPHSystem.\n\nArguments\n\ninitial_density: Vector holding the initial density of each boundary particle.\nhydrodynamic_mass: Vector holding the \"hydrodynamic mass\" of each boundary particle.                      See description above for more information.\ndensity_calculator: Strategy to compute the hydrodynamic density of the boundary particles.                       See description below for more information.\nsmoothing_kernel: Smoothing kernel should be the same as for the adjacent fluid system.\nsmoothing_length: Smoothing length should be the same as for the adjacent fluid system.\n\nKeywords\n\nstate_equation: This should be the same as for the adjacent fluid system                   (see e.g. StateEquationCole).\ncorrection:     Correction method of the adjacent fluid system (see Corrections).\nviscosity:      Slip (default) or no-slip condition. See description below for further                   information.\n\nExamples\n\n# Free-slip condition\nboundary_model = BoundaryModelDummyParticles(densities, masses, AdamiPressureExtrapolation(),\n                                             smoothing_kernel, smoothing_length)\n\n# No-slip condition\nboundary_model = BoundaryModelDummyParticles(densities, masses, AdamiPressureExtrapolation(),\n                                             smoothing_kernel, smoothing_length,\n                                             viscosity=ViscosityAdami(nu=1e-6))\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#Hydrodynamic-density-of-dummy-particles","page":"Boundary","title":"Hydrodynamic density of dummy particles","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"We provide five options to compute the boundary density and pressure, determined by the density_calculator:","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"(Recommended) With AdamiPressureExtrapolation, the pressure is extrapolated from the pressure of the fluid according to (Adami et al., 2012), and the density is obtained by applying the inverse of the state equation. This option usually yields the best results of the options listed here.\nWith SummationDensity, the density is calculated by summation over the neighboring particles, and the pressure is computed from the density with the state equation.\nWith ContinuityDensity, the density is integrated from the continuity equation, and the pressure is computed from the density with the state equation. Note that this causes a gap between fluid and boundary where the boundary is initialized without any contact to the fluid. This is due to overestimation of the boundary density as soon as the fluid comes in contact with boundary particles that initially did not have contact to the fluid. Therefore, in dam break simulations, there is a visible \"step\", even though the boundary is supposed to be flat. See also dual.sphysics.org/faq/#Q_13.\nWith PressureZeroing, the density is set to the reference density and the pressure is computed from the density with the state equation. This option is not recommended. The other options yield significantly better results.\nWith PressureMirroring, the density is set to the reference density. The pressure is not used. Instead, the fluid pressure is mirrored as boundary pressure in the momentum equation. This option is not recommended due to stability issues. See PressureMirroring for more details.","category":"page"},{"location":"systems/boundary/#1.-[AdamiPressureExtrapolation](@ref)","page":"Boundary","title":"1. AdamiPressureExtrapolation","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The pressure of the boundary particles is obtained by extrapolating the pressure of the fluid according to (Adami et al., 2012). The pressure of a boundary particle b is given by","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"p_b = fracsum_f (p_f + rho_f (bmg - bma_b) cdot bmr_bf) W(Vert r_bf Vert h)sum_f W(Vert r_bf Vert h)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the sum is over all fluid particles, rho_f and p_f denote the density and pressure of fluid particle f, respectively, r_bf = r_b - r_f denotes the difference of the coordinates of particles b and f, bmg denotes the gravitational acceleration acting on the fluid, and bma_b denotes the acceleration of the boundary particle b.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"    AdamiPressureExtrapolation","category":"page"},{"location":"systems/boundary/#TrixiParticles.AdamiPressureExtrapolation","page":"Boundary","title":"TrixiParticles.AdamiPressureExtrapolation","text":"AdamiPressureExtrapolation()\n\ndensity_calculator for BoundaryModelDummyParticles.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#4.-[PressureZeroing](@ref)","page":"Boundary","title":"4. PressureZeroing","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"This is the simplest way to implement dummy boundary particles. The density of each particle is set to the reference density and the pressure to the reference pressure (the corresponding pressure to the reference density by the state equation).","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"    PressureZeroing","category":"page"},{"location":"systems/boundary/#TrixiParticles.PressureZeroing","page":"Boundary","title":"TrixiParticles.PressureZeroing","text":"PressureZeroing()\n\ndensity_calculator for BoundaryModelDummyParticles.\n\nnote: Note\nThis boundary model produces significantly worse results than all other models and is only included for research purposes.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#5.-[PressureMirroring](@ref)","page":"Boundary","title":"5. PressureMirroring","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Instead of calculating density and pressure for each boundary particle, we modify the momentum equation,","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"fracmathrmdv_amathrmdt = -sum_b m_b left( fracp_arho_a^2 + fracp_brho_b^2 right) nabla_a W_ab","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"to replace the unknown density rho_b if b is a boundary particle by the reference density and the unknown pressure p_b if b is a boundary particle by the pressure p_a of the interacting fluid particle. The momentum equation therefore becomes","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"fracmathrmdv_amathrmdt = -sum_f m_f left( fracp_arho_a^2 + fracp_frho_f^2 right) nabla_a W_af\n-sum_b m_b left( fracp_arho_a^2 + fracp_arho_0^2 right) nabla_a W_ab","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the first sum is over all fluid particles and the second over all boundary particles.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"This approach was first mentioned by Akinci et al. (2012) and written down in this form by Band et al. (2018).","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"    PressureMirroring","category":"page"},{"location":"systems/boundary/#TrixiParticles.PressureMirroring","page":"Boundary","title":"TrixiParticles.PressureMirroring","text":"PressureMirroring()\n\ndensity_calculator for BoundaryModelDummyParticles.\n\nnote: Note\nThis boundary model requires high viscosity for stability with WCSPH. It also produces significantly worse results than AdamiPressureExtrapolation and is not more efficient because smaller time steps are required due to more noise in the pressure. We added this model only for research purposes and for comparison with SPlisHSPlasH.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#No-slip-conditions","page":"Boundary","title":"No-slip conditions","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"For the interaction of dummy particles and fluid particles, Adami et al. (2012) impose a no-slip boundary condition by assigning a wall velocity v_w to the dummy particle.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The wall velocity of particle a is calculated from the prescribed boundary particle velocity v_a and the smoothed velocity field","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"v_w = 2 v_a - fracsum_b v_b W_absum_b W_ab","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the sum is over all fluid particles.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"By choosing the viscosity model ViscosityAdami for viscosity, a no-slip condition is imposed. It is recommended to choose nu in the order of either the kinematic viscosity parameter of the adjacent fluid or the equivalent from the artificial parameter alpha of the adjacent fluid (nu = fracalpha h c 2d + 4). When omitting the viscous interaction (default viscosity=nothing), a free-slip wall boundary condition is applied.","category":"page"},{"location":"systems/boundary/#References","page":"Boundary","title":"References","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"S. Adami, X. Y. Hu, N. A. Adams. \"A generalized wall boundary condition for smoothed particle hydrodynamics\". In: Journal of Computational Physics 231, 21 (2012), pages 7057–7075. doi: 10.1016/J.JCP.2012.05.005\nAlireza Valizadeh, Joseph J. Monaghan. \"A study of solid wall models for weakly compressible SPH\". In: Journal of Computational Physics 300 (2015), pages 5–19. doi: 10.1016/J.JCP.2015.07.033\nNadir Akinci, Markus Ihmsen, Gizem Akinci, Barbara Solenthaler, Matthias Teschner. \"Versatile rigid-fluid coupling for incompressible SPH\". ACM Transactions on Graphics 31, 4 (2012), pages 1–8. doi: 10.1145/2185520.2185558\nA. J. C. Crespo, M. Gómez-Gesteira, R. A. Dalrymple. \"Boundary conditions generated by dynamic particles in SPH methods\" In: Computers, Materials and Continua 5 (2007), pages 173-184. doi: 10.3970/cmc.2007.005.173\nStefan Band, Christoph Gissler, Andreas Peer, and Matthias Teschner. \"MLS Pressure Boundaries for Divergence-Free and Viscous SPH Fluids.\" In: Computers & Graphics 76 (2018), pages 37–46. doi: 10.1016/j.cag.2018.08.001","category":"page"},{"location":"systems/boundary/#Repulsive-Particles","page":"Boundary","title":"Repulsive Particles","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Boundaries modeled as boundary particles which exert forces on the fluid particles (Monaghan, Kajtar, 2009). The force on fluid particle a due to boundary particle b is given by","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"f_ab = m_a left(tildef_ab - m_b Pi_ab nabla_r_a W(Vert r_a - r_b Vert h)right)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"with","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"tildef_ab = fracKbeta^n-1 fracr_abVert r_ab Vert (Vert r_ab Vert - d) Phi(Vert r_ab Vert h)\nfrac2 m_bm_a + m_b","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where m_a and m_b are the masses of fluid particle a and boundary particle b respectively, r_ab = r_a - r_b is the difference of the coordinates of particles a and b, d denotes the boundary particle spacing and n denotes the number of dimensions (see (Monaghan, Kajtar, 2009, Equation (3.1)) and (Valizadeh, Monaghan, 2015)). Note that the repulsive acceleration tildef_ab does not depend on the masses of the boundary particles. Here, Phi denotes the 1D Wendland C4 kernel, normalized to 177 for q=0 (Monaghan, Kajtar, 2009, Section 4), with Phi(r h) = w(rh) and","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"w(q) =\nbegincases\n  (17732) (1 + (52)q + 2q^2)(2 - q)^5   textif  0 leq q  2 \n  0                                        textif  q geq 2\nendcases","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The boundary particles are assumed to have uniform spacing by the factor beta smaller than the expected fluid particle spacing. For example, if the fluid particles have an expected spacing of 03 and the boundary particles have a uniform spacing of 01, then this parameter should be set to beta = 3. According to (Monaghan, Kajtar, 2009), a value of beta = 3 for the Wendland C4 that we use here is reasonable for most computing purposes.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The parameter K is used to scale the force exerted by the boundary particles. In (Monaghan, Kajtar, 2009), a value of gD is used for static tank simulations, where g is the gravitational acceleration and D is the depth of the fluid.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The viscosity Pi_ab is calculated according to the viscosity used in the simulation, where the density of the boundary particle if needed is assumed to be identical to the density of the fluid particle.","category":"page"},{"location":"systems/boundary/#No-slip-condition","page":"Boundary","title":"No-slip condition","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"By choosing the viscosity model ArtificialViscosityMonaghan for viscosity, a no-slip condition is imposed. When omitting the viscous interaction (default viscosity=nothing), a free-slip wall boundary condition is applied.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"warning: Warning\nThe no-slip conditions for BoundaryModelMonaghanKajtar have not been verified yet.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"boundary\", \"monaghan_kajtar\", \"monaghan_kajtar.jl\")]","category":"page"},{"location":"systems/boundary/#TrixiParticles.BoundaryModelMonaghanKajtar","page":"Boundary","title":"TrixiParticles.BoundaryModelMonaghanKajtar","text":"BoundaryModelMonaghanKajtar(K, beta, boundary_particle_spacing, mass;\n                            viscosity=nothing)\n\nboundary_model for BoundarySPHSystem.\n\nArguments\n\nK: Scaling factor for repulsive force.\nbeta: Ratio of fluid particle spacing to boundary particle spacing.\nboundary_particle_spacing: Boundary particle spacing.\nmass: Vector holding the mass of each boundary particle.\n\nKeywords\n\nviscosity:  Free-slip (default) or no-slip condition. See description above for further               information.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#References-2","page":"Boundary","title":"References","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Joseph J. Monaghan, Jules B. Kajtar. \"SPH particle boundary forces for arbitrary boundaries\". In: Computer Physics Communications 180.10 (2009), pages 1811–1820. doi: 10.1016/j.cpc.2009.05.008\nAlireza Valizadeh, Joseph J. Monaghan. \"A study of solid wall models for weakly compressible SPH.\" In: Journal of Computational Physics 300 (2015), pages 5–19. doi: 10.1016/J.JCP.2015.07.033","category":"page"},{"location":"news/","page":"News","title":"News","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/NEWS.md\"","category":"page"},{"location":"news/#Changelog","page":"News","title":"Changelog","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"TrixiParticles.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.  We aim at 3 to 4 month between major release versions and about 2 weeks between minor versions. ","category":"page"},{"location":"news/#Version-0.1.x","page":"News","title":"Version 0.1.x","text":"","category":"section"},{"location":"news/#Highlights","page":"News","title":"Highlights","text":"","category":"section"},{"location":"news/#Added","page":"News","title":"Added","text":"","category":"section"},{"location":"news/#Removed","page":"News","title":"Removed","text":"","category":"section"},{"location":"news/#Deprecated","page":"News","title":"Deprecated","text":"","category":"section"},{"location":"news/#Pre-Initial-Release-(v0.1.0)","page":"News","title":"Pre Initial Release (v0.1.0)","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"This section summarizes the initial features that TrixiParticles.jl was released with.","category":"page"},{"location":"news/#Highlights-2","page":"News","title":"Highlights","text":"","category":"section"},{"location":"news/#EDAC","page":"News","title":"EDAC","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"An implementation of EDAC (Entropically Damped Artificial Compressibility) was added, which allows for more stable simulations compared to basic WCSPH and reduces spurious pressure oscillations.","category":"page"},{"location":"news/#WCSPH","page":"News","title":"WCSPH","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"An implementation of WCSPH (Weakly Compressible Smoothed Particle Hydrodynamics), which is the classical SPH approach.","category":"page"},{"location":"news/","page":"News","title":"News","text":"Features:","category":"page"},{"location":"news/","page":"News","title":"News","text":"Correction schemes (Shepard (0. Order) ... MixedKernelGradient (1. Order))\nDensity reinitialization\nKernel summation and Continuity equation density formulations\nFlexible boundary conditions e.g. dummy particles with Adami pressure extrapolation, pressure zeroing, pressure mirroring...\nMoving boundaries\nDensity diffusion based on the models by Molteni & Colagrossi (2009), Ferrari et al. (2009) and Antuono et al. (2010).","category":"page"},{"location":"news/#TLSPH","page":"News","title":"TLSPH","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"An implementation of TLSPH (Total Lagrangian Smoothed Particle Hydrodynamics) for solid bodies enabling FSI (Fluid Structure Interactions).","category":"page"},{"location":"general/util/#Util","page":"Util","title":"Util","text":"","category":"section"},{"location":"general/util/","page":"Util","title":"Util","text":"Modules = [TrixiParticles]\nPages = [\"util.jl\"]","category":"page"},{"location":"general/util/#TrixiParticles.examples_dir-Tuple{}","page":"Util","title":"TrixiParticles.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with TrixiParticles.jl are located. If TrixiParticles is installed as a regular package (with ]add TrixiParticles), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir.\n\nCopied from Trixi.jl.\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"general/util/#TrixiParticles.validation_dir-Tuple{}","page":"Util","title":"TrixiParticles.validation_dir","text":"validation_dir()\n\nReturn the directory where the validation files provided with TrixiParticles.jl are located. If TrixiParticles is installed as a regular package (with ]add TrixiParticles), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir.\n\nCopied from Trixi.jl.\n\nExamples\n\nreaddir(validation_dir())\n\n\n\n\n\n","category":"method"},{"location":"general/util/#TrixiParticles.@autoinfiltrate","page":"Util","title":"TrixiParticles.@autoinfiltrate","text":"@autoinfiltrate\n@autoinfiltrate condition::Bool\n\nInvoke the @infiltrate macro of the package Infiltrator.jl to create a breakpoint for ad-hoc interactive debugging in the REPL. If the optional argument condition is given, the breakpoint is only enabled if condition evaluates to true.\n\nAs opposed to using Infiltrator.@infiltrate directly, this macro does not require Infiltrator.jl to be added as a dependency to TrixiParticles.jl. As a bonus, the macro will also attempt to load the Infiltrator module if it has not yet been loaded manually.\n\nNote: For this macro to work, the Infiltrator.jl package needs to be installed in your current Julia environment stack.\n\nSee also: Infiltrator.jl\n\nwarning: Internal use only\nPlease note that this macro is intended for internal use only. It is not part of the public API of TrixiParticles.jl, and it thus can altered (or be removed) at any time without it being considered a breaking change.\n\n\n\n\n\n","category":"macro"},{"location":"general/util/#TrixiParticles.@threaded-Tuple{Any}","page":"Util","title":"TrixiParticles.@threaded","text":"@threaded for ... end\n\nSemantically the same as Threads.@threads when iterating over a AbstractUnitRange but without guarantee that the underlying implementation uses Threads.@threads or works for more general for loops. In particular, there may be an additional check whether only one thread is used to reduce the overhead of serial execution or the underlying threading capabilities might be provided by other packages such as Polyester.jl.\n\nwarn: Warn\nThis macro does not necessarily work for general for loops. For example, it does not necessarily support general iterables such as eachline(filename).\n\nSome discussion can be found at https://discourse.julialang.org/t/overhead-of-threads-threads/53964 and https://discourse.julialang.org/t/threads-threads-with-one-thread-how-to-remove-the-overhead/58435.\n\nCopied from Trixi.jl.\n\n\n\n\n\n","category":"macro"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/CODE_OF_CONDUCT.md\"","category":"page"},{"location":"code_of_conduct/#Code-of-Conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Michael Schlottke-Lakemper, Sven Berger, or any other of the principal developers responsible for enforcement listed in Authors. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"tutorials/tut_dam_break_replaced/","page":"Example file","title":"Example file","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/docs/src/tutorials/tut_dam_break.md\"","category":"page"},{"location":"tutorials/tut_dam_break_replaced/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_dam_break_replaced/","page":"Example file","title":"Example file","text":"# 2D dam break simulation based on\n#\n# S. Marrone, M. Antuono, A. Colagrossi, G. Colicchio, D. le Touzé, G. Graziani.\n# \"δ-SPH model for simulating violent impact flows\".\n# In: Computer Methods in Applied Mechanics and Engineering, Volume 200, Issues 13–16 (2011), pages 1526–1542.\n# https://doi.org/10.1016/J.CMA.2010.12.016\n\nusing TrixiParticles\nusing OrdinaryDiffEq\n\n# ==========================================================================================\n# ==== Resolution\nfluid_particle_spacing = 0.02\n\n# Change spacing ratio to 3 and boundary layers to 1 when using Monaghan-Kajtar boundary model\nboundary_layers = 3\nspacing_ratio = 1\n\nboundary_particle_spacing = fluid_particle_spacing / spacing_ratio\n\n# ==========================================================================================\n# ==== Experiment Setup\ngravity = 9.81\ntspan = (0.0, 5.7 / sqrt(gravity))\n\n# Boundary geometry and initial fluid particle positions\ninitial_fluid_size = (2.0, 1.0)\ntank_size = (floor(5.366 / boundary_particle_spacing) * boundary_particle_spacing, 4.0)\n\nfluid_density = 1000.0\nsound_speed = 20 * sqrt(gravity * initial_fluid_size[2])\nstate_equation = StateEquationCole(; sound_speed, reference_density=fluid_density,\n                                   exponent=7, clip_negative_pressure=false)\n\ntank = RectangularTank(fluid_particle_spacing, initial_fluid_size, tank_size, fluid_density,\n                       n_layers=boundary_layers, spacing_ratio=spacing_ratio,\n                       acceleration=(0.0, -gravity), state_equation=state_equation)\n\n# ==========================================================================================\n# ==== Fluid\nsmoothing_length = 3.0 * fluid_particle_spacing\nsmoothing_kernel = WendlandC2Kernel{2}()\n\nfluid_density_calculator = ContinuityDensity()\nviscosity = ArtificialViscosityMonaghan(alpha=0.02, beta=0.0)\ndensity_diffusion = DensityDiffusionMolteniColagrossi(delta=0.1)\n# density_diffusion = DensityDiffusionAntuono(tank.fluid, delta=0.1)\n\nfluid_system = WeaklyCompressibleSPHSystem(tank.fluid, fluid_density_calculator,\n                                           state_equation, smoothing_kernel,\n                                           smoothing_length, viscosity=viscosity,\n                                           density_diffusion=density_diffusion,\n                                           acceleration=(0.0, -gravity), correction=nothing)\n\n# ==========================================================================================\n# ==== Boundary\nboundary_density_calculator = AdamiPressureExtrapolation()\nboundary_model = BoundaryModelDummyParticles(tank.boundary.density, tank.boundary.mass,\n                                             state_equation=state_equation,\n                                             boundary_density_calculator,\n                                             smoothing_kernel, smoothing_length,\n                                             correction=nothing)\n\nboundary_system = BoundarySPHSystem(tank.boundary, boundary_model)\n\n# ==========================================================================================\n# ==== Simulation\nsemi = Semidiscretization(fluid_system, boundary_system)\node = semidiscretize(semi, tspan)\n\ninfo_callback = InfoCallback(interval=100)\nsaving_callback = SolutionSavingCallback(dt=0.02, prefix=\"\")\n\nuse_reinit = false\ndensity_reinit_cb = use_reinit ? DensityReinitializationCallback(semi.systems[1], dt=0.01) :\n                    nothing\nstepsize_callback = StepsizeCallback(cfl=1.1)\n\ncallbacks = CallbackSet(info_callback, saving_callback, stepsize_callback)\n\nsol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt=1.0, # This is overwritten by the stepsize callback\n            save_everystep=false, callback=callbacks);\n\n","category":"page"},{"location":"systems/entropically_damped_sph/#edac","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility (EDAC) for SPH","text":"","category":"section"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"As opposed to the weakly compressible SPH scheme, which uses an equation of state, this scheme uses a pressure evolution equation to calculate the pressure","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"fracmathrmd p_amathrmdt =  - rho c_s^2 nabla cdot v + nu nabla^2 p","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"which is derived by Clausen (2013). This equation is similar to the continuity equation (first term, see ContinuityDensity), but also contains a pressure damping term (second term, similar to density diffusion see DensityDiffusion), which reduces acoustic pressure waves through an entropy-generation mechanism.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The pressure evolution is discretized with the SPH method by Ramachandran (2019) as following:","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The first term is equivalent to the classical artificial compressible methods, which are commonly motivated by assuming the artificial equation of state (StateEquationCole with exponent=1) and is discretized as","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"- rho c_s^2 nabla cdot v = sum_b m_b fracrho_arho_b c_s^2 v_ab cdot nabla_r_a W(Vert r_a - r_b Vert h)","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where rho_a, rho_b,  r_a, r_b, denote the density and coordinates of particles a and b respectively, c_s is the speed of sound and v_ab = v_a - v_b is the difference in the velocity.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The second term smooths the pressure through the introduction of entropy and is discretized as","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"nu nabla^2 p = fracV_a^2 + V_b^2m_a tildeeta_ab fracp_abVert r_ab^2 Vert + eta h_ab^2 nabla_r_a\nW(Vert r_a - r_b Vert h) cdot r_ab","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where V_a, V_b denote the volume of particles a and b respectively and p_ab= p_a -p_b  is the difference in the pressure.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The viscosity parameter eta_a for a particle a is given as","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"eta_a = rho_a fracalpha h c_s8","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where it is found in the numerical experiments of Ramachandran (2019) that alpha = 05 is a good choice for a wide range of Reynolds numbers (0.0125 to 10000).","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"note: Note\nThe EDAC formulation keeps the density constant and this eliminates the need for the continuity equation or the use of a summation density to ﬁnd the pressure. However, in SPH discretizations, mrho is typically used as a proxy for the particle volume. The density of the ﬂuids can therefore be computed using the summation density approach.Ramachandran (2019)","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"fluid\", \"entropically_damped_sph\", \"system.jl\")]","category":"page"},{"location":"systems/entropically_damped_sph/#TrixiParticles.EntropicallyDampedSPHSystem","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"TrixiParticles.EntropicallyDampedSPHSystem","text":"EntropicallyDampedSPHSystem(initial_condition, smoothing_kernel,\n                            smoothing_length, sound_speed;\n                            pressure_acceleration=inter_particle_averaged_pressure,\n                            density_calculator=SummationDensity(),\n                            alpha=0.5, viscosity=nothing,\n                            acceleration=ntuple(_ -> 0.0, NDIMS),\n                            source_terms=nothing)\n\nSystem for particles of a fluid. As opposed to the weakly compressible SPH scheme, which uses an equation of state, this scheme uses a pressure evolution equation to calculate the pressure. See Entropically Damped Artificial Compressibility for SPH for more details on the method.\n\nArguments\n\ninitial_condition:  Initial condition representing the system's particles.\nsound_speed:        Speed of sound.\nsmoothing_kernel:   Smoothing kernel to be used for this system.                       See Smoothing Kernels.\nsmoothing_length:   Smoothing length to be used for this system.                       See Smoothing Kernels.\n\nKeyword Arguments\n\nviscosity:      Viscosity model for this system (default: no viscosity).                   Recommended: ViscosityAdami.\nacceleration:   Acceleration vector for the system. (default: zero vector)\npressure_acceleration: Pressure acceleration formulation (default: inter-particle averaged pressure).                       When set to nothing, the pressure acceleration formulation for the                       corresponding density calculator is chosen.\ndensity_calculator: Density calculator (default: SummationDensity)\nsource_terms:   Additional source terms for this system. Has to be either nothing                   (by default), or a function of (coords, velocity, density, pressure)                   (which are the quantities of a single particle), returning a Tuple                   or SVector that is to be added to the acceleration of that particle.                   See, for example, SourceTermDamping.                   Note that these source terms will not be used in the calculation of the                   boundary pressure when using a boundary with                   BoundaryModelDummyParticles and AdamiPressureExtrapolation.                   The keyword argument acceleration should be used instead for                   gravity-like source terms.\n\n\n\n\n\n","category":"type"},{"location":"systems/entropically_damped_sph/#References","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"References","text":"","category":"section"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"Prabhu Ramachandran. \"Entropically damped artiﬁcial compressibility for SPH\". In: Computers and Fluids 179 (2019), pages 579–594. doi: 10.1016/j.compfluid.2018.11.023\nJonathan R. Clausen. \"Entropically damped form of artificial compressibility for explicit simulation of incompressible flow\". In: American Physical Society 87 (2013), page 13309. doi: 10.1103/PhysRevE.87.013309","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/AUTHORS.md\"","category":"page"},{"location":"authors/#Authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"TrixiParticles.jl's development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about TrixiParticles.jl. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The TrixiParticles.jl Authors\" as mentioned under License.","category":"page"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Erik Faulhaber, University of Cologne, Germany\nNiklas Neher, High-Performance Computing Center Stuttgart (HLRS), Germany\nSven Berger, Helmholtz Center Hereon, Germany","category":"page"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The following people contributed major additions or modifications to TrixiParticles.jl and are listed in alphabetical order:","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"Sven Berger\nErik Faulhaber\nGregor Gassner\nNiklas Neher\nHendrik Ranocha\nMichael Schlottke-Lakemper","category":"page"},{"location":"tutorials/tut_setup_replaced/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/docs/src/tutorials/tut_setup.md\"","category":"page"},{"location":"tutorials/tut_setup_replaced/#Setting-up-your-simulation-from-scratch","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"section"},{"location":"tutorials/tut_setup_replaced/#Hydrostatic-tank","page":"Setting up your simulation from scratch","title":"Hydrostatic tank","text":"","category":"section"},{"location":"tutorials/tut_setup_replaced/#Example-file","page":"Setting up your simulation from scratch","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_setup_replaced/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using TrixiParticles\nusing OrdinaryDiffEq\n\n# ==========================================================================================\n# ==== Resolution\nfluid_particle_spacing = 0.05\n\n# Make sure that the kernel support of fluid particles at a boundary is always fully sampled\nboundary_layers = 3\n\n# ==========================================================================================\n# ==== Experiment Setup\ngravity = 9.81\ntspan = (0.0, 1.0)\n\n# Boundary geometry and initial fluid particle positions\ninitial_fluid_size = (1.0, 0.9)\ntank_size = (1.0, 1.0)\n\nfluid_density = 1000.0\nsound_speed = 10.0\nstate_equation = StateEquationCole(; sound_speed, reference_density=fluid_density,\n                                   exponent=7, clip_negative_pressure=false)\n\ntank = RectangularTank(fluid_particle_spacing, initial_fluid_size, tank_size, fluid_density,\n                       n_layers=boundary_layers,\n                       acceleration=(0.0, -gravity), state_equation=state_equation)\n\n# ==========================================================================================\n# ==== Fluid\nsmoothing_length = 1.2 * fluid_particle_spacing\nsmoothing_kernel = SchoenbergCubicSplineKernel{2}()\n\nviscosity = ArtificialViscosityMonaghan(alpha=0.02, beta=0.0)\n\nfluid_density_calculator = ContinuityDensity()\nfluid_system = WeaklyCompressibleSPHSystem(tank.fluid, fluid_density_calculator,\n                                           state_equation, smoothing_kernel,\n                                           smoothing_length, viscosity=viscosity,\n                                           acceleration=(0.0, -gravity),\n                                           source_terms=nothing)\n\n# ==========================================================================================\n# ==== Boundary\n\n# This is to set another boundary density calculation with `trixi_include`\nboundary_density_calculator = AdamiPressureExtrapolation()\n\n# This is to set wall viscosity with `trixi_include`\nviscosity_wall = nothing\nboundary_model = BoundaryModelDummyParticles(tank.boundary.density, tank.boundary.mass,\n                                             state_equation=state_equation,\n                                             boundary_density_calculator,\n                                             smoothing_kernel, smoothing_length,\n                                             viscosity=viscosity_wall)\nboundary_system = BoundarySPHSystem(tank.boundary, boundary_model, movement=nothing)\n\n# ==========================================================================================\n# ==== Simulation\nsemi = Semidiscretization(fluid_system, boundary_system)\node = semidiscretize(semi, tspan)\n\ninfo_callback = InfoCallback(interval=50)\nsaving_callback = SolutionSavingCallback(dt=0.02, prefix=\"\")\n\n# This is to easily add a new callback with `trixi_include`\nextra_callback = nothing\n\ncallbacks = CallbackSet(info_callback, saving_callback, extra_callback)\n\n# Use a Runge-Kutta method with automatic (error based) time step size control\nsol = solve(ode, RDPK3SpFSAL35(), save_everystep=false, callback=callbacks);\n\n","category":"page"},{"location":"tutorials/tut_falling_replaced/","page":"Example file","title":"Example file","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/docs/src/tutorials/tut_falling.md\"","category":"page"},{"location":"tutorials/tut_falling_replaced/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_falling_replaced/","page":"Example file","title":"Example file","text":"using TrixiParticles\nusing OrdinaryDiffEq\n\n# ==========================================================================================\n# ==== Resolution\nfluid_particle_spacing = 0.02\nsolid_particle_spacing = fluid_particle_spacing\n\n# Change spacing ratio to 3 and boundary layers to 1 when using Monaghan-Kajtar boundary model\nboundary_layers = 3\nspacing_ratio = 1\n\n# ==========================================================================================\n# ==== Experiment Setup\ngravity = 9.81\ntspan = (0.0, 2.0)\n\n# Boundary geometry and initial fluid particle positions\ninitial_fluid_size = (2.0, 0.9)\ntank_size = (2.0, 1.0)\n\nfluid_density = 1000.0\nsound_speed = 10 * sqrt(gravity * initial_fluid_size[2])\nstate_equation = StateEquationCole(; sound_speed, reference_density=fluid_density,\n                                   exponent=7)\n\ntank = RectangularTank(fluid_particle_spacing, initial_fluid_size, tank_size, fluid_density,\n                       n_layers=boundary_layers, spacing_ratio=spacing_ratio,\n                       faces=(true, true, true, false),\n                       acceleration=(0.0, -gravity), state_equation=state_equation)\n\nsphere1_radius = 0.3\nsphere2_radius = 0.2\nsphere1_density = 500.0\nsphere2_density = 1100.0\n\n# Young's modulus and Poisson ratio\nsphere1_E = 7e4\nsphere2_E = 1e5\nnu = 0.0\n\nsphere1 = SphereShape(solid_particle_spacing, sphere1_radius, (0.5, 1.6),\n                      sphere1_density)\nsphere2 = SphereShape(solid_particle_spacing, sphere2_radius, (1.5, 1.6),\n                      sphere2_density)\n\n# ==========================================================================================\n# ==== Fluid\nfluid_smoothing_length = 1.2 * fluid_particle_spacing\nfluid_smoothing_kernel = SchoenbergCubicSplineKernel{2}()\n\nfluid_density_calculator = ContinuityDensity()\nviscosity = ArtificialViscosityMonaghan(alpha=0.02, beta=0.0)\n\nfluid_system = WeaklyCompressibleSPHSystem(tank.fluid, fluid_density_calculator,\n                                           state_equation, fluid_smoothing_kernel,\n                                           fluid_smoothing_length, viscosity=viscosity,\n                                           acceleration=(0.0, -gravity))\n\n# ==========================================================================================\n# ==== Boundary\nboundary_density_calculator = AdamiPressureExtrapolation()\nboundary_model = BoundaryModelDummyParticles(tank.boundary.density, tank.boundary.mass,\n                                             state_equation=state_equation,\n                                             boundary_density_calculator,\n                                             fluid_smoothing_kernel, fluid_smoothing_length)\n\nboundary_system = BoundarySPHSystem(tank.boundary, boundary_model)\n\n# ==========================================================================================\n# ==== Solid\nsolid_smoothing_length = sqrt(2) * solid_particle_spacing\nsolid_smoothing_kernel = SchoenbergCubicSplineKernel{2}()\n\n# For the FSI we need the hydrodynamic masses and densities in the solid boundary model\nhydrodynamic_densites_1 = fluid_density * ones(size(sphere1.density))\nhydrodynamic_masses_1 = hydrodynamic_densites_1 * solid_particle_spacing^2\n\nsolid_boundary_model_1 = BoundaryModelDummyParticles(hydrodynamic_densites_1,\n                                                     hydrodynamic_masses_1,\n                                                     state_equation=state_equation,\n                                                     boundary_density_calculator,\n                                                     fluid_smoothing_kernel,\n                                                     fluid_smoothing_length)\n\nhydrodynamic_densites_2 = fluid_density * ones(size(sphere2.density))\nhydrodynamic_masses_2 = hydrodynamic_densites_2 * solid_particle_spacing^2\n\nsolid_boundary_model_2 = BoundaryModelDummyParticles(hydrodynamic_densites_2,\n                                                     hydrodynamic_masses_2,\n                                                     state_equation=state_equation,\n                                                     boundary_density_calculator,\n                                                     fluid_smoothing_kernel,\n                                                     fluid_smoothing_length)\n\nsolid_system_1 = TotalLagrangianSPHSystem(sphere1,\n                                          solid_smoothing_kernel, solid_smoothing_length,\n                                          sphere1_E, nu,\n                                          acceleration=(0.0, -gravity),\n                                          boundary_model=solid_boundary_model_1,\n                                          penalty_force=PenaltyForceGanzenmueller(alpha=0.3))\n\nsolid_system_2 = TotalLagrangianSPHSystem(sphere2,\n                                          solid_smoothing_kernel, solid_smoothing_length,\n                                          sphere2_E, nu,\n                                          acceleration=(0.0, -gravity),\n                                          boundary_model=solid_boundary_model_2,\n                                          penalty_force=PenaltyForceGanzenmueller(alpha=0.3))\n\n# ==========================================================================================\n# ==== Simulation\nsemi = Semidiscretization(fluid_system, boundary_system, solid_system_1, solid_system_2)\node = semidiscretize(semi, tspan)\n\ninfo_callback = InfoCallback(interval=10)\nsaving_callback = SolutionSavingCallback(dt=0.02, prefix=\"\")\n\ncallbacks = CallbackSet(info_callback, saving_callback)\n\n# Use a Runge-Kutta method with automatic (error based) time step size control.\n# Limiting of the maximum stepsize is necessary to prevent crashing.\n# When particles are approaching a wall in a uniform way, they can be advanced\n# with large time steps. Close to the wall, the stepsize has to be reduced drastically.\n# Sometimes, the method fails to do so because forces become extremely large when\n# fluid particles are very close to boundary particles, and the time integration method\n# interprets this as an instability.\nsol = solve(ode, RDPK3SpFSAL49(),\n            abstol=1e-5, # Default abstol is 1e-6 (may need to be tuned to prevent boundary penetration)\n            reltol=1e-3, # Default reltol is 1e-3 (may need to be tuned to prevent boundary penetration)\n            dtmax=1e-2, # Limit stepsize to prevent crashing\n            save_everystep=false, callback=callbacks);\n\n","category":"page"},{"location":"tutorials/tut_setup/#Setting-up-your-simulation-from-scratch","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"section"},{"location":"tutorials/tut_setup/#Hydrostatic-tank","page":"Setting up your simulation from scratch","title":"Hydrostatic tank","text":"","category":"section"},{"location":"tutorials/tut_setup/#Example-file","page":"Setting up your simulation from scratch","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"!!include:examples/fluid/hydrostatic_water_column_2d.jl!!\n","category":"page"},{"location":"systems/total_lagrangian_sph/#tlsph","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH","text":"","category":"section"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"A Total Lagrangian framework is used wherein the governing equations are formulated such that all relevant quantities and operators are measured with respect to the initial configuration (O’Connor & Rogers 2021, Belytschko et al. 2000).","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The governing equations with respect to the initial configuration are given by:","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"fracmathrmDbmvmathrmDt = frac1rho_0 nabla_0 cdot bmP + bmg","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"where the zero subscript denotes a derivative with respect to the initial configuration and bmP is the first Piola-Kirchhoff (PK1) stress tensor.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The discretized version of this equation is given by O’Connor & Rogers (2021):","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"fracmathrmdbmv_amathrmdt = sum_b m_0b\n    left( fracbmP_a bmL_0arho_0a^2 + fracbmP_b bmL_0brho_0b^2 right)\n    nabla_0a W(bmX_ab) + fracbmf_a^PFm_0a + bmg","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"with the correction matrix (see also GradientCorrection)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmL_0a = left( -sum_b fracm_0brho_0b nabla_0a W(bmX_ab) bmX_ab^T right)^-1 in R^d times d","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The subscripts a and b denote quantities of particle a and b, respectively. The zero subscript on quantities denotes that the quantity is to be measured in the initial configuration. The difference in the initial coordinates is denoted by bmX_ab = bmX_a - bmX_b, the difference in the current coordinates is denoted by bmx_ab = bmx_a - bmx_b.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"For the computation of the PK1 stress tensor, the deformation gradient bmF is computed per particle as","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmF_a = sum_b fracm_0brho_0b bmx_ba (bmL_0anabla_0a W(bmX_ab))^T \n    qquad  = -left(sum_b fracm_0brho_0b bmx_ab (nabla_0a W(bmX_ab))^T right) bmL_0a^T","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"with 1 leq ij leq d. From the deformation gradient, the Green-Lagrange strain","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmE = frac12(bmF^TbmF - bmI)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"and the second Piola-Kirchhoff stress tensor","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmS = lambda operatornametr(bmE) bmI + 2mu bmE","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"are computed to obtain the PK1 stress tensor as","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmP = bmFbmS","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Here,","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"mu = fracE2(1 + nu)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"and","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"lambda = fracEnu(1 + nu)(1 - 2nu)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"are the Lamé coefficients, where E is the Young's modulus and nu is the Poisson ratio.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The term bmf_a^PF is an optional penalty force. See e.g. PenaltyForceGanzenmueller.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"solid\", \"total_lagrangian_sph\", \"system.jl\")]","category":"page"},{"location":"systems/total_lagrangian_sph/#TrixiParticles.TotalLagrangianSPHSystem","page":"Total Lagrangian SPH (Elastic Structure)","title":"TrixiParticles.TotalLagrangianSPHSystem","text":"TotalLagrangianSPHSystem(initial_condition,\n                         smoothing_kernel, smoothing_length,\n                         young_modulus, poisson_ratio;\n                         n_fixed_particles=0, boundary_model=nothing,\n                         acceleration=ntuple(_ -> 0.0, NDIMS),\n                         penalty_force=nothing, source_terms=nothing)\n\nSystem for particles of an elastic structure.\n\nA Total Lagrangian framework is used wherein the governing equations are formulated such that all relevant quantities and operators are measured with respect to the initial configuration (O’Connor & Rogers 2021, Belytschko et al. 2000). See Total Lagrangian SPH for more details on the method.\n\nArguments\n\ninitial_condition:  Initial condition representing the system's particles.\nyoung_modulus:      Young's modulus.\npoisson_ratio:      Poisson ratio.\nsmoothing_kernel:   Smoothing kernel to be used for this system.                       See Smoothing Kernels.\nsmoothing_length:   Smoothing length to be used for this system.                       See Smoothing Kernels.\n\nKeyword Arguments\n\nn_fixed_particles:  Number of fixed particles which are used to clamp the structure                       particles. Note that the fixed particles must be the last                       particles in the InitialCondition. See the info box below.\nboundary_model: Boundary model to compute the hydrodynamic density and pressure for                   fluid-structure interaction (see Boundary Models).\npenalty_force:  Penalty force to ensure regular particle position under large deformations                   (see PenaltyForceGanzenmueller).\nacceleration:   Acceleration vector for the system. (default: zero vector)\nsource_terms:   Additional source terms for this system. Has to be either nothing                   (by default), or a function of (coords, velocity, density, pressure)                   (which are the quantities of a single particle), returning a Tuple                   or SVector that is to be added to the acceleration of that particle.                   See, for example, SourceTermDamping.\n\nnote: Note\nThe fixed particles must be the last particles in the InitialCondition. To do so, e.g. use the union function:solid = union(beam, fixed_particles)where beam and fixed_particles are of type InitialCondition.\n\n\n\n\n\n","category":"type"},{"location":"systems/total_lagrangian_sph/#References","page":"Total Lagrangian SPH (Elastic Structure)","title":"References","text":"","category":"section"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Joseph O’Connor, Benedict D. Rogers. \"A fluid-structure interaction model for free-surface flows and flexible structures using smoothed particle hydrodynamics on a GPU\". In: Journal of Fluids and Structures 104 (2021). doi: 10.1016/J.JFLUIDSTRUCTS.2021.103312\nTed Belytschko, Yong Guo, Wing Kam Liu, Shao Ping Xiao. \"A unified stability analysis of meshless particle methods\". In: International Journal for Numerical Methods in Engineering 48 (2000), pages 1359–1400. doi: 10.1002/1097-0207","category":"page"},{"location":"systems/total_lagrangian_sph/#Penalty-Force","page":"Total Lagrangian SPH (Elastic Structure)","title":"Penalty Force","text":"","category":"section"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"In FEM, underintegrated elements can deform without an associated increase of energy. This is caused by the stiffness matrix having zero eigenvalues (so-called hourglass modes). The name \"hourglass modes\" comes from the fact that elements can deform into an hourglass shape.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Similar effects can occur in SPH as well. Particles can change positions without changing the SPH approximation of the deformation gradient bmF, thus, without causing an increase of energy. To ensure regular particle positions, we can apply similar correction forces as are used in FEM.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Ganzenmüller (2015) introduced a so-called hourglass correction force or penalty force f^PF, which is given by","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmf_a^PF = frac12 alpha sum_b fracm_0a m_0b W_0abrho_0arho_0b bmX_ab^2\n                left( E delta_ab^a + E delta_ba^b right) fracbmx_abbmx_ab","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The subscripts a and b denote quantities of particle a and b, respectively. The zero subscript on quantities denotes that the quantity is to be measured in the initial configuration. The difference in the initial coordinates is denoted by bmX_ab = bmX_a - bmX_b, the difference in the current coordinates is denoted by bmx_ab = bmx_a - bmx_b. Note that Ganzenmüller (2015) has a flipped sign here because they define bmx_ab the other way around.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"This correction force is based on the potential energy density of a Hookean material. Thus, E is the Young's modulus and alpha is a dimensionless coefficient that controls the amplitude of hourglass correction. The separation vector delta_ab^a indicates the change of distance which the particle separation should attain in order to minimize the error and is given by","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"    delta_ab^a = fracbmepsilon_ab^a cdot bmx_abbmx_ab","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"where the error vector is defined as","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"    bmepsilon_ab^a = bmF_a bmX_ab - bmx_ab","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"schemes\", \"solid\", \"total_lagrangian_sph\", \"penalty_force.jl\")]","category":"page"},{"location":"systems/total_lagrangian_sph/#TrixiParticles.PenaltyForceGanzenmueller","page":"Total Lagrangian SPH (Elastic Structure)","title":"TrixiParticles.PenaltyForceGanzenmueller","text":"PenaltyForceGanzenmueller(; alpha=0.1)\n\nPenalty force to ensure regular particle positions under large deformations.\n\nKeywords\n\nalpha: Coefficient to control the amplitude of hourglass correction.\n\n\n\n\n\n","category":"type"},{"location":"systems/total_lagrangian_sph/#References-2","page":"Total Lagrangian SPH (Elastic Structure)","title":"References","text":"","category":"section"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Georg C. Ganzenmüller. \"An hourglass control algorithm for Lagrangian Smooth Particle Hydrodynamics\". In: Computer Methods in Applied Mechanics and Engineering 286 (2015). doi: 10.1016/j.cma.2014.12.005","category":"page"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/trixi-framework/TrixiParticles.jl/blob/main/LICENSE.md\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2023-present The TrixiParticles.jl Authors (see Authors) \nCopyright (c) 2023-present Helmholtz-Zentrum hereon GmbH, Institute of Surface Science \n \nPermission is hereby granted, free of charge, to any person obtaining a copy   of this software and associated documentation files (the \"Software\"), to deal   in the Software without restriction, including without limitation the rights   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell   copies of the Software, and to permit persons to whom the Software is   furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all   copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you have not installed TrixiParticles.jl, please follow the instructions given here.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In the following sections, we will give a short introduction. For a more thorough discussion, take a look at our Tutorials.","category":"page"},{"location":"getting_started/#Running-an-Example","page":"Getting started","title":"Running an Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The easiest way to run a simulation is to run one of our predefined example files. We will run the file examples/fluid/hydrostatic_water_column_2d.jl, which simulates a fluid resting in a rectangular tank. Since TrixiParticles.jl uses multithreading, you should start Julia with the flag --threads auto (or, e.g. --threads 4 for 4 threads).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In the Julia REPL, first load the package TrixiParticles.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> using TrixiParticles","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Then start the simulation by executing","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> trixi_include(joinpath(examples_dir(), \"fluid\", \"hydrostatic_water_column_2d.jl\"))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This will result in the following: (Image: image)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To visualize the results, see Visualization.","category":"page"},{"location":"getting_started/#Running-other-Examples","page":"Getting started","title":"Running other Examples","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You can find a list of our other predefined examples under Examples. Execute them as follows from the Julia REPL by replacing subfolder and example_name","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> trixi_include(joinpath(examples_dir(), \"subfolder\", \"example_name.jl\"))","category":"page"},{"location":"getting_started/#Modifying-an-example","page":"Getting started","title":"Modifying an example","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You can pass keyword arguments to the function trixi_include to overwrite assignments in the file.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"With trixi_include, we can overwrite variables defined in the example file to run a different simulation without modifying the example file.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> trixi_include(joinpath(examples_dir(), \"fluid\", \"hydrostatic_water_column_2d.jl\"), initial_fluid_size=(1.0, 0.5))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This for example, will change the fluid size from (09 10) to (10 05).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To understand why, take a look into the file hydrostatic_water_column_2d.jl in the subfolder fluid inside the examples directory, which is the file that we executed earlier. You can see that the initial size of the fluid is defined in the variable initial_fluid_size, which we could overwrite with the trixi_include call above. Another variable that is worth experimenting with is fluid_particle_spacing, which controls the resolution of the simulation in this case. A lower value will increase the resolution and the runtime.","category":"page"},{"location":"getting_started/#Set-up-you-first-simulation-from-scratch","page":"Getting started","title":"Set up you first simulation from scratch","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"See Set up your first simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Find an overview over the available tutorials under Tutorials.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Fluid","page":"Examples","title":"Fluid","text":"","category":"section"},{"location":"examples/#Structure-Mechanics","page":"Examples","title":"Structure Mechanics","text":"","category":"section"},{"location":"examples/#Fluid-Structure-Interaction","page":"Examples","title":"Fluid Structure Interaction","text":"","category":"section"},{"location":"examples/#Postprocessing","page":"Examples","title":"Postprocessing","text":"","category":"section"},{"location":"callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"Modules = [TrixiParticles]\nPages = map(file -> joinpath(\"callbacks\", file), readdir(joinpath(\"..\", \"src\", \"callbacks\")))","category":"page"},{"location":"callbacks/#TrixiParticles.DensityReinitializationCallback","page":"Callbacks","title":"TrixiParticles.DensityReinitializationCallback","text":"DensityReinitializationCallback(; interval::Integer=0, dt=0.0)\n\nCallback to reinitialize the density field when using ContinuityDensity.\n\nKeywords\n\ninterval=0:              Reinitialize the density every interval time steps.\ndt:                      Reinitialize the density in regular intervals of dt in terms                            of integration time.\nreinit_initial_solution: Reinitialize the initial solution (default=false)\n\nReferences\n\nPanizzo, Andrea, Giovanni Cuomo, and Robert A. Dalrymple. \"3D-SPH simulation of landslide generated waves.\" In: Coastal Engineering 2006 (2007), pages 1503-1515. doi: 10.1142/9789812709554_0128\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#TrixiParticles.InfoCallback-Tuple{}","page":"Callbacks","title":"TrixiParticles.InfoCallback","text":"InfoCallback()\n\nCreate and return a callback that prints a human-readable summary of the simulation setup at the beginning of a simulation and then resets the timer. When the returned callback is executed directly, the current timer values are shown.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.PostprocessCallback","page":"Callbacks","title":"TrixiParticles.PostprocessCallback","text":"PostprocessCallback(; interval::Integer=0, dt=0.0, exclude_boundary=true, filename=\"values\",\n                    output_directory=\"out\", append_timestamp=false, write_csv=true,\n                    write_json=true, write_file_interval=1, funcs...)\n\nCreate a callback to post-process simulation data at regular intervals. This callback allows for the execution of a user-defined function func at specified intervals during the simulation. The function is applied to the current state of the simulation, and its results can be saved or used for further analysis. The provided function cannot be anonymous as the function name will be used as part of the name of the value.\n\nThe callback can be triggered either by a fixed number of time steps (interval) or by a fixed interval of simulation time (dt).\n\nKeywords\n\nfuncs...: Functions to be executed at specified intervals during the simulation.             The functions must have the arguments (v, u, t, system).\ninterval=0: Specifies the number of time steps between each invocation of the callback.               If set to 0, the callback will not be triggered based on time steps.               Either interval or dt must be set to something larger than 0.\ndt=0.0: Specifies the simulation time interval between each invocation of the callback.           If set to 0.0, the callback will not be triggered based on simulation time.           Either interval or dt must be set to something larger than 0.\nexclude_boundary=true: If set to true, boundary particles will be excluded from the post-processing.\nfilename=\"values\": The filename of the postprocessing files to be saved.\noutput_directory=\"out\": The path where the results of the post-processing will be saved.\nwrite_csv=true: If set to true, write a csv file.\nwrite_json=true: If set to true, write a json file.\nappend_timestep=false: If set to true, the current timestamp will be added to the filename.\nwrite_file_interval=1: Files will be written after every write_file_interval number of                          postprocessing execution steps. A value of 0 indicates that files                          are only written at the end of the simulation, eliminating I/O overhead.\n\nExamples\n\nfunction example_function(v, u, t, system)\n    println(\"test_func \", t)\nend\n\n# Create a callback that is triggered every 100 time steps\npostprocess_callback = PostprocessCallback(interval=100, example_quantity=example_function)\n\n# Create a callback that is triggered every 0.1 simulation time units\npostprocess_callback = PostprocessCallback(dt=0.1, example_quantity=example_function)\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#TrixiParticles.SolutionSavingCallback","page":"Callbacks","title":"TrixiParticles.SolutionSavingCallback","text":"SolutionSavingCallback(; interval::Integer=0, dt=0.0,\n                       save_initial_solution=true,\n                       save_final_solution=true,\n                       output_directory=\"out\", append_timestamp=false, max_coordinates=2^15,\n                       custom_quantities...)\n\nCallback to save the current numerical solution in VTK format in regular intervals. Either pass interval to save every interval time steps, or pass dt to save in intervals of dt in terms of integration time by adding additional tstops (note that this may change the solution).\n\nAdditional user-defined quantities can be saved by passing functions as keyword arguments, which map (v, u, t, system) to an Array where the columns represent the particles in the same order as in u. To ignore a custom quantity for a specific system, return nothing.\n\nKeywords\n\ninterval=0:                 Save the solution every interval time steps.\ndt:                         Save the solution in regular intervals of dt in terms                               of integration time by adding additional tstops                               (note that this may change the solution).\nsave_initial_solution=true: Save the initial solution.\nsave_final_solution=true:   Save the final solution.\noutput_directory=\"out\":     Directory to save the VTK files.\nappend_timestamp=false:     Append current timestamp to the output directory.\n'prefix':                     Prefix added to the filename.\ncustom_quantities...:       Additional user-defined quantities.\nwrite_meta_data:            Write meta data.\nverbose=false:              Print to standard IO when a file is written.\nmax_coordinates=2^15        The coordinates of particles will be clipped if their absolute values exceed this threshold.\n\nExamples\n\n# Save every 100 time steps.\nsaving_callback = SolutionSavingCallback(interval=100)\n\n# Save in intervals of 0.1 in terms of simulation time.\nsaving_callback = SolutionSavingCallback(dt=0.1)\n\n# Additionally store the norm of the particle velocity for fluid systems as \"v_mag\".\nusing LinearAlgebra\nfunction v_mag(v, u, t, system)\n    # Ignore for other systems.\n    return nothing\nend\nfunction v_mag(v, u, t, system::WeaklyCompressibleSPHSystem)\n    return [norm(v[1:ndims(system), i]) for i in axes(v, 2)]\nend\nsaving_callback = SolutionSavingCallback(dt=0.1, v_mag=v_mag)\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#TrixiParticles.StepsizeCallback-Tuple{}","page":"Callbacks","title":"TrixiParticles.StepsizeCallback","text":"StepsizeCallback(; cfl::Real)\n\nSet the time step size according to a CFL condition if the time integration method isn't adaptive itself.\n\nThe current implementation is using the simplest form of CFL condition, which chooses a time step size that is constant during the simulation. The step size is therefore only applied once at the beginning of the simulation.\n\nThe step size Delta t is chosen as the minimum\n\n    Delta t = min(Delta t_eta Delta t_a Delta t_c)\n\nwhere\n\n    Delta t_eta = 0125  h^2  eta quad Delta t_a = 025 sqrth  lVert g rVert\n    quad Delta t_c = textCFL  h  c\n\nwith nu = alpha h c  (2n + 4), where alpha is the parameter of the viscosity and n is the number of dimensions.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nReferences\n\nM. Antuono, A. Colagrossi, S. Marrone. \"Numerical Diffusive Terms in Weakly-Compressible SPH Schemes.\" In: Computer Physics Communications 183, no. 12 (2012), pages 2570–80. doi: 10.1016/j.cpc.2012.07.006\nS. Adami, X. Y. Hu, N. A. Adams. \"A generalized wall boundary condition for smoothed particle hydrodynamics\". In: Journal of Computational Physics 231, 21 (2012), pages 7057–7075. doi: 10.1016/J.JCP.2012.05.005\nP. N. Sun, A. Colagrossi, S. Marrone, A. M. Zhang. \"The δplus-SPH Model: Simple Procedures for a Further Improvement of the SPH Scheme.\" In: Computer Methods in Applied Mechanics and Engineering 315 (2017), pages 25–49. doi: 10.1016/j.cma.2016.10.028\nM. Antuono, S. Marrone, A. Colagrossi, B. Bouscasse. \"Energy Balance in the δ-SPH Scheme.\" In: Computer Methods in Applied Mechanics and Engineering 289 (2015), pages 209–26. doi: 10.1016/j.cma.2015.02.004\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"general/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [TrixiParticles]\nPages = [joinpath(\"general\", \"interpolation.jl\")]","category":"page"},{"location":"general/interpolation/#TrixiParticles.interpolate_line-NTuple{6, Any}","page":"Interpolation","title":"TrixiParticles.interpolate_line","text":"interpolate_line(start, end_, n_points, semi, ref_system, sol; endpoint=true,\n                 smoothing_length=ref_system.smoothing_length, cut_off_bnd=true)\n\nInterpolates properties along a line in a TrixiParticles simulation. The line interpolation is accomplished by generating a series of evenly spaced points between start and end_. If endpoint is false, the line is interpolated between the start and end points, but does not include these points.\n\nSee also: interpolate_point, interpolate_plane_2d,           interpolate_plane_2d_vtk, interpolate_plane_3d.\n\nArguments\n\nstart:      The starting point of the line.\nend_:       The ending point of the line.\nn_points:   The number of points to interpolate along the line.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nendpoint=true: A boolean to include (true) or exclude (false) the end point in the interpolation.\nsmoothing_length=ref_system.smoothing_length: The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\n\nReturns\n\nA NamedTuple of arrays containing interpolated properties at each point along the line.\n\nnote: Note\nThis function is particularly useful for analyzing gradients or creating visualizations along a specified line in the SPH simulation domain.\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating along a line from [1.0, 0.0] to [1.0, 1.0] with 5 points\nresults = interpolate_line([1.0, 0.0], [1.0, 1.0], 5, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_plane_2d-NTuple{6, Any}","page":"Interpolation","title":"TrixiParticles.interpolate_plane_2d","text":"interpolate_plane_2d(min_corner, max_corner, resolution, semi, ref_system, sol;\n                     smoothing_length=ref_system.smoothing_length, cut_off_bnd=true)\n\nInterpolates properties along a plane in a TrixiParticles simulation. The region for interpolation is defined by its lower left and top right corners, with a specified resolution determining the density of the interpolation points.\n\nThe function generates a grid of points within the defined region, spaced uniformly according to the given resolution.\n\nSee also: interpolate_plane_2d_vtk, interpolate_plane_3d,           interpolate_line, interpolate_point.\n\nArguments\n\nmin_corner: The lower left corner of the interpolation region.\nmax_corner: The top right corner of the interpolation region.\nresolution: The distance between adjacent interpolation points in the grid.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nsmoothing_length=ref_system.smoothing_length: The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\n\nReturns\n\nA NamedTuple of arrays containing interpolated properties at each point within the plane.\n\nnote: Note\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used, which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating across a plane from [0.0, 0.0] to [1.0, 1.0] with a resolution of 0.2\nresults = interpolate_plane_2d([0.0, 0.0], [1.0, 1.0], 0.2, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_plane_2d_vtk-NTuple{6, Any}","page":"Interpolation","title":"TrixiParticles.interpolate_plane_2d_vtk","text":"interpolate_plane_2d_vtk(min_corner, max_corner, resolution, semi, ref_system, sol;\n                         smoothing_length=ref_system.smoothing_length, cut_off_bnd=true,\n                         output_directory=\"out\", filename=\"plane\")\n\nInterpolates properties along a plane in a TrixiParticles simulation and exports the result as a VTI file. The region for interpolation is defined by its lower left and top right corners, with a specified resolution determining the density of the interpolation points.\n\nThe function generates a grid of points within the defined region, spaced uniformly according to the given resolution.\n\nSee also: interpolate_plane_2d, interpolate_plane_3d,           interpolate_line, interpolate_point.\n\nArguments\n\nmin_corner: The lower left corner of the interpolation region.\nmax_corner: The top right corner of the interpolation region.\nresolution: The distance between adjacent interpolation points in the grid.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nsmoothing_length=ref_system.smoothing_length: The smoothing length used in the interpolation.\noutput_directory=\"out\": Directory to save the VTI file.\nfilename=\"plane\":       Name of the VTI file.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\n\nnote: Note\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used, which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating across a plane from [0.0, 0.0] to [1.0, 1.0] with a resolution of 0.2\nresults = interpolate_plane_2d([0.0, 0.0], [1.0, 1.0], 0.2, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_plane_3d-NTuple{7, Any}","page":"Interpolation","title":"TrixiParticles.interpolate_plane_3d","text":"interpolate_plane_3d(point1, point2, point3, resolution, semi, ref_system, sol;\n                     smoothing_length=ref_system.smoothing_length, cut_off_bnd=true)\n\nInterpolates properties along a plane in a 3D space in a TrixiParticles simulation. The plane for interpolation is defined by three points in 3D space, with a specified resolution determining the density of the interpolation points.\n\nThe function generates a grid of points on a parallelogram within the plane defined by the three points, spaced uniformly according to the given resolution.\n\nSee also: interpolate_plane_2d, interpolate_plane_2d_vtk,           interpolate_line, interpolate_point.\n\nArguments\n\npoint1:     The first point defining the plane.\npoint2:     The second point defining the plane.\npoint3:     The third point defining the plane. The points must not be collinear.\nresolution: The distance between adjacent interpolation points in the grid.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nsmoothing_length=ref_system.smoothing_length: The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\n\nReturns\n\nA NamedTuple of arrays containing interpolated properties at each point within the plane.\n\nnote: Note\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating across a plane defined by points [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], and [0.0, 1.0, 0.0]\n# with a resolution of 0.1\nresults = interpolate_plane_3d([0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], 0.1, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_point-Tuple{AbstractArray{<:AbstractArray}, Any, Any, Any}","page":"Interpolation","title":"TrixiParticles.interpolate_point","text":"interpolate_point(points_coords::Array{Array{Float64,1},1}, semi, ref_system, sol;\n                  smoothing_length=ref_system.smoothing_length, cut_off_bnd=true)\n\ninterpolate_point(point_coords, semi, ref_system, sol;\n                  smoothing_length=ref_system.smoothing_length, cut_off_bnd=true)\n\nPerforms interpolation of properties at specified points or an array of points in a TrixiParticles simulation.\n\nWhen given an array of points (points_coords), it iterates over each point and applies interpolation individually. For a single point (point_coords), it performs the interpolation at that specific location. The interpolation utilizes the same kernel function of the SPH simulation to weigh contributions from nearby particles.\n\nSee also: interpolate_line, interpolate_plane_2d,           interpolate_plane_2d_vtk, interpolate_plane_3d, .\n\nArguments\n\npoints_coords:  An array of point coordinates, for which to interpolate properties.\npoint_coords:   The coordinates of a single point for interpolation.\nsemi:           The semidiscretization used in the SPH simulation.\nref_system:     The reference system defining the properties of the SPH particles.\nsol:            The current solution state from which properties are interpolated.\n\nKeywords\n\nsmoothing_length=ref_system.smoothing_length: The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\n\nReturns\n\nFor multiple points:  A NamedTuple of arrays containing interpolated properties at each point.\nFor a single point: A NamedTuple of interpolated properties at the point.\n\nExamples\n\n# For a single point\nresult = interpolate_point([1.0, 0.5], semi, ref_system, sol)\n\n# For multiple points\npoints = [[1.0, 0.5], [1.0, 0.6], [1.0, 0.7]]\nresults = interpolate_point(points, semi, ref_system, sol)\n\nnote: Note\nThis function is particularly useful for analyzing gradients or creating visualizations along a specified line in the SPH simulation domain.\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used which is not asaccurate as a real surface reconstruction.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiParticles.jl","page":"Home","title":"TrixiParticles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiParticles.jl is a numerical simulation framework designed for particle-based numerical methods, with an emphasis on multiphysics applications, written in Julia. A primary goal of the framework is to be user-friendly for engineering, science, and educational purposes. In addition to its extensible design and optimized implementation, we prioritize the user experience, including installation, pre- and postprocessing. Its features include:","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Incompressible Navier-Stokes\nMethods: Weakly Compressible Smoothed Particle Hydrodynamics (WCSPH), Entropically Damped Artificial Compressibility (EDAC)\nSolid-body mechanics\nMethods: Total Lagrangian SPH (TLSPH)\nFluid-Structure Interaction\nOutput formats:\nVTK","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation\nGetting started","category":"page"},{"location":"#Start-with-development","page":"Home","title":"Start with development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation\nContributing","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Fluid","page":"Tutorial","title":"Fluid","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Setting up your simulation from scratch\nSetting up a dam break simulation","category":"page"},{"location":"tutorial/#Mechanics","page":"Tutorial","title":"Mechanics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Deforming a beam","category":"page"},{"location":"tutorial/#Fluid-Structure-Interaction","page":"Tutorial","title":"Fluid-Structure Interaction","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Setting up a falling structure","category":"page"}]
}
