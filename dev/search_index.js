var documenterSearchIndex = {"docs":
[{"location":"time_integration/#time_integration","page":"Time Integration","title":"Time integration","text":"","category":"section"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"TrixiParticles.jl uses a modular approach where time integration is just another module that can be customized and exchanged. The function semidiscretize returns an ODEProblem (see the OrdinaryDiffEq.jl docs), which can be integrated with OrdinaryDiffEq.jl.","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"In particular, a DynamicalODEProblem is returned, where the right-hand side is split into two functions, the kick!, which computes the derivative of the particle velocities and the drift!, which computes the derivative of the particle positions. This approach allows us to use specialized time integration methods that do not work with general ODEProblems. Note that this is not a true DynamicalODEProblem where the kick does not depend on the velocity. Therefore, not all integrators designed for DynamicalODEProblems will work (properly) (see below). However, all integrators designed for general ODEProblems can be used.","category":"page"},{"location":"time_integration/#Usage","page":"Time Integration","title":"Usage","text":"","category":"section"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"After obtaining an ODEProblem from semidiscretize, let us call it ode, we can pass it to the function solve of OrdinaryDiffEq.jl. For most schemes, we do the following:","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"using OrdinaryDiffEq\nsol = solve(ode, Euler(),\n            dt=1.0,\n            save_everystep=false, callback=callbacks);","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"Here, Euler() should in practice be replaced by a more useful scheme. callbacks should be a CallbackSet containing callbacks like the InfoCallback. For callbacks, please refer to the docs and the example files. In this case, we need to either set a reasonable, problem- and resolution-dependent step size dt, or use the StepsizeCallback, which overwrites the step size dynamically during the simulation based on a CFL-number. We always set save_everystep=false, or OrdinaryDiffEq.jl would return the solution vector for every time step, writing massive amounts of data into the RAM for large simulations. To visualize data for every time step, callbacks can be used.","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"Some schemes, e.g. the two schemes RDPK3SpFSAL35 and RDPK3SpFSAL49 mentioned below, support automatic time stepping, where the step size is determined automatically based on error estimates during the simulation. These schemes do not use the keyword argument dt and will ignore the step size set by the StepsizeCallback. Instead, they will work with the tolerances abstol and reltol, which can be passed as keyword arguments to solve. The default tolerances are abstol=1e-6 and reltol=1e-3.","category":"page"},{"location":"time_integration/#Recommended-schemes","page":"Time Integration","title":"Recommended schemes","text":"","category":"section"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"A list of schemes for general ODEProblems can be found here. We commonly use the following three schemes:","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"CarpenterKennedy2N54(williamson_condition=false): A five-stage, fourth order low-storage Runge-Kutta method designed by Carpenter and Kennedy for hyperbolic problems.\nRDPK3SpFSAL35(): A 5-stage, third order low-storage Runge-Kutta scheme with embedded error estimator, optimized for compressible fluid mechanics [52].\nRDPK3SpFSAL49(): A 9-stage, fourth order low-storage Runge-Kutta scheme with embedded error estimator, optimized for compressible fluid mechanics [52].","category":"page"},{"location":"time_integration/#symplectic_schemes","page":"Time Integration","title":"Symplectic schemes","text":"","category":"section"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"Symplectic schemes like the leapfrog method are often used for SPH.","category":"page"},{"location":"time_integration/#kick_drift_kick","page":"Time Integration","title":"Leapfrog kick-drift-kick","text":"","category":"section"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"The kick-drift-kick scheme of the leapfrog method, updating positions u and velocities v with the functions operatornamekick and operatornamedrift, reads:","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"beginalign*\nv^12 = v^0 + frac12 Delta t operatornamekick(u^0 t^0) \nu^1 = u^0 + Delta t operatornamedrift left( v^12 t^0 + frac12 Delta t right) \nv^1 = v^12 + frac12 Delta t operatornamekick(u^1 t^0 + Delta t)\nendalign*","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"In this form, it is also identical to the velocity Verlet scheme. Note that this only works as long as operatornamekick does not depend on v, i.e., in the inviscid case. Once we add viscosity, operatornamekick depends on both u and v. Then, the calculation of v^1 requires v^1 and becomes implicit.","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"The way this scheme is implemented in OrdinaryDiffEq.jl as VerletLeapfrog, the intermediate velocity v^12 is passed to operatornamekick in the last stage, resulting in first-order convergence when the scheme is used in the viscid case.","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"warning: Warning\nPlease do not use VelocityVerlet and VerletLeapfrog with TrixiParticles.jl. They will require very small time steps due to first-order convergence in the viscid case.","category":"page"},{"location":"time_integration/#Leapfrog-drift-kick-drift","page":"Time Integration","title":"Leapfrog drift-kick-drift","text":"","category":"section"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"The drift-kick-drift scheme of the leapfrog method reads:","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"beginalign*\nu^12 = u^0 + frac12 Delta t operatornamedrift(v^0 t^0) \nv^1 = v^0 + Delta t operatornamekick left( u^12 t^0 + frac12 Delta t right) \nu^1 = u^12 + frac12 Delta t operatornamedrift(v^1 t^0 + Delta t)\nendalign*","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"In the viscid case where operatornamekick depends on v, we can add another half step for v, yielding","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"beginalign*\nu^12 = u^0 + frac12 Delta t operatornamedrift(v^0 u^0 t^0) \nv^12 = v^0 + frac12 Delta t operatornamekick(v^0 u^0 t^0) \nv^1 = v^0 + Delta t operatornamekick left( v^12 u^12 t^0 + frac12 Delta t right) \nu^1 = u^12 + frac12 Delta t operatornamedrift(v^1 u^1 t^0 + Delta t)\nendalign*","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"This scheme is implemented in OrdinaryDiffEq.jl as LeapfrogDriftKickDrift and yields the desired second order as long as operatornamedrift does not depend on u, which is always the case.","category":"page"},{"location":"time_integration/#Symplectic-position-Verlet","page":"Time Integration","title":"Symplectic position Verlet","text":"","category":"section"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"When the density is integrated (with ContinuityDensity), the density is appended to v as an additional dimension, so all previously mentioned schemes treat the density similar to the velocity. The SPH code DualSPHysics implements a variation of the drift-kick-drift scheme where the density is updated separately. See Domínguez et al. 2022, Section 2.5.2. In the following, we will call the derivative of the density R(v u t), even though it is actually included in the operatornamekick as an additional dimension.","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"This scheme reads","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"beginalign*\nu^12 = u^0 + frac12 Delta t operatornamedrift(v^0 u^0 t^0) \nv^12 = v^0 + frac12 Delta t operatornamekick(v^0 u^0 t^0) \nrho^12 = rho^0 + frac12 Delta t R(v^0 u^0 t^0) \nv^1 = v^0 + Delta t operatornamekick left( v^12 u^12 t^0 + frac12 Delta t right) \nrho^1 = rho^0 frac2 - varepsilon^122 + varepsilon^12 \nu^1 = u^12 + frac12 Delta t operatornamedrift(v^1 u^1 t^0 + Delta t)\nendalign*","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"where","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"varepsilon^12 = - fracR(v^12 u^12 t^0 + frac12 Delta t)rho^12 Delta t","category":"page"},{"location":"time_integration/","page":"Time Integration","title":"Time Integration","text":"This scheme is implemented in TrixiParticles.jl as SymplecticPositionVerlet.","category":"page"},{"location":"time_integration/#TrixiParticles.SymplecticPositionVerlet","page":"Time Integration","title":"TrixiParticles.SymplecticPositionVerlet","text":"SymplecticPositionVerlet()\n\nModified leapfrog integration scheme for Weakly Compressible SPH (WCSPH) when integrating the density with ContinuityDensity. This scheme is used by the SPH code DualSPHysics. See https://github.com/DualSPHysics/DualSPHysics/wiki/3.-SPH-formulation#372-symplectic-position-verlet-scheme and Domínguez et al. 2022, Section 2.5.2.\n\nSee time integration for more details.\n\n\n\n\n\n","category":"function"},{"location":"references/","page":"References","title":"References","text":"K. Hormann and A. Agathos. The point in polygon problem for arbitrary polygons. Computational Geometry 20, 131–144 (2001).\n\n\n\nA. Jacobson, L. Kavan and O. Sorkine-Hornung. Robust inside-outside segmentation using generalized winding numbers. ACM Transactions on Graphics 32, 1–12 (2013).\n\n\n\nY. Zhu, C. Zhang, Y. Yu and X. Hu. A CAD-compatible body-fitted particle generator for arbitrarily complex geometry and its application to wave-structure interaction. Journal of Hydrodynamics 33, 195–206 (2021).\n\n\n\nM. Müller, D. Charypar and M. Gross. Particle-Based Fluid Simulation for Interactive Applications. In: Proceedings of the 2003 ACM SIGGRAPH/Eurographics Symposium on Computer Animation (Eurographics Association, 07 2003); pp. 154–159.\n\n\n\nI. J. Schoenberg. Contributions to the problem of approximation of equidistant data by analytic functions. Part B. On the problem of osculatory interpolation. A second class of analytic approximation formulae. Quarterly of Applied Mathematics 4, 112–141 (1946).\n\n\n\nD. J. Price. Smoothed particle hydrodynamics and magnetohydrodynamics. Journal of Computational Physics 231, 759–794 (2012).\n\n\n\nJ. Monaghan. Particle methods for hydrodynamics. Computer Physics Reports 3, 71–124 (1985).\n\n\n\nH. Wendland. Piecewise polynomial, positive definite and compactly supported radial functions of minimal degree. Advances in Computational Mathematics 4, 389–396 (1995).\n\n\n\nW. Dehnen and H. Aly. Improving convergence in smoothed particle hydrodynamics simulations without pairing instability: SPH without pairing instability. Monthly Notices of the Royal Astronomical Society 425, 1068–1082 (2012).\n\n\n\nJ. J. Monaghan. Smoothed Particle Hydrodynamics. Annual Review of Astronomy and Astrophysics 30, 543–574 (1992).\n\n\n\nJ. Monaghan. On the problem of penetration in particle methods. Journal of Computational Physics 82, 1–15 (1989).\n\n\n\nD. S. Balsara, von Neumann stability analysis of smoothed particle hydrodynamics—suggestions for optimal algorithms. Journal of Computational Physics 121, 357–372 (1995).\n\n\n\nJ. P. Morris, P. J. Fox and Y. Zhu. Modeling Low Reynolds Number Incompressible Flows Using SPH. Journal of Computational Physics 136, 214–226 (1997).\n\n\n\nG. Fourtakas, J. M. Dominguez, R. Vacondio and B. D. Rogers. Local uniform stencil (LUST) boundary condition for arbitrary 3-D boundaries in parallel smoothed particle hydrodynamics (SPH) models. Computers & Fluids 190, 346–361 (2019).\n\n\n\nS. Adami, X. Hu and N. Adams. A generalized wall boundary condition for smoothed particle hydrodynamics. Journal of Computational Physics 231, 7057–7075 (2012).\n\n\n\nP. Ramachandran and K. Puri. Entropically damped artificial compressibility for SPH. Computers & Fluids 179, 579–594 (2019).\n\n\n\nJ. Smagorinsky. General Circulation Experiments with the Primitive Equations. I. The Basic Experiment. Monthly Weather Review 91, 99–164 (1963).\n\n\n\nN. Akinci, G. Akinci and M. Teschner. Versatile surface tension and adhesion for SPH fluids. ACM Transactions on Graphics 32, 1–8 (2013).\n\n\n\nJ. Bonet and T.-S. Lok. Variational and momentum preservation aspects of Smooth Particle Hydrodynamic formulations. Computer Methods in Applied Mechanics and Engineering 180, 97–115 (1999).\n\n\n\nM. Basa, N. J. Quinlan and M. Lastiwka. Robustness and accuracy of SPH formulations for viscous flow. International Journal for Numerical Methods in Fluids 60, 1127–1148 (2008).\n\n\n\nS. Li and W. K. Liu. Moving least-square reproducing kernel method Part II: Fourier analysis. Computer Methods in Applied Mechanics and Engineering 139, 159–193 (1996).\n\n\n\nB. E. Poling, J. M. Prausnitz and J. P. O'Connell. The Properties of Gases and Liquids (McGraw-Hill, New York, 2001).\n\n\n\nLange's Handbook of Chemistry. Lange's Handbook of Chemistry. 16th Edition (McGraw-Hill, 2005).\n\n\n\nY. H. Hui. Encyclopedia of Food Science and Technology (Academic Press, London, 1992).\n\n\n\nE. A. Melo-Espinosa, Y. Sánchez-Borroto, M. Errasti and A. C. Hansen. Surface Tension Prediction of Vegetable Oils Using Artificial Neural Networks and Multiple Linear Regression. Energy Conversion and Management 84, 50–60 (2014).\n\n\n\nJ. P. Morris. Simulating surface tension with smoothed particle hydrodynamics. International Journal for Numerical Methods in Fluids 33, 333–353 (2000).\n\n\n\nJ. Monaghan. Simulating Free Surface Flows with SPH. Journal of Computational Physics 110, 399–406 (1994).\n\n\n\nR. H. Cole and R. Weller. Underwater Explosions. Physics Today 1, 35–35 (1948).\n\n\n\nM. Antuono, A. Colagrossi and S. Marrone. Numerical diffusive terms in weakly-compressible SPH schemes. Computer Physics Communications 183, 2570–2580 (2012).\n\n\n\nM. Antuono, A. Colagrossi, S. Marrone and D. Molteni. Free-surface flows solved by means of SPH schemes with numerical diffusive terms. Computer Physics Communications 181, 532–549 (2010).\n\n\n\nD. Molteni and A. Colagrossi. A simple procedure to improve the pressure evaluation in hydrodynamic context using the SPH. Computer Physics Communications 180, 861–872 (2009).\n\n\n\nA. Ferrari, M. Dumbser, E. F. Toro and A. Armanini. A new 3D parallel SPH scheme for free surface flows. Computers & Fluids 38, 1203–1217 (2009).\n\n\n\nP. N. Sun, A. Colagrossi, S. Marrone, M. Antuono and A. M. Zhang. Multi-resolution Delta-plus-SPH with tensile instability control: Towards high Reynolds number flows. Computer Physics Communications 224, 63–80 (2018).\n\n\n\nJ. R. Clausen. Entropically damped form of artificial compressibility for explicit simulation of incompressible flow. Physical Review E 87, 013309 (2013).\n\n\n\nS. Adami, X. Hu and N. Adams. A transport-velocity formulation for smoothed particle hydrodynamics. Journal of Computational Physics 241, 292–307 (2013).\n\n\n\nN. Bićanić. Discrete Element Methods. In: Discrete Element Methods (Wiley, 2004).\n\n\n\nP. A. Cundall and O. D. Strack. A discrete numerical model for granular assemblies. Géotechnique 29, 47–65 (1979).\n\n\n\nA. Di Renzo and F. P. Di Maio. Comparison of contact-force models for the simulation of collisions in DEM-based granular flow codes. Chemical Engineering Science 59, 525–541 (2004).\n\n\n\nJ. O’Connor and B. D. Rogers. A fluid–structure interaction model for free-surface flows and flexible structures using smoothed particle hydrodynamics on a GPU. Journal of Fluids and Structures 104, 103312 (2021).\n\n\n\nT. Belytschko, Y. Guo, W. K. Liu and S. P. Xiao. A unified stability analysis of meshless particle methods. International Journal for Numerical Methods in Engineering 48, 1359–1400 (2000).\n\n\n\nG. C. Ganzenmüller. An hourglass control algorithm for Lagrangian Smooth Particle Hydrodynamics. Computer Methods in Applied Mechanics and Engineering 286, 87–106 (2015).\n\n\n\nA. Valizadeh and J. J. Monaghan. A study of solid wall models for weakly compressible SPH. Journal of Computational Physics 300, 5–19 (2015).\n\n\n\nN. Akinci, M. Ihmsen, G. Akinci, B. Solenthaler and M. Teschner. Versatile rigid-fluid coupling for incompressible SPH. ACM Transactions on Graphics 31, 1–8 (2012).\n\n\n\nA. J. Crespo, M. Gomez-Gesteira and R. A. Dalrymple. Boundary Conditions Generated by Dynamic Particles in SPH Methods. Computers, Materials and Continua 5, 173–184 (2007).\n\n\n\nS. Band, C. Gissler, A. Peer and M. Teschner. MLS pressure boundaries for divergence-free and viscous SPH fluids. Computers & Graphics 76, 37–46 (2018).\n\n\n\nJ. Monaghan and J. Kajtar. SPH particle boundary forces for arbitrary boundaries. Computer Physics Communications 180, 1811–1820 (2009).\n\n\n\nM. B. Giles. Nonreflecting boundary conditions for Euler equation calculations. AIAA Journal 28, 2050–2058 (1990).\n\n\n\nM. Lastiwka, M. Basa and N. J. Quinlan. Permeable and non‐reflecting boundary conditions in SPH. International Journal for Numerical Methods in Fluids 61, 709–724 (2008).\n\n\n\nP. Negi, P. Ramachandran and A. Haftu. An improved non-reflecting outlet boundary condition for weakly-compressible SPH. Computer Methods in Applied Mechanics and Engineering 367, 113119 (2020).\n\n\n\nA. Tafuni, J. Domı́nguez, R. Vacondio and A. Crespo. A versatile algorithm for the treatment of open boundary conditions in Smoothed particle hydrodynamics GPU models. Computer Methods in Applied Mechanics and Engineering 342, 604–624 (2018).\n\n\n\nM. H. Carpenter and C. A. Kennedy. Fourth Order 2N-storage Runge-Kutta Schemes (1994).\n\n\n\nH. Ranocha, L. Dalcin, M. Parsani and D. I. Ketcheson. Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics. Communications on Applied Mathematics and Computation 4, 1191–1228 (2022).\n\n\n\nJ. M. Domínguez, G. Fourtakas and others. DualSPHysics: from fluid dynamics to multiphysics problems. Computational Particle Mechanics 9, 867–895 (2022).\n\n\n\nA. Panizzo, G. Cuomo and R. A. Dalrymple. 3D-SPH SIMULATION OF LANDSLIDE GENERATED WAVES. In: Coastal Engineering 2006 (World Scientific Publishing Company, Apr 2007).\n\n\n\nP. Sun, A. Colagrossi, S. Marrone and A. Zhang. Delta-SPH model: Simple procedures for a further improvement of the SPH scheme. Computer Methods in Applied Mechanics and Engineering 315, 25–49 (2017).\n\n\n\nM. Antuono, S. Marrone, A. Colagrossi and B. Bouscasse. Energy balance in the Delta-SPH scheme. Computer Methods in Applied Mechanics and Engineering 289, 209–226 (2015).\n\n\n\n","category":"page"},{"location":"preprocessing/preprocessing/#sampling_of_geometries","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Generating the initial configuration of a simulation requires filling volumes (3D) or surfaces (2D) of complex geometries with particles. The algorithm to sample a complex geometry should be robust and fast, since for large problems (large numbers of particles) or complex geometries (many geometry faces), generating the initial configuration is not trivial and can be very expensive in terms of computational cost. We therefore use a winding number approach for an inside-outside segmentation of an object. The winding number w(mathbfp) is a signed integer-valued function of a point mathbfp and is defined as","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"w(mathbfp) = frac12 pi sum^n_i=1 Theta_i","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Here, Theta_i is the signed angle between mathbfc_i - mathbfp and mathbfc_i+1 - mathbfp where mathbfc_i and mathbfc_i+1 are two consecutive vertices on a curve. In 3D, we refer to the solid angle of an oriented triangle with respect to mathbfp.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"We provide the following methods to calculate w(mathbfp):","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Hormann et al. (2001) evaluate the winding number combined with an even-odd rule, but only for 2D polygons (see WindingNumberHormann).\nNaive winding: Jacobson et al. (2013) generalized the winding number so that the algorithm can be applied for both 2D and 3D geometries (see WindingNumberJacobson).\nHierarchical winding: Jacobson et al. (2013) also introduced a fast hierarchical evaluation of the winding number. For further information see the description below.","category":"page"},{"location":"preprocessing/preprocessing/#hierarchical_winding","page":"Sampling of Geometries","title":"Hierarchical Winding","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"According to Jacobson et al. (2013) the winding number with respect to a polygon (2D) or triangle mesh (3D) is the sum of the winding numbers with respect to each edge (2D) or face (3D). We can show this with the following example in which we determine the winding number for each edge of a triangle separately and sum them up:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"using TrixiParticles\nusing Plots\n\ntriangle = [125.0 375.0 250.0 125.0;\n            175.0 175.0 350.0 175.0]\n\n# Delete all edges but one\nedge1 = deleteat!(TrixiParticles.Polygon(triangle), [2, 3])\nedge2 = deleteat!(TrixiParticles.Polygon(triangle), [1, 3])\nedge3 = deleteat!(TrixiParticles.Polygon(triangle), [1, 2])\n\nalgorithm = WindingNumberJacobson()\n\ngrid = hcat(([x, y] for x in 1:500, y in 1:500)...)\n\n_, w1 = algorithm(edge1, grid; store_winding_number=true)\n_, w2 = algorithm(edge2, grid; store_winding_number=true)\n_, w3 = algorithm(edge3, grid; store_winding_number=true)\n\nw = w1 + w2 + w3\n\nheatmap(1:500, 1:500, reshape(w1, 500, 500)', color=:coolwarm, showaxis=false,\n        tickfontsize=12, size=(570, 500), margin=6 * Plots.mm)\nheatmap(1:500, 1:500, reshape(w2, 500, 500)', color=:coolwarm, showaxis=false,\n        tickfontsize=12, size=(570, 500), margin=6 * Plots.mm)\nheatmap(1:500, 1:500, reshape(w3, 500, 500)', color=:coolwarm, showaxis=false,\n        tickfontsize=12, size=(570, 500), margin=6 * Plots.mm)\nheatmap(1:500, 1:500, reshape(w, 500, 500)', color=:coolwarm, showaxis=false,\n        tickfontsize=12, size=(570, 500), margin=6 * Plots.mm, clims=(-1, 1))\n","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/bf491b2d-740e-4136-8a7b-e321f26f86fd\" alt=\"triangle\"/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"This summation property has some interesting consequences that we can utilize for an efficient computation of the winding number. Let mathcalS be an open surface and barmathcalS an arbitrary closing surface, such that","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"partial barmathcalS = partial mathcalS","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"and mathcalB = barmathcalS cup mathcalS is some closed oriented surface. For any query point mathbfp outside of mathcalB, we know that","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"w_mathcalS(mathbfp) + w_barmathcalS(mathbfp) = w_mathcalB(mathbfp) = 0","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"This means","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"w_mathcalS(mathbfp) = - w_barmathcalS(mathbfp)","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"regardless of how barmathcalS is constructed (as long as mathbfp is outside of mathcalB).","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"We can use this property in the discrete case to efficiently compute the winding number of a query point by partitioning the polygon or mesh in a \"small\" part (as in consisting of a small number of edges/faces) and a \"large\" part. For the small part we just compute the winding number, and for the large part we construct a small closing and compute its winding number. The partitioning is based on a hierarchical construction of bounding boxes.","category":"page"},{"location":"preprocessing/preprocessing/#Bounding-volume-hierarchy","page":"Sampling of Geometries","title":"Bounding volume hierarchy","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"To efficiently find a \"small part\" and a \"large part\" as mentioned above, we construct a hierarchy of bounding boxes by starting with the whole domain and recursively splitting it in two equally sized boxes. The resulting hierarchy is a binary tree.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"The algorithm by Jacobsen et al. (Algorithm 2, p. 5) traverses this binary tree recursively until we find the leaf in which the query point is located. The recursion stops with the following criteria:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"if the bounding box T is a leaf then TmathcalS = mathcalS cap T, the part of mathcalS that lies inside T, is the \"small part\" mentioned above, so evaluate the winding number naively as w(mathbfp TmathcalS).\nelse if mathbfp is outside T then TmathcalS is the \"large part\", so evaluate the winding number naively as -w(mathbfp TbarmathcalS), where TbarmathcalS is the closing surface of TmathcalS.","category":"page"},{"location":"preprocessing/preprocessing/#Continuous-example","page":"Sampling of Geometries","title":"Continuous example","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Now consider the following continuous (not discretized to a polygon) 2D example. We compute the winding number of the point mathbfp with respect to mathcalS using the depicted hierarchy of bounding boxes.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/0ca2f475-6dd5-43f9-8b0c-87a0612ecdf4\" alt=\"continuous closing\"/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(1):","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Recurse left: w_textleft = texttexttthierarchical_winding (mathbfp Ttextleft)\nRecurse right: w_textright = texttexttthierarchical_winding (mathbfpTtextright)","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(2):","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Query point mathbfp is outside bounding box T, so don't recurse deeper.\nCompute w_mathcalS(mathbfp) = - w_barmathcalS(mathbfp) with the closure TbarmathcalS, which is generally much smaller (fewer edges in the discrete version) than TmathcalS:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"w_textleft = -texttextttnaive_winding (mathbfp TbarmathcalS)","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(3):","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Bounding box T is a leaf. Use open surface TmathcalS:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"w_textright = texttextttnaive_winding (mathbfp TmathcalS)","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"The reconstructed surface will then look as in the following image.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/920bb4f1-1336-4e77-b06d-d5b46ca0d8d5\" alt=\"reconstructed surface\"/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"We finally sum up the winding numbers","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"w = w_textleft + w_textright  = -w_T_textleftbarmathcalS + w_T_textrightmathcalS","category":"page"},{"location":"preprocessing/preprocessing/#Discrete-example","page":"Sampling of Geometries","title":"Discrete example","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"We will now go through the discrete version of the example above.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/a9b59cc3-5421-40af-b0b0-f4c18a5a7078\" alt=\"discrete geometry\"/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"To construct the hierarchy for the discrete piecewise-linear example in (1), we have to do the following.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(2): Each edge is distributed to the child whose box contains the edge's barycenter (red dots in (2)). Splitting stops when the number of a box's edges slips below a threshold (usually approx 100 faces in 3D, here: 6 edges).","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(3): For the closure, Jacobson et al. (2013) define exterior vertices (exterior edges in 3D) as boundary vertices of such a segmentation (red dots in (3)). To find them, we traverse around each edge (face in 3D) in order, and increment or decrement for each vertex (edge) a specific counter.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"v1 = edge_vertices_ids[edge][1]\nv2 = edge_vertices_ids[edge][2]\n\nvertex_count[v1] += 1\nvertex_count[v2] -= 1","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"In 2D, a vertex is declared as exterior if vertex_count(vertex) != 0, so there is not the same amount of edges in this box going into versus out of the vertex. To construct the closing surface, the exterior vertices are then connected to one arbitrary exterior vertex using appropriately oriented line segments:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"edge = vertex_count[v] > 0 ? (closing_vertex, v) : (v, closing_vertex)","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"The resulting closed surface TS cup TbarS then has the same number of edges going into and out of each vertex.","category":"page"},{"location":"preprocessing/preprocessing/#Incorrect-evaluation","page":"Sampling of Geometries","title":"Incorrect evaluation","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"If we follow the algorithm, we know that recursion stops if","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"the bounding box T is a leaf or\nthe query point mathbfp is outside the box.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/7bae164a-8d5b-4761-9d54-9abf99fca94a\" alt=\"incorrect evaluation\"/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(1): The query point mathbfp is outside the box, so we calculate the winding number with the (red) closure of the box.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(2): The query point mathbfp is inside the box, so we use the (blue) edges distributed to the box.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"(3): In this case, it leads to an incorrect evaluation of the winding number. The query point is clearly inside the box, but not inside the reconstructed surface. This is because the property w_mathcalS(mathbfp) = - w_barmathcalS(mathbfp) only holds when mathbfp is outside of mathcalB, which is not the case here.","category":"page"},{"location":"preprocessing/preprocessing/#Correct-evaluation","page":"Sampling of Geometries","title":"Correct evaluation","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Jacobson et al. (2013) don't mention this problem or provide a solution to it. We contacted the authors and found that they know about this problem and solve it by resizing the bounding box to fully include the closing surface of the neighboring box, since it doesn't matter if the boxes overlap.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/097f01f4-1f37-48e4-968a-4c0970548b24\" alt=\"correct evaluation resizing\"/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"To avoid resizing, we take a different approach and calculate the closure of the bounding box differently:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Exclude intersecting edges in the calculation of the exterior vertices.\nThis way, all exterior vertices are inside the bounding box, and so will be the closing surface.\nThe intersecting edges are later added with flipped orientation, so that the closing is actually a closing of the exterior plus intersecting edges.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/a8ff9a7e-e6d6-44d1-9a29-7debddf2803d\" alt=\"correct evaluation intersecting\" width=60%/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"The evaluation then looks as follows.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<figure>\n  <img src=\"https://github.com/user-attachments/assets/9bb2d2ad-14e8-4bd0-a9bd-3c824932affd\" alt=\"correct evaluation intersecting 2\"/>\n</figure>","category":"page"},{"location":"preprocessing/preprocessing/#TrixiParticles.WindingNumberHormann","page":"Sampling of Geometries","title":"TrixiParticles.WindingNumberHormann","text":"WindingNumberHormann()\n\nAlgorithm for inside-outside segmentation of a complex geometry proposed by Hormann (2001). It is only supported for 2D geometries. WindingNumberHormann might handle edge cases a bit better, since the winding number is an integer value.\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in any future releases.\n\n\n\n\n\n","category":"type"},{"location":"preprocessing/preprocessing/#TrixiParticles.WindingNumberJacobson","page":"Sampling of Geometries","title":"TrixiParticles.WindingNumberJacobson","text":"WindingNumberJacobson(; geometry=nothing, winding_number_factor=sqrt(eps()),\n                      hierarchical_winding=false)\n\nAlgorithm for inside-outside segmentation of a complex geometry proposed by [2].\n\nKeywords\n\ngeometry: Complex geometry returned by load_geometry and is only required when using             hierarchical_winding=true.\nhierarchical_winding: If set to true, an optimized hierarchical approach will be used,                         which gives a significant speedup. For further information see Hierarchical Winding.\nwinding_number_factor: For leaky geometries, a factor of 0.4 will give a better inside-outside segmentation.\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in any future releases.\n\n\n\n\n\n","category":"type"},{"location":"preprocessing/preprocessing/#read_geometries_from_file","page":"Sampling of Geometries","title":"Read geometries from file","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Geometries can be imported using the load_geometry function.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"For 3D geometries, we support the binary (.stl) format.\nFor 2D geometries, the recommended format is DXF (.dxf), with optional support for a simple ASCII (.asc) format.","category":"page"},{"location":"preprocessing/preprocessing/#ASCII-Format-(.asc)","page":"Sampling of Geometries","title":"ASCII Format (.asc)","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"An .asc file contains a list of 2D coordinates, space-delimited, one point per line, where the first column are the x values and the second the y values. For example:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"# ASCII\n0.0 0.0\n1.0 0.0\n1.0 1.0\n0.0 1.0","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"It is the user’s responsibility to ensure the points are ordered correctly. This format is easy to generate and inspect manually.","category":"page"},{"location":"preprocessing/preprocessing/#DXF-Format-(.dxf)-–-recommended","page":"Sampling of Geometries","title":"DXF Format (.dxf) – recommended","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"The DXF (Drawing Exchange Format) is a widely-used CAD format for 2D and 3D data. We recommend this format for defining 2D polygonal. Only DXF entities of type LINE or POLYLINE are supported. To create DXF files from scratch, we recommend using the open-source tool FreeCAD. For a less technical approach, we recommend using Inkscape to create SVG files and then export them as DXF.","category":"page"},{"location":"preprocessing/preprocessing/#Creating-DXF-Files-with-FreeCAD","page":"Sampling of Geometries","title":"Creating DXF Files with FreeCAD","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Open FreeCAD and create a new document.\nSwitch to the Sketcher workbench and create a new sketch.\nChoose the XY-plane orientation and draw your geometry.\nSelect the object to be exported.\nGo to \"File > Export...\" and choose \"AutoDesk DXF (*.dxf)\" as the format.\nEnsure the following Import-Export options are enabled:\n\"Use legacy Python exporter\".\n\"Project exported objects along current view direction\".","category":"page"},{"location":"preprocessing/preprocessing/#Creating-DXF-Files-with-Inkscape","page":"Sampling of Geometries","title":"Creating DXF Files with Inkscape","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"SVG vector graphics can also be used as a basis for geometry. Use Inkscape to open or create the SVG. You can simply draw a Bezier curve by pressing \"B\" on your keyboard. We reommend the mode \"Create spiro paths\" for a smooth curve. Select the relevant path and export it as DXF:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Go to \"File > Save As...\".\nChoose \"Desktop Cutting Plotter (AutoCAD DXF R12)(*.dxf)\" format.","category":"page"},{"location":"preprocessing/preprocessing/#TrixiParticles.load_geometry-Tuple{Any}","page":"Sampling of Geometries","title":"TrixiParticles.load_geometry","text":"load_geometry(filename; element_type=Float64)\n\nLoad file and return corresponding type for ComplexShape. Supported file formats are .stl, .asc and dxf. For comprehensive information about the supported file formats, refer to the documentation at Read geometries from file.\n\nArguments\n\nfilename: Name of the file to be loaded.\n\nKeywords\n\nelement_type: Element type (default is Float64)\n\n\n\n\n\n","category":"method"},{"location":"preprocessing/preprocessing/#particle_packing","page":"Sampling of Geometries","title":"Particle Packing","text":"","category":"section"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"To obtain a body-fitted and isotropic particle distribution, an initial configuration (see Sampling of Geometries) is first generated. This configuration is then packed using a ParticlePackingSystem. The preprocessing pipeline consists of the following steps:","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"Load geometry: Fig. 1, load_geometry.\nCompute the signed distance field (SDF): Fig. 2, SignedDistanceField.\nGenerate boundary particles: Fig. 3, sample_boundary.\nInitial sampling of the interior particles with inside-outside segmentation: Fig. 4, ComplexShape.\nPack the initial configuration of interior and boundary particles (Fig. 5): Fig. 6, ParticlePackingSystem.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"The input data can either be a 3D triangulated surface mesh represented in STL format or a 2D polygonal traversal of the geometry (see load_geometry). The second step involves generating the SDF (see SignedDistanceField), which is necessary for the final packing step as it requires a surface detection. The SDF is illustrated in Fig. 2, where the distances to the surface of the geometry are visualized as a color map. As shown, the SDF is computed only within a narrow band around the geometry’s surface, enabling  a face-based neighborhood search (NHS) to be used exclusively during this step. In the third step, the initial configuration of the boundary particles is generated (orange particles in Fig. 3). Boundary particles are created by copying the positions of SDF points located outside the geometry but within a predefined boundary thickness (see sample_boundary). In the fourth step, the initial configuration of the interior particles (green particles in Fig. 4) is generated using the hierarchical winding number approach (see Hierarchical Winding). After steps 1 through 4, the initial configuration of both interior and boundary particles is obtained, as illustrated in Fig. 5. The interface of the geometry surface is not well resolved with the initial particle configuration. Thus, in the final step, a packing algorithm by Zhu et al. [3] is applied utilizing the SDF to simultaneously optimize the positions of both interior and boundary particles, yielding an isotropic distribution while accurately preserving the geometry surface, as illustrated in Fig. 6.","category":"page"},{"location":"preprocessing/preprocessing/","page":"Sampling of Geometries","title":"Sampling of Geometries","text":"<div style=\"display: flex; gap: 16px; flex-wrap: wrap;\">\n  <figure style=\"margin: 0; text-align: center;\">\n    <img src=\"https://github.com/user-attachments/assets/7fe9d1f1-1633-4377-8b97-a4d1778aee07\" alt=\"geometry\" style=\"max-width: 200px;\">\n    <figcaption>(1) Geometry representation</figcaption>\n  </figure>\n  <figure style=\"margin: 0; text-align: center;\">\n    <img src=\"https://github.com/user-attachments/assets/2b79188c-3148-49f1-8337-718721851bf5\" alt=\"sdf\" style=\"max-width: 200px;\">\n    <figcaption>(2) Signed distances to the surface</figcaption>\n  </figure>\n  <figure style=\"margin: 0; text-align: center;\">\n    <img src=\"https://github.com/user-attachments/assets/1501718f-d1f5-4f14-b1bc-2a2e581db476\" alt=\"boundary\" style=\"max-width: 200px;\">\n    <figcaption>(3) Boundary particles</figcaption>\n  </figure>\n  <figure style=\"margin: 0; text-align: center;\">\n    <img src=\"https://github.com/user-attachments/assets/f7376b15-324a-4da1-bb59-db01c7bd6620\" alt=\"interior\" style=\"max-width: 200px;\">\n    <figcaption>(4) Interior particles</figcaption>\n  </figure>\n  <figure style=\"margin: 0; text-align: center;\">\n    <img src=\"https://github.com/user-attachments/assets/4be889d6-e70a-4c5e-bef2-0071ea4d898c\" alt=\"initial_config\" style=\"max-width: 200px;\">\n    <figcaption>(5) Initial configuration</figcaption>\n  </figure>\n  <figure style=\"margin: 0; text-align: center;\">\n    <img src=\"https://github.com/user-attachments/assets/0f7aba29-3cf7-4ec1-8c95-841e72fe620d\" alt=\"packed_config\" style=\"max-width: 200px;\">\n    <figcaption>(6) Packed configuration</figcaption>\n  </figure>\n</div>","category":"page"},{"location":"preprocessing/preprocessing/#TrixiParticles.SignedDistanceField","page":"Sampling of Geometries","title":"TrixiParticles.SignedDistanceField","text":"SignedDistanceField(geometry, particle_spacing;\n                    points=nothing,\n                    max_signed_distance=4 * particle_spacing,\n                    use_for_boundary_packing=false)\n\nGenerate particles along a surface of a complex geometry storing the signed distances and normals to this surface.\n\nArguments\n\ngeometry: Geometry returned by load_geometry.\nparticle_spacing: Spacing between the particles.\n\nKeywords\n\nmax_signed_distance:      Maximum signed distance to be stored. That is, only particles with a                             distance of abs(max_signed_distance) to the surface of the shape                             will be sampled.\npoints:                   Points on which the signed distance is computed.                             When set to nothing (default), the bounding box of the shape will be                             sampled with a uniform grid of points.\nuse_for_boundary_packing: Set to true if [SignedDistanceField] is used to pack                             a boundary ParticlePackingSystem.                             Use the default of false when packing without a boundary.\n\n\n\n\n\n","category":"type"},{"location":"preprocessing/preprocessing/#TrixiParticles.ParticlePackingSystem","page":"Sampling of Geometries","title":"TrixiParticles.ParticlePackingSystem","text":"ParticlePackingSystem(shape::InitialCondition;\n                      signed_distance_field::Union{SignedDistanceField, Nothing},\n                      smoothing_kernel=SchoenbergQuinticSplineKernel{ndims(shape)}(),\n                      smoothing_length=shape.particle_spacing,\n                      smoothing_length_interpolation=smoothing_length,\n                      is_boundary=false, boundary_compress_factor=1,\n                      neighborhood_search=GridNeighborhoodSearch{ndims(shape)}(),\n                      background_pressure, tlsph=false, fixed_system=false)\n\nSystem to generate body-fitted particles for complex shapes. For more information on the methods, see particle packing.\n\nArguments\n\nshape: InitialCondition to be packed.\n\nKeywords\n\nbackground_pressure:   Constant background pressure to physically pack the particles.                          A large background_pressure can cause high accelerations                          which requires a properly adjusted time step.\ntlsph:                 With the TotalLagrangianSPHSystem, particles need to be placed                          on the boundary of the shape and not half a particle spacing away,                          as for fluids. When tlsph=true, particles will be placed                          on the boundary of the shape.\nis_boundary:           When shape is inside the geometry that was used to create                          signed_distance_field, set is_boundary=false.                          Otherwise (shape is the sampled boundary), set is_boundary=true.                          The thickness of the boundary is specified by creating                          signed_distance_field with:                             - use_for_boundary_packing=true                             - max_signed_distance=boundary_thickness                          See SignedDistanceField.\nfixed_system:          When set to true, the system remains static, meaning particles                          will not move and the InitialCondition will stay unchanged.                          This is useful when the system is packed together with another                          (non-fixed) ParticlePackingSystem.                          In this case, no SignedDistanceField is required for both                          the fixed and non-fixed system (use nothing as signed distance field).\nsigned_distance_field: To constrain particles onto the surface, the information about                          the signed distance from a particle to a face is required.                          The precalculated signed distances will be interpolated                          to each particle during the packing procedure.                          Set signed_distance_field=nothing when packing with a fixed system                          (see fixed_system description above).\nsmoothing_kernel:      Smoothing kernel to be used for this system.                          See Smoothing Kernels.\nsmoothing_length:      Smoothing length to be used for the gradient estimation.                          See Smoothing Kernels.\nsmoothing_length_interpolation: Smoothing length to be used for interpolating the SignedDistanceField information.                                   The default is smoothing_length_interpolation = smoothing_length.\nboundary_compress_factor: Factor to compress the boundary particles by reducing the boundary thickness by a factor of boundary_compress_factor.                             The default value is 1, which means no compression.                             Compression can be useful for highly convex geometries,                             where the boundary volume increases significantly while the mass of the boundary particles remains constant.                             Recommended values are 0.8 or 0.9.\n\n\n\n\n\n","category":"type"},{"location":"systems/dem/#dem","page":"Discrete Element Method (Solid)","title":"Discrete Element Method","text":"","category":"section"},{"location":"systems/dem/","page":"Discrete Element Method (Solid)","title":"Discrete Element Method (Solid)","text":"The Discrete Element Method (DEM) is a computational technique widely used in physics, engineering, and applied mathematics for simulating the mechanical behavior of granular materials, such as powders, sand, soil, or rock, as well as other discontinua. Unlike continuum mechanics that treats materials as continuous, DEM considers individual particles or elements and their interactions. This approach provides detailed insights into the micro-mechanical behavior of materials, making it particularly valuable in fields such as geomechanics, material science, and mechanical engineering.","category":"page"},{"location":"systems/dem/#Fundamental-Principles","page":"Discrete Element Method (Solid)","title":"Fundamental Principles","text":"","category":"section"},{"location":"systems/dem/","page":"Discrete Element Method (Solid)","title":"Discrete Element Method (Solid)","text":"The core idea behind DEM is the discretization of a material system into a finite set of distinct, interacting mass elements (particles). These elements (particles) can vary in shape, size, and properties, and they interact with each other and possibly with their boundaries through contact forces and potential fields. The motion and behavior of each mass element are governed by Newton's laws of motion, accounting for the forces and moments acting upon them.","category":"page"},{"location":"systems/dem/#API","page":"Discrete Element Method (Solid)","title":"API","text":"","category":"section"},{"location":"systems/dem/#TrixiParticles.DEMSystem","page":"Discrete Element Method (Solid)","title":"TrixiParticles.DEMSystem","text":"DEMSystem(initial_condition, contact_model; damping_coefficient=0.0001,\n          acceleration=ntuple(_ -> 0.0, ndims(initial_condition)), source_terms=nothing,\n          radius=nothing)\n\nConstructs a Discrete Element Method (DEM) system for numerically simulating the dynamics of granular and particulate matter. DEM is employed to simulate and analyze the motion, interactions, and collective behavior of assemblies of discrete, solid particles, typically under mechanical loading. The model accounts for individual particle characteristics and implements interaction laws that govern contact forces (normal and tangential), based on specified material properties and contact mechanics.\n\nArguments\n\ninitial_condition: Initial condition of the system, encapsulating the initial positions,  velocities, masses, and radii of particles.\ncontact_model: Contact model used for particle interactions.\n\nKeywords\n\nacceleration: Global acceleration vector applied to the system, such as gravity. Specified as  an SVector of length NDIMS, with a default of zero in each dimension.\nsource_terms: Optional; additional forces or modifications to particle dynamics not  captured by standard DEM interactions, such as electromagnetic forces or user-defined perturbations.\ndamping_coefficient=0.0001: Set a damping coefficient for the collision interactions.\nradius=nothing: Specifies the radius of the particles, defaults to initial_condition.particle_spacing / 2.\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in a future releases.\n\nReferences\n\n[36], [37], [38]\n\n\n\n\n\n","category":"type"},{"location":"systems/dem/#Contact-Models","page":"Discrete Element Method (Solid)","title":"Contact Models","text":"","category":"section"},{"location":"systems/dem/#TrixiParticles.HertzContactModel","page":"Discrete Element Method (Solid)","title":"TrixiParticles.HertzContactModel","text":"HertzContactModel(; elastic_modulus, poissons_ratio)\n\nNon-linear contact model based on Hertzian contact theory ([38]).\n\nThis model calculates the normal contact force between two spherical particles (or a particle and a boundary represented by an equivalent sphere) based on their material properties and the overlap delta. The elastic part of the force is given by:\n\nF_textelastic = frac43 E^* sqrtR^* delta^32\n\nwhere E^* is the effective Young's modulus and R^* is the effective radius.\n\nThe effective Young's modulus E^* is calculated from the Young's moduli E_a E_b and Poisson's ratios nu_a nu_b of the two contacting bodies:\n\nE^* = left( frac1 - nu_a^2E_a + frac1 - nu_b^2E_b right)^-1\n\nThe effective radius R^* is calculated from the radii of the two particles R_a and  R_b:\n\nR^* = left( frac1R_a + frac1R_b right)^-1 = fracR_a R_bR_a + R_b\n\nFor particle-wall interactions, R_b to infty, so R^* = R_a.\n\nThe implementation also includes a damping force based on the approach described in [38], proportional to the normal component of the relative velocity v_textreln:\n\nF_textdamping = C_textdamp gamma_c v_textreln\n\nwhere C_textdamp is the user-provided damping coefficient (damping ratio), and gamma_c is a non-linear critical damping coefficient:\n\ngamma_c = 2 sqrtm^* K_textnonlin\n\nwith m^* being the effective mass and K_textnonlin being a non-linear stiffness term related to the current state:\n\nK_textnonlin = fracF_textelasticdelta = frac43 E^* sqrtR^* delta\n\nThe total normal force is F_n = F_textelastic + F_textdamping.\n\nFields\n\nelastic_modulus::Float64: Material Young's modulus E.\npoissons_ratio::Float64: Material Poisson's ratio nu.\n\n\n\n\n\n","category":"type"},{"location":"systems/dem/#TrixiParticles.LinearContactModel","page":"Discrete Element Method (Solid)","title":"TrixiParticles.LinearContactModel","text":"LinearContactModel(; normal_stiffness)\n\nLinear spring-dashpot contact model ([37]).\n\nThis model calculates the normal contact force between two objects based on a linear spring law for the elastic component and a linear viscous damping law for the dissipative component. The total normal force F_n is given by\n\nF_n = k_n delta + gamma_d v_textreln\n\nwhere k_n is the normal stiffness, delta is the overlap between the objects, v_textreln is the normal component of the relative velocity, and gamma_d is the damping coefficient.\n\nThe damping coefficient gamma_d is calculated based on the critical damping coefficient gamma_c and a user-provided damping ratio C_textdamp:\n\ngamma_d = C_textdamp gamma_c\n\nwhere the critical damping for this linear system is\n\ngamma_c = 2 sqrtm^* k_n\n\nand m^* is the effective mass of the colliding pair.\n\nThe total force is applied along the normal direction connecting the centers of the contacting objects.\n\nFields\n\nnormal_stiffness::Real: Constant spring stiffness k_n for the normal direction.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#smoothing_kernel","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"","category":"section"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"The following smoothing kernels are currently available:","category":"page"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"Smoothing Kernel Compact Support Typ. Smoothing Length Recommended Application Stability\nSchoenbergCubicSplineKernel 0 2h 11 to 13 General + sharp waves ++\nSchoenbergQuarticSplineKernel 0 25h 11 to 15 General +++\nSchoenbergQuinticSplineKernel 0 3h 11 to 15 General ++++\nGaussianKernel 0 3h 10 to 15 Literature +++++\nWendlandC2Kernel 0 2h 12 to 20 General (recommended) ++++\nWendlandC4Kernel 0 2h 15 to 23 General +++++\nWendlandC6Kernel 0 2h 17 to 25 General +++++\nPoly6Kernel 0 1h 15 to 25 Literature +\nSpikyKernel 0 1h 15 to 30 Sharp corners + waves +","category":"page"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"We recommend to use the WendlandC2Kernel for most applications. If less smoothing is needed, try SchoenbergCubicSplineKernel, for more smoothing try WendlandC6Kernel.","category":"page"},{"location":"general/smoothing_kernels/","page":"Smoothing Kernels","title":"Smoothing Kernels","text":"note: Usage\nThe kernel can be called asTrixiParticles.kernel(smoothing_kernel, r, h)The length of the compact support can be obtained asTrixiParticles.compact_support(smoothing_kernel, h)Note that r has to be a scalar, so in the context of SPH, the kernel should be used asW(Vert r_a - r_b Vert h)The gradient required in SPH,    nabla_r_a W(Vert r_a - r_b Vert h)can be called asTrixiParticles.kernel_grad(smoothing_kernel, pos_diff, distance, h)where pos_diff is r_a - r_b and distance is Vert r_a - r_b Vert.","category":"page"},{"location":"general/smoothing_kernels/#TrixiParticles.GaussianKernel","page":"Smoothing Kernels","title":"TrixiParticles.GaussianKernel","text":"GaussianKernel{NDIMS}()\n\nGaussian kernel given by\n\nW(r h) = fracsigma_dh^d e^-r^2h^2\n\nwhere d is the number of dimensions and\n\nsigma_2 = frac1pi for 2D,\nsigma_3 = frac1pi^32 for 3D.\n\nThis kernel function has an infinite support, but in practice, it's often truncated at a certain multiple of h, such as 3h.\n\nIn this implementation, the kernel is truncated at 3h, so this kernel function has a compact support of 0 3h.\n\nThe smoothing length is typically in the range 10delta 15delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\nNote: This truncation makes this Kernel not conservative, which is beneficial in regards to stability but makes it less accurate.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.Poly6Kernel","page":"Smoothing Kernels","title":"TrixiParticles.Poly6Kernel","text":"Poly6Kernel{NDIMS}()\n\nPoly6 kernel, a commonly used kernel in SPH literature [4], especially in computer graphics contexts. It is defined as\n\nW(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (1 - q^2)^3     textif  0 leq q  1 \n    0               textif  q geq 1\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor that depends on the dimension. The normalization factor sigma is 4  pi in two dimensions or 315  64pi in three dimensions.\n\nThis kernel function has a compact support of 0 h.\n\nPoly6 is well-known for its computational simplicity, though it's worth noting that there are other kernels that might offer better accuracy for hydrodynamic simulations. Furthermore, its derivatives are not that smooth, which can lead to stability problems. It is also susceptible to clumping.\n\nThe smoothing length is typically in the range 15delta 25delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SchoenbergCubicSplineKernel","page":"Smoothing Kernels","title":"TrixiParticles.SchoenbergCubicSplineKernel","text":"SchoenbergCubicSplineKernel{NDIMS}()\n\nCubic spline kernel by Schoenberg (1946), given by\n\n    W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    frac14 (2 - q)^3 - (1 - q)^3    textif  0 leq q  1 \n    frac14 (2 - q)^3                textif  1 leq q  2 \n    0                                    textif  q geq 2 \nendcases\n\nwhere d is the number of dimensions and sigma is a normalization constant given by sigma =frac23 frac107 pi frac1pi in 1 2 3 dimensions.\n\nThis kernel function has a compact support of 0 2h.\n\nFor an overview of Schoenberg cubic, quartic and quintic spline kernels including normalization factors, see Price (2012). For an analytic formula for higher order Schoenberg kernels, see Monaghan (1985). The largest disadvantage of Schoenberg Spline Kernel is the rather non-smooth first derivative, which can lead to increased noise compared to other kernel variants.\n\nThe smoothing length is typically in the range 11delta 13delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SchoenbergQuarticSplineKernel","page":"Smoothing Kernels","title":"TrixiParticles.SchoenbergQuarticSplineKernel","text":"SchoenbergQuarticSplineKernel{NDIMS}()\n\nQuartic spline kernel by Schoenberg (1946), given by\n\n    W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    left(52 - q right)^4 - 5left(32 - q right)^4\n    + 10left(12 - q right)^4  textif  0 leq q  frac12 \n    left(52 - q right)^4 - 5left(32 - q right)^4\n     textif  frac12 leq q  frac32 \n    left(52 - q right)^4  textif  frac32 leq q  frac52 \n    0  textif  q geq frac52\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization constant given by sigma =frac124 frac961199 pi frac120pi in 1 2 3 dimensions.\n\nThis kernel function has a compact support of 0 25h.\n\nFor an overview of Schoenberg cubic, quartic and quintic spline kernels including normalization factors, see Price (2012). For an analytic formula for higher order Schoenberg kernels, see Monaghan (1985).\n\nThe largest disadvantage of Schoenberg Spline Kernel are the rather non-smooth first derivative, which can lead to increased noise compared to other kernel variants.\n\nThe smoothing length is typically in the range 11delta 15delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SchoenbergQuinticSplineKernel","page":"Smoothing Kernels","title":"TrixiParticles.SchoenbergQuinticSplineKernel","text":"SchoenbergQuinticSplineKernel{NDIMS}()\n\nQuintic spline kernel by Schoenberg (1946), given by\n\n    W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (3 - q)^5 - 6(2 - q)^5 + 15(1 - q)^5     textif  0 leq q  1 \n    (3 - q)^5 - 6(2 - q)^5                   textif  1 leq q  2 \n    (3 - q)^5                                textif  2 leq q  3 \n    0                                        textif  q geq 3\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization constant given by sigma =frac1120 frac7478 pi frac1120pi in 1 2 3 dimensions.\n\nThis kernel function has a compact support of 0 3h.\n\nFor an overview of Schoenberg cubic, quartic and quintic spline kernels including normalization factors, see Price (2012). For an analytic formula for higher order Schoenberg kernels, see Monaghan (1985).\n\nThe largest disadvantage of Schoenberg Spline Kernel are the rather non-smooth first derivative, which can lead to increased noise compared to other kernel variants.\n\nThe smoothing length is typically in the range 11delta 15delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.SpikyKernel","page":"Smoothing Kernels","title":"TrixiParticles.SpikyKernel","text":"SpikyKernel{NDIMS}()\n\nThe Spiky kernel is another frequently used kernel in SPH, especially due to its desirable properties in preserving features near boundaries in fluid simulations [4]. It is defined as:\n\n W(r h) = frac1h^d w(rh)\n\nwith:\n\nw(q) = sigma begincases\n    (1 - q)^3     textif  0 leq q  1 \n    0             textif  q geq 1\nendcases\n\nwhere d is the number of dimensions and the normalization factor sigma is 10  pi in two dimensions or 15  pi in three dimensions.\n\nThis kernel function has a compact support of 0 h.\n\nThe Spiky kernel is particularly known for its sharp gradients, which can help to preserve sharp features in fluid simulations, especially near solid boundaries. These sharp gradients at the boundary are also the largest disadvantage as they can lead to instability.\n\nThe smoothing length is typically in the range 15delta 30delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.WendlandC2Kernel","page":"Smoothing Kernels","title":"TrixiParticles.WendlandC2Kernel","text":"WendlandC2Kernel{NDIMS}()\n\nWendland C2 kernel [8], a piecewise polynomial function designed to have compact support and to be twice continuously differentiable everywhere. Given by\n\n W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (1 - q2)^4 (2q + 1)   textif  0 leq q  2 \n    0                      textif  q geq 2\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor dependent on the dimension. The normalization factor sigma is 407pi in two dimensions or 212pi in three dimensions.\n\nThis kernel function has a compact support of 0 2h.\n\nFor a detailed discussion on Wendland functions and their applications in SPH, see Dehnen (2012). The smoothness of these functions is also the largest disadvantage as they lose details at sharp corners.\n\nThe smoothing length is typically in the range 12delta 2delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.WendlandC4Kernel","page":"Smoothing Kernels","title":"TrixiParticles.WendlandC4Kernel","text":"WendlandC4Kernel{NDIMS}()\n\nWendland C4 kernel [8], a piecewise polynomial function designed to have compact support and to be four times continuously differentiable everywhere. Given by\n\n W(r h) = frac1h^d w(rh)\n\nwith\n\nw(q) = sigma begincases\n    (1 - q2)^6 (35q^2  12 + 3q + 1)    textif  0 leq q  2 \n    0                                    textif  q geq 2\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor dependent on the dimension. The normalization factor sigma is 9  pi in two dimensions or 495  32pi in three dimensions.\n\nThis kernel function has a compact support of 0 2h.\n\nFor a detailed discussion on Wendland functions and their applications in SPH, see Dehnen (2012). The smoothness of these functions is also the largest disadvantage as they lose details at sharp corners.\n\nThe smoothing length is typically in the range 15delta 23delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"general/smoothing_kernels/#TrixiParticles.WendlandC6Kernel","page":"Smoothing Kernels","title":"TrixiParticles.WendlandC6Kernel","text":"WendlandC6Kernel{NDIMS}()\n\nWendland C6 kernel [8], a piecewise polynomial function designed to have compact support and to be six times continuously differentiable everywhere. Given by:\n\nW(r h) = frac1h^d w(rh)\n\nwith:\n\nw(q) = sigma begincases\n    (1 - q  2)^8 (4q^3 + 25q^2  4 + 4q + 1)    textif  0 leq q  2 \n    0                                            textif  q geq 2\nendcases\n\nwhere d is the number of dimensions and sigma is a normalization factor dependent on the dimension. The normalization factor sigma is 78  7 pi in two dimensions or 1365  64pi in three dimensions.\n\nThis kernel function has a compact support of 0 2h.\n\nFor a detailed discussion on Wendland functions and their applications in SPH, Dehnen (2012). The smoothness of these functions is also the largest disadvantage as they lose details at sharp corners.\n\nThe smoothing length is typically in the range 17delta 25delta, where delta is the typical particle spacing.\n\nFor general information and usage see Smoothing Kernels.\n\n\n\n\n\n","category":"type"},{"location":"reference-trixibase/#TrixiBase.jl-API","page":"TrixiBase.jl API Reference","title":"TrixiBase.jl API","text":"","category":"section"},{"location":"reference-trixibase/#TrixiBase.disable_debug_timings-Tuple{}","page":"TrixiBase.jl API Reference","title":"TrixiBase.disable_debug_timings","text":"disable_debug_timings()\n\nDisable all @trixi_timeit timings. The timings should be optimized away, allowing for truly zero-overhead. Enable timings again with enable_debug_timings.\n\nSee also enable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixibase/#TrixiBase.enable_debug_timings-Tuple{}","page":"TrixiBase.jl API Reference","title":"TrixiBase.enable_debug_timings","text":"enable_debug_timings()\n\nEnable all @trixi_timeit timings (default behavior).\n\nSee also disable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixibase/#TrixiBase.timer-Tuple{}","page":"TrixiBase.jl API Reference","title":"TrixiBase.timer","text":"timer()\n\nMain timer for global timing, e.g., to be used with @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixibase/#TrixiBase.trixi_include-Tuple{Function, Module, AbstractString}","page":"TrixiBase.jl API Reference","title":"TrixiBase.trixi_include","text":"trixi_include([mapexpr::Function=identity,] [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. Its basic purpose is to make it easier to modify some parameters while running simulations from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nBefore replacing assignments in elixir, the keyword argument maxiters is inserted into calls to solve with it's default value used in the SciML ecosystem for ODEs, see the \"Miscellaneous\" section of the documentation.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in elixir, the include function actually evaluates mapexpr(expr). If it is omitted, mapexpr defaults to identity.\n\nExamples\n\njulia> using TrixiBase, Trixi\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\n0.1\n\n\n\n\n\n","category":"method"},{"location":"reference-trixibase/#TrixiBase.trixi_include_changeprecision-Tuple{Any, Module, AbstractString}","page":"TrixiBase.jl API Reference","title":"TrixiBase.trixi_include_changeprecision","text":"trixi_include_changeprecision(T, [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the elixir elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments, similar to trixi_include.\n\nThe only difference to trixi_include is that the precision of floating-point numbers in the included elixir is changed to T. More precisely, the package ChangePrecision.jl is used to convert all Float64 literals, operations like / that produce Float64 results, and functions like ones that return Float64 arrays by default, to the desired type T. See the documentation of ChangePrecision.jl for more details.\n\nThe purpose of this function is to conveniently run a full simulation with Float32, which is orders of magnitude faster on most GPUs than Float64, by just including the elixir with trixi_include_changeprecision(Float32, elixir). Many constructors in the Trixi.jl framework are written in a way that changing all floating-point arguments to Float32 will change the element type to Float32 as well. In TrixiParticles.jl, including an elixir with this macro should be sufficient to run the full simulation with single precision.\n\n\n\n\n\n","category":"method"},{"location":"reference-trixibase/#TrixiBase.@trixi_timeit-Tuple{Any, Any, Any}","page":"TrixiBase.jl API Reference","title":"TrixiBase.@trixi_timeit","text":"@trixi_timeit timer() \"some label\" expression\n\nBasically the same as a special case of @timeit_debug from TimerOutputs.jl, but without try ... finally ... end block. Thus, it's not exception-safe, but it also avoids some related performance problems. Since we do not use exception handling in Trixi.jl, that's not really an issue.\n\nAll @trixi_timeit timings can be disabled with disable_debug_timings. The timings should then be optimized away, allowing for truly zero-overhead.\n\nSee also disable_debug_timings, enable_debug_timings.\n\n\n\n\n\n","category":"macro"},{"location":"tutorials_template/tut_beam/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials_template/tut_beam/","page":"Example file","title":"Example file","text":"!!include:examples/solid/oscillating_beam_2d.jl!!\n","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TrixiParticles.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"TrixiParticles.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"development/#development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/#Preview-of-the-documentation","page":"Development","title":"Preview of the documentation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"To generate the Documentation, first instantiate the docs environment by executing the following command from the TrixiParticles.jl root directory:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs -e \"using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()\"","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"This command only has to be run once. After that, maintain the docs environment as described under Installation.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"With an instantiated docs environment, generate the docs with the following command (again from the TrixiParticles.jl root directory):","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs --color=yes docs/make.jl","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"You can then open the generated files in docs/build with your webbrowser. Alternatively, run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"python3 -m http.server -d docs/build","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"and open localhost:8000 in your webbrowser.","category":"page"},{"location":"development/#Release-management","page":"Development","title":"Release management","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"To create a new release for TrixiParticles.jl, perform the following steps:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Make sure that all PRs and changes that you want to go into the release are merged to main and that the latest commit on main has passed all CI tests.\nDetermine the currently released version of TrixiParticles.jl, e.g., on the release page. For this manual, we will assume that the latest release was v0.2.3.\nDecide on the next version number. We follow semantic versioning, thus each version is of the form vX.Y.Z where X is the major version, Y the minor version, and Z the patch version. In this manual, we assume that the major version is always 0, thus the decision process on the new version is as follows:\nIf the new release contains breaking changes (i.e., user code might not work as before without modifications), increase the minor version by one and set the patch version to zero. In our example, the new version should thus be v0.3.0.\nIf the new release only contains minor modifications and/or bug fixes, the minor version is kept as-is and the patch version is increased by one. In our example, the new version should thus be v0.2.4.\nEdit the version string in the Project.toml and set it to the new version. Push/merge this change to main.\nGo to GitHub and add a comment to the commit that you would like to become the new release (typically this will be the commit where you just updated the version). You can comment on a commit by going to the commit overview and clicking on the title of the commit. The comment should contain the following text:\n@JuliaRegistrator register\nWait for the magic to happen! Specifically, JuliaRegistrator will create a new PR to the Julia registry with the new release information. After a grace period of ~15 minutes, this PR will be merged automatically. A short while after, TagBot will create a new release of TrixiParticles.jl in our GitHub repository.\nOnce the new release has been created, the new version can be obtained through the Julia package manager as usual.\nTo make sure people do not mistake the latest state of main as the latest release, we set the version in the Project.toml to a development version. The development version should be the latest released version, with the patch version incremented by one, and the -dev suffix added. For example, if you just released v0.3.0, the new development version should be v0.3.1-dev. If you just released v0.2.4, the new development version should be v0.2.5-dev.","category":"page"},{"location":"install/#installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Setting-up-Julia","page":"Installation","title":"Setting up Julia","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you have not yet installed Julia, please follow the instructions on the official website. TrixiParticles.jl works with Julia v1.10 and newer. We recommend using the latest stable release of Julia.","category":"page"},{"location":"install/#For-users","page":"Installation","title":"For users","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"TrixiParticles.jl is a registered Julia package. You can install TrixiParticles.jl, OrdinaryDiffEq.jl (used for time integration) and Plots.jl by executing the following commands in the Julia REPL:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg\n\njulia> Pkg.add([\"TrixiParticles\", \"OrdinaryDiffEq\", \"Plots\"])","category":"page"},{"location":"install/#for-developers","page":"Installation","title":"For developers","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you plan on editing TrixiParticles.jl itself, you can download TrixiParticles.jl to a local folder and use the code from the cloned directory:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone git@github.com:trixi-framework/TrixiParticles.jl.git\ncd TrixiParticles.jl\nmkdir run\njulia --project=run -e 'using Pkg; Pkg.develop(PackageSpec(path=\".\"))' # Add TrixiParticles.jl to `run` project\njulia --project=run -e 'using Pkg; Pkg.add([\"OrdinaryDiffEq\", \"Plots\"])' # Add additional packages","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you installed TrixiParticles.jl this way, you always have to start Julia with the --project flag set to your run directory, e.g.,","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia --project=run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"from the TrixiParticles.jl root directory.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The advantage of using a separate run directory is that you can also add other related packages (e.g., OrdinaryDiffEq.jl, see above) to the project in the run folder and always have a reproducible environment at hand to share with others.","category":"page"},{"location":"install/#Optional-software/packages","page":"Installation","title":"Optional software/packages","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"OrdinaryDiffEq.jl – A Julia package of ordinary differential equation solvers that is used in the examples\nPlots.jl – Julia Plotting library that is used in some examples\nPythonPlot.jl – Plotting library that can be used instead of Plots.jl\nParaView – Software that can be used for visualization of results","category":"page"},{"location":"install/#installation-issues","page":"Installation","title":"Common issues","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"If you followed the installation instructions for developers and you run into any problems with packages when pulling the latest version of TrixiParticles.jl, start Julia with the project in the run folder,","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"   julia --project=run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"update all packages in that project, resolve all conflicts in the project, and install all new dependencies:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg\n\njulia> Pkg.update()\n\njulia> Pkg.resolve()\n\njulia> Pkg.instantiate()","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/#Export-VTK-files","page":"Visualization","title":"Export VTK files","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"You can export particle data as VTK files by using the SolutionSavingCallback. All our predefined examples are already using this callback to export VTK files to the out directory (relative to the directory that you are running Julia from). VTK files can be read by visualization tools like ParaView and VisIt.","category":"page"},{"location":"visualization/#ParaView","page":"Visualization","title":"ParaView","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Follow these steps to view the exported VTK files in ParaView:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Click File -> Open.\nNavigate to the out directory (relative to the directory that you are running Julia from).\nOpen both boundary_1.pvd and fluid_1.pvd.\nClick \"Apply\", which by default is on the left pane below the \"Pipeline Browser\".\nHold the left mouse button to move the solution around.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"You will now see the following: (Image: image)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"It is useful to make the dot size dependent on the actual particle size. For this, first make sure you have \"fluid_1.pvd\" highlighted in the \"Pipeline Browser\". Then, in the Properties panel (bottom left), adjust the following settings:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"\"Representation\" to \"Point Gaussian\".\nChoose the right \"Shader Preset\": \"Plain Circle\" for 2D and \"Sphere\" for 3D.\nActivate \"Scale by Array\" and select \"particle_spacing\" in \"Gaussian Scale Array\".\nDeactivate \"Use Scale Function\".\nSet the \"Gaussian Radius\" to \"0.5\".","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: image)","category":"page"},{"location":"visualization/#Visualization-with-Macro","page":"Visualization","title":"Visualization with Macro","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To simplify the visualization of your particle data in ParaView, you can use a macro. This macro automates the manual steps in the previous section to a single click of a button. Install the macro as follows.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Save the macro code (see below) as a .py file, e.g. PointGaussianMacro.py.\nOpen ParaView and go to the top menu: Macros → Import New Macro... → Select the saved .py file.\nThe macro will now appear in the Macros menu and can optionally be pinned to the toolbar.\nLoad your dataset into ParaView.\nSelect the dataset in the Pipeline Browser.\nClick on the macro name in the Macros menu (or toolbar, if pinned) to run it.\nThe Point Gaussian representation with particle_spacing scaling will be applied automatically.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"","category":"page"},{"location":"visualization/#Macro-Code","page":"Visualization","title":"Macro Code","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# trace generated using paraview version 5.13.1\n#from paraview\n#paraview.compatibility.major = 5\n#paraview.compatibility.minor = 13\n\nfrom paraview.simple import *\nparaview.simple._DisableFirstRenderCameraReset()\n\n# get active source\nsource = GetActiveSource()\n\n# get active view\nrenderView1 = GetActiveViewOrCreate('RenderView')\n\n# get display properties\nsourceDisplay = GetDisplayProperties(source, view=renderView1)\n\n# change representation type\nsourceDisplay.SetRepresentationType('Point Gaussian')\n\n# modified display properties\nsourceDisplay.ShaderPreset = 'Plain circle' # for 2D, change to 'Sphere' for 3D\nsourceDisplay.ScaleByArray = 1\nsourceDisplay.SetScaleArray = ['POINTS', 'particle_spacing']\nsourceDisplay.UseScaleFunction = 0\nsourceDisplay.GaussianRadius = 0.5","category":"page"},{"location":"visualization/#Show-results","page":"Visualization","title":"Show results","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"To now view the result variables first make sure you have \"fluid_1.pvd\" highlighted in the \"Pipeline Browser\" then select them in the variable selection combo box (see picture below). Let's, for example, pick \"density\". To now view the time progression of the result hit the \"play button\" (see picture below). (Image: image)","category":"page"},{"location":"visualization/#API","page":"Visualization","title":"API","text":"","category":"section"},{"location":"visualization/#TrixiParticles.vtk2trixi-Tuple{Any}","page":"Visualization","title":"TrixiParticles.vtk2trixi","text":"vtk2trixi(file::String)\n\nLoad VTK file and convert data to an InitialCondition.\n\nArguments\n\nfile: Name of the VTK file to be loaded.\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in any future releases.\n\nExample\n\n```jldoctest; output = false\n\nCreate a rectangular shape\n\nrectangular = RectangularShape(0.1, (10, 10), (0, 0), density=1.5, velocity=(1.0, -2.0),                                pressure=1000.0)\n\nWrite the InitialCondition to a vtk file\n\ntrixi2vtk(rectangular; filename=\"rectangular\", output_directory=\"out\")\n\nRead the vtk file and convert it to InitialCondition\n\nic = vtk2trixi(joinpath(\"out\", \"rectangular.vtu\"))\n\noutput\n\n┌──────────────────────────────────────────────────────────────────────────────────────────────────┐ │ InitialCondition{Float64}                                                                        │ │ ═════════════════════════                                                                        │ │ #dimensions: ……………………………………………… 2                                                                │ │ #particles: ………………………………………………… 100                                                              │ │ particle spacing: ………………………………… 0.1                                                              │ └──────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n\n\n\n\n","category":"method"},{"location":"visualization/#TrixiParticles.trixi2vtk-Tuple{Any, Any, Any}","page":"Visualization","title":"TrixiParticles.trixi2vtk","text":"trixi2vtk(vu_ode, semi, t; iter=nothing, output_directory=\"out\", prefix=\"\",\n          write_meta_data=true, max_coordinates=Inf, custom_quantities...)\n\nConvert Trixi simulation data to VTK format.\n\nArguments\n\nvu_ode: Solution of the TrixiParticles ODE system at one time step.           This expects an ArrayPartition as returned in the examples as sol.u[end].\nsemi:   Semidiscretization of the TrixiParticles simulation.\nt:      Current time of the simulation.\n\nKeywords\n\niter=nothing:           Iteration number when multiple iterations are to be stored in                           separate files. This number is just appended to the filename.\noutput_directory=\"out\": Output directory path.\nprefix=\"\":              Prefix for output files.\nwrite_meta_data=true:   Write meta data.\nmax_coordinates=Inf     The coordinates of particles will be clipped if their absolute                           values exceed this threshold.\ncustom_quantities...:   Additional custom quantities to include in the VTK output.                           Each custom quantity must be a function of (system, data, t),                           which will be called for every system, where data is a named                           tuple with fields depending on the system type, and t is the                           current simulation time. Check the available data for each                           system with available_data(system).                           See Custom Quantities                           for a list of pre-defined custom quantities that can be used here.\n\nExample\n\ntrixi2vtk(sol.u[end], semi, 0.0, iter=1, output_directory=\"output\", prefix=\"solution\")\n\n# Additionally store the kinetic energy of each system as \"my_custom_quantity\"\ntrixi2vtk(sol.u[end], semi, 0.0, iter=1, my_custom_quantity=kinetic_energy)\n\n\n\n\n\n","category":"method"},{"location":"visualization/#TrixiParticles.trixi2vtk-Tuple{Any}","page":"Visualization","title":"TrixiParticles.trixi2vtk","text":"trixi2vtk(coordinates; output_directory=\"out\", prefix=\"\", filename=\"coordinates\",\n          custom_quantities...)\n\nConvert coordinate data to VTK format.\n\nArguments\n\ncoordinates: Coordinates to be saved.\n\nKeywords\n\noutput_directory=\"out\": Output directory path.\nprefix=\"\":              Prefix for the output file.\nfilename=\"coordinates\": Name of the output file.\ncustom_quantities...:   Additional custom quantities to include in the VTK output.\n\nReturns\n\nfile::AbstractString: Path to the generated VTK file.\n\n\n\n\n\n","category":"method"},{"location":"visualization/#TrixiParticles.trixi2vtk-Tuple{InitialCondition}","page":"Visualization","title":"TrixiParticles.trixi2vtk","text":"trixi2vtk(initial_condition::InitialCondition; output_directory=\"out\",\n          prefix=\"\", filename=\"initial_condition\", custom_quantities...)\n\nConvert InitialCondition data to VTK format.\n\nArguments\n\ninitial_condition: InitialCondition to be saved.\n\nKeywords\n\noutput_directory=\"out\": Output directory path.\nprefix=\"\":              Prefix for the output file.\nfilename=\"coordinates\": Name of the output file.\ncustom_quantities...:   Additional custom quantities to include in the VTK output.\n\nReturns\n\nfile::AbstractString: Path to the generated VTK file.\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#initial_condition","page":"Initial Condition and Setups","title":"Initial Condition","text":"","category":"section"},{"location":"general/initial_condition/#TrixiParticles.InitialCondition","page":"Initial Condition and Setups","title":"TrixiParticles.InitialCondition","text":"InitialCondition(; coordinates, density, velocity=zeros(size(coordinates, 1)),\n                 mass=nothing, pressure=0.0, particle_spacing=-1.0)\n\nStruct to hold the initial configuration of the particles.\n\nThe following setups return InitialConditions for commonly used setups:\n\nRectangularShape\nSphereShape\nRectangularTank\nComplexShape\nextrude_geometry\n\nInitialConditions support the set operations union, setdiff and intersect in order to build more complex geometries. InitialConditions also support the set operations setdiff and intersect together with TrixiParticles.TriangleMesh and TrixiParticles.Polygon returned by load_geometry.\n\nArguments\n\ncoordinates: An array where the i-th column holds the coordinates of particle i.\ndensity:     Either a vector holding the density of each particle,                or a function mapping each particle's coordinates to its density,                or a scalar for a constant density over all particles.\n\nKeywords\n\nvelocity:   Either an array where the i-th column holds the velocity of particle i,               or a function mapping each particle's coordinates to its velocity,               or, for a constant fluid velocity, a vector holding this velocity.               Velocity is constant zero by default.\nmass:       Either nothing (default) to automatically compute particle mass from particle               density and spacing, or a vector holding the mass of each particle,               or a function mapping each particle's coordinates to its mass,               or a scalar for a constant mass over all particles.\npressure:   Either a vector holding the pressure of each particle,               or a function mapping each particle's coordinates to its pressure,               or a scalar for a constant pressure over all particles. This is optional and               only needed when using the EntropicallyDampedSPHSystem.\nparticle_spacing: The spacing between the particles. This is a scalar, as the spacing                     is assumed to be uniform. This is only needed when using                     set operations on the InitialCondition or for automatic mass calculation.\n\nExamples\n\n# Rectangle filled with particles\ninitial_condition = RectangularShape(0.1, (3, 4), (-1.0, 1.0), density=1.0)\n\n# Two spheres in one initial condition\ninitial_condition = union(SphereShape(0.15, 0.5, (-1.0, 1.0), 1.0),\n                          SphereShape(0.15, 0.2, (0.0, 1.0), 1.0))\n\n# Rectangle with a spherical hole\nshape1 = RectangularShape(0.1, (16, 13), (-0.8, 0.0), density=1.0)\nshape2 = SphereShape(0.1, 0.35, (0.0, 0.6), 1.0, sphere_type=RoundSphere())\ninitial_condition = setdiff(shape1, shape2)\n\n# Intersect of a rectangle with a sphere. Note that this keeps the particles of the\n# rectangle that are in the intersect, while `intersect(shape2, shape1)` would consist of\n# the particles of the sphere that are in the intersect.\nshape1 = RectangularShape(0.1, (16, 13), (-0.8, 0.0), density=1.0)\nshape2 = SphereShape(0.1, 0.35, (0.0, 0.6), 1.0, sphere_type=RoundSphere())\ninitial_condition = intersect(shape1, shape2)\n\n# Set operations with geometries loaded from files\nshape = RectangularShape(0.05, (20, 20), (0.0, 0.0), density=1.0)\nfile =  pkgdir(TrixiParticles, \"examples\", \"preprocessing\", \"data\", \"circle.asc\")\ngeometry = load_geometry(file)\n\ninitial_condition_1 = intersect(shape, geometry)\ninitial_condition_2 = setdiff(shape, geometry)\n\n# Build `InitialCondition` manually\ncoordinates = [0.0 1.0 1.0\n               0.0 0.0 1.0]\nvelocity = zero(coordinates)\nmass = ones(3)\ndensity = 1000 * ones(3)\ninitial_condition = InitialCondition(; coordinates, velocity, mass, density)\n\n# With functions\ninitial_condition = InitialCondition(; coordinates, velocity=x -> 2x, mass=1.0, density=1000.0)\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#Setups","page":"Initial Condition and Setups","title":"Setups","text":"","category":"section"},{"location":"general/initial_condition/#TrixiParticles.ComplexShape-Tuple{Any}","page":"Initial Condition and Setups","title":"TrixiParticles.ComplexShape","text":"ComplexShape(geometry::Union{TriangleMesh, Polygon}; particle_spacing, density,\n             pressure=0.0, mass=nothing, velocity=zeros(ndims(geometry)),\n             point_in_geometry_algorithm=WindingNumberJacobson(; geometry,\n                                                               hierarchical_winding=false,\n                                                               winding_number_factor=sqrt(eps())),\n             grid_offset::Real=0.0, max_nparticles=10^7,\n             pad_initial_particle_grid=2particle_spacing)\n\nSample a complex geometry with particles. Returns an InitialCondition. Note that an initial particle grid is generated inside the bounding box of the geometry. A point_in_geometry_algorithm checks if particles are inside the geometry or not. For more information about the method see WindingNumberJacobson or WindingNumberHormann.\n\nArguments\n\ngeometry: Geometry returned by load_geometry.\n\nKeywords\n\nparticle_spacing:   Spacing between the particles.\ndensity:            Either a function mapping each particle's coordinates to its density,                       or a scalar for a constant density over all particles.\nvelocity:           Either a function mapping each particle's coordinates to its velocity,                       or, for a constant fluid velocity, a vector holding this velocity.                       Velocity is constant zero by default.\nmass:               Either nothing (default) to automatically compute particle mass from particle                       density and spacing, or a function mapping each particle's coordinates to its mass,                       or a scalar for a constant mass over all particles.\npressure:           Scalar to set the pressure of all particles to this value.                       This is only used by the EntropicallyDampedSPHSystem and                       will be overwritten when using an initial pressure function in the system.\npoint_in_geometry_algorithm: Algorithm for sampling the complex geometry with particles.                                It basically checks whether a particle is inside an object or not.                                For more information see WindingNumberJacobson or WindingNumberHormann\ngrid_offset: Offset of the initial particle grid of the bounding box of the geometry.\nmax_nparticles: Maximum number of particles in the initial particle grid.                   This is only used to avoid accidentally choosing a particle_spacing                   that is too small for the scale of the geometry.\npad_initial_particle_grid: Padding of the initial particle grid.\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in any future releases.\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#TrixiParticles.sample_boundary-Tuple{Any}","page":"Initial Condition and Setups","title":"TrixiParticles.sample_boundary","text":"sample_boundary(signed_distance_field::SignedDistanceField;\n                boundary_thickness::Real, tlsph=true)\n\nSample boundary particles of a complex geometry by using the SignedDistanceField of the geometry.\n\nArguments\n\nsigned_distance_field: The signed distance field of a geometry (see SignedDistanceField).\n\nKeywords\n\nboundary_thickness: Thickness of the boundary\ntlsph             : When tlsph=true, boundary particles will be placed                       one particle spacing from the surface of the geometry.                       Otherwise when tlsph=true (simulating fluid particles),                       boundary particles will be placed half particle spacing away from the surface.\n\nExamples\n\ngeometry = load_geometry(file)\n\nsigned_distance_field = SignedDistanceField(geometry, particle_spacing;\n                                            use_for_boundary_packing=true,\n                                            max_signed_distance=boundary_thickness)\n\nboundary_sampled = sample_boundary(signed_distance_field; boundary_density=1.0,\n                                   boundary_thickness)\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#TrixiParticles.extrude_geometry-Tuple{Any}","page":"Initial Condition and Setups","title":"TrixiParticles.extrude_geometry","text":"extrude_geometry(geometry; particle_spacing, direction, n_extrude::Integer,\n                 velocity=zeros(length(direction)),\n                 mass=nothing, density=nothing, pressure=0.0)\n\nExtrude either a line, a plane or a shape along a specific direction. Returns an InitialCondition.\n\nArguments\n\ngeometry:           Either particle coordinates or an InitialCondition                       defining a 2D shape to extrude to a 3D volume, or two 2D points                       (A B) defining the interval A B to extrude to a plane                       in 2D, or three 3D points (A B C) defining the parallelogram                       spanned by the vectors widehatAB and widehat AC to extrude                       to a parallelepiped.\n\nKeywords\n\nparticle_spacing:   Spacing between the particles. Can be omitted when geometry is an                       InitialCondition (unless geometry.particle_spacing == -1).\ndirection:          A vector that specifies the direction in which to extrude.\nn_extrude:          Number of layers of particles created in the direction of extrusion.\nvelocity:           Either a function mapping each particle's coordinates to its velocity,                       or, for a constant fluid velocity, a vector holding this velocity.                       Velocity is constant zero by default.\nmass:               Either nothing (default) to automatically compute particle mass from particle                       density and spacing, or a function mapping each particle's coordinates to its mass,                       or a scalar for a constant mass over all particles.\ndensity:            Either a function mapping each particle's coordinates to its density,                       or a scalar for a constant density over all particles.\npressure:           Scalar to set the pressure of all particles to this value.                       This is only used by the EntropicallyDampedSPHSystem and                       will be overwritten when using an initial pressure function in the system.\ntlsph:              With the TotalLagrangianSPHSystem, particles need to be placed                       on the boundary of the shape and not one particle radius away, as for fluids.                       When tlsph=true, particles will be placed on the boundary of the shape.\n\nExamples\n\n# Extrude a line in 2D to a plane in 2D\np1 = [0.0, 0.0]\np2 = [1.0, 1.0]\n\ndirection = [-1.0, 1.0]\n\nshape = extrude_geometry((p1, p2); direction, particle_spacing=0.1, n_extrude=4, density=1000.0)\n\n# Extrude a parallelogram in 3D to a parallelepiped in 3D\np1 = [0.0, 0.0, 0.0]\np2 = [0.5, 1.0, 0.0]\np3 = [1.0, 0.2, 0.0]\n\ndirection = [0.0, 0.0, 1.0]\n\nshape = extrude_geometry((p1, p2, p3); direction, particle_spacing=0.1, n_extrude=4, density=1000.0)\n\n# Extrude a 2D shape (here: a disc) to a 3D shape (here: a cylinder)\nshape = SphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, n_layers=3,\n                    sphere_type=RoundSphere(end_angle=pi))\n\ndirection = [0.0, 0.0, 1.0]\n\nshape = extrude_geometry(shape; direction, particle_spacing=0.1, n_extrude=4, density=1000.0)\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in any future releases.\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#TrixiParticles.RectangularShape-Tuple{Any, Any, Any}","page":"Initial Condition and Setups","title":"TrixiParticles.RectangularShape","text":"RectangularShape(particle_spacing, n_particles_per_dimension, min_coordinates;\n                 velocity=zeros(length(n_particles_per_dimension)),\n                 mass=nothing, density=nothing, pressure=0.0,\n                 acceleration=nothing, state_equation=nothing,\n                 tlsph=false, loop_order=nothing)\n\nRectangular shape filled with particles. Returns an InitialCondition.\n\nArguments\n\nparticle_spacing:           Spacing between the particles.\nn_particles_per_dimension:  Tuple containing the number of particles in x, y and z                               (only 3D) direction, respectively.\nmin_coordinates:            Coordinates of the corner in negative coordinate directions.\n\nKeywords\n\nvelocity:       Either a function mapping each particle's coordinates to its velocity,                   or, for a constant fluid velocity, a vector holding this velocity.                   Velocity is constant zero by default.\nmass:           Either nothing (default) to automatically compute particle mass from particle                   density and spacing, or a function mapping each particle's coordinates to its mass,                   or a scalar for a constant mass over all particles.\ndensity:        Either a function mapping each particle's coordinates to its density,                   or a scalar for a constant density over all particles.                   Obligatory when not using a state equation. Cannot be used together with                   state_equation.\npressure:       Scalar to set the pressure of all particles to this value.                   This is only used by the EntropicallyDampedSPHSystem and                   will be overwritten when using an initial pressure function in the system.                   Cannot be used together with hydrostatic pressure gradient.\nacceleration:   In order to initialize particles with a hydrostatic pressure gradient,                   an acceleration vector can be passed. Note that only accelerations                   in one coordinate direction and no diagonal accelerations are supported.                   This will only change the pressure of the particles. When using the                   WeaklyCompressibleSPHSystem, pass a state_equation as well                   to initialize the particles with the corresponding density and mass.                   When using the EntropicallyDampedSPHSystem, the pressure                   will be overwritten when using an initial pressure function in the system.                   This cannot be used together with the pressure keyword argument.\nstate_equation: When calculating a hydrostatic pressure gradient by setting acceleration,                   the state_equation will be used to set the corresponding density.                   Cannot be used together with density.\ntlsph:          With the TotalLagrangianSPHSystem, particles need to be placed                   on the boundary of the shape and not one particle radius away, as for fluids.                   When tlsph=true, particles will be placed on the boundary of the shape.\ncoordinates_perturbation: Add a small random displacement to the particle positions,                             where the amplitude is coordinates_perturbation * particle_spacing.\n\nExamples\n\n# 2D\nrectangular = RectangularShape(particle_spacing, (5, 4), (1.0, 2.0), density=1000.0)\n\n# 2D with hydrostatic pressure gradient.\n# `state_equation` has to be the same as for the WCSPH system.\nstate_equation = StateEquationCole(sound_speed=20.0, exponent=7, reference_density=1000.0)\nrectangular = RectangularShape(particle_spacing, (5, 4), (1.0, 2.0),\n                               acceleration=(0.0, -9.81), state_equation=state_equation)\n\n# 3D\nrectangular = RectangularShape(particle_spacing, (5, 4, 7), (1.0, 2.0, 3.0), density=1000.0)\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#TrixiParticles.RectangularTank","page":"Initial Condition and Setups","title":"TrixiParticles.RectangularTank","text":"RectangularTank(particle_spacing, fluid_size, tank_size, fluid_density;\n                velocity=zeros(length(fluid_size)), fluid_mass=nothing,\n                pressure=0.0,\n                acceleration=nothing, state_equation=nothing,\n                boundary_density=fluid_density,\n                n_layers=1, spacing_ratio=1.0,\n                min_coordinates=zeros(length(fluid_size)),\n                faces=Tuple(trues(2 * length(fluid_size))))\n\nRectangular tank filled with a fluid to set up dam-break-style simulations.\n\nArguments\n\nparticle_spacing:   Spacing between the fluid particles.\nfluid_size:         The dimensions of the fluid as (x, y) (or (x, y, z) in 3D).\ntank_size:          The dimensions of the tank as (x, y) (or (x, y, z) in 3D).\nfluid_density:      The rest density of the fluid. Will only be used as default for                       boundary_density when using a state equation.\n\nKeywords\n\nvelocity:       Either a function mapping each particle's coordinates to its velocity,                   or, for a constant fluid velocity, a vector holding this velocity.                   Velocity is constant zero by default.\nfluid_mass:     Either nothing (default) to automatically compute particle mass from particle                   density and spacing, or a function mapping each particle's coordinates to its mass,                   or a scalar for a constant mass over all particles.\npressure:       Scalar to set the pressure of all particles to this value.                   This is only used by the EntropicallyDampedSPHSystem and                   will be overwritten when using an initial pressure function in the system.                   Cannot be used together with hydrostatic pressure gradient.\nacceleration:   In order to initialize particles with a hydrostatic pressure gradient,                   an acceleration vector can be passed. Note that only accelerations                   in one coordinate direction and no diagonal accelerations are supported.                   This will only change the pressure of the particles. When using the                   WeaklyCompressibleSPHSystem, pass a state_equation as well                   to initialize the particles with the corresponding density and mass.                   When using the EntropicallyDampedSPHSystem, the pressure                   will be overwritten when using an initial pressure function in the system.                   This cannot be used together with the pressure keyword argument.\nstate_equation: When calculating a hydrostatic pressure gradient by setting acceleration,                   the state_equation will be used to set the corresponding density.                   Cannot be used together with density.\nboundary_density:   Density of each boundary particle (by default set to the fluid density)\nn_layers:           Number of boundary layers.\nspacing_ratio:      Ratio of particle_spacing to boundary particle spacing.                       A value of 2 means that the boundary particle spacing will be                       half the fluid particle spacing.\nmin_coordinates:    Coordinates of the corner in negative coordinate directions.\nfaces:              By default all faces are generated. Set faces by passing a                       bit-array of length 4 (2D) or 6 (3D) to generate the faces in the                       normal direction: -x,+x,-y,+y,-z,+z.\n\nFields\n\nfluid::InitialCondition:    InitialCondition for the fluid.\nboundary::InitialCondition: InitialCondition for the boundary.\nfluid_size::Tuple:          Tuple containing the size of the fluid in each dimension after rounding.\ntank_size::Tuple:           Tuple containing the size of the tank in each dimension after rounding.\n\nExamples\n\n# 2D\nsetup = RectangularTank(particle_spacing, (water_width, water_height),\n                        (container_width, container_height), fluid_density,\n                        n_layers=2, spacing_ratio=3)\n\n# 2D with hydrostatic pressure gradient.\n# `state_equation` has to be the same as for the WCSPH system.\nstate_equation = StateEquationCole(sound_speed=10.0, exponent=1, reference_density=1000.0)\nsetup = RectangularTank(particle_spacing, (water_width, water_height),\n                        (container_width, container_height), fluid_density,\n                        acceleration=(0.0, -9.81), state_equation=state_equation)\n\n# 3D\nsetup = RectangularTank(particle_spacing, (water_width, water_height, water_depth),\n                        (container_width, container_height, container_depth), fluid_density,\n                        n_layers=2)\n\nSee also: reset_wall!.\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#TrixiParticles.reset_wall!-Tuple{Any, Any, Any}","page":"Initial Condition and Setups","title":"TrixiParticles.reset_wall!","text":"reset_wall!(rectangular_tank::RectangularTank, reset_faces, positions)\n\nThe selected walls of the tank will be placed at the new positions.\n\nArguments\n\nreset_faces: Boolean tuple of 4 (in 2D) or 6 (in 3D) dimensions, similar to faces in RectangularTank.\npositions: Tuple of new positions\n\nwarning: Warning\nThere are overlapping particles when adjacent walls are moved inwards simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"general/initial_condition/#TrixiParticles.RoundSphere","page":"Initial Condition and Setups","title":"TrixiParticles.RoundSphere","text":"RoundSphere(; start_angle=0.0, end_angle=2π)\n\nConstruct a sphere (or sphere segment) by nesting perfectly round concentric spheres. The resulting ball will be perfectly round, but will not have a regular inner structure.\n\nKeywords\n\nstart_angle: The starting angle of the sphere segment in radians. It determines the                beginning point of the segment. The default is set to 0.0 representing                the positive x-axis.\nend_angle: The ending angle of the sphere segment in radians. It defines the termination              point of the segment. The default is set to 2pi, completing a full sphere.\n\nnote: Usage\nSee SphereShape on how to use this.\n\nwarning: Warning\nThe sphere segment is intended for 2D geometries and hollow spheres. If used for filled spheres or in a 3D context, results may not be accurate.\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#TrixiParticles.VoxelSphere","page":"Initial Condition and Setups","title":"TrixiParticles.VoxelSphere","text":"VoxelSphere()\n\nConstruct a sphere of voxels (where particles are placed in the voxel center) with a regular inner structure but corners on the surface. Essentially, a grid of particles is generated and all particles outside the sphere are removed. The resulting sphere will have a perfect inner structure, but is not perfectly round, as it will have corners (like a sphere in Minecraft).\n\nnote: Usage\nSee SphereShape on how to use this.\n\n\n\n\n\n","category":"type"},{"location":"general/initial_condition/#TrixiParticles.SphereShape-NTuple{4, Any}","page":"Initial Condition and Setups","title":"TrixiParticles.SphereShape","text":"SphereShape(particle_spacing, radius, center_position, density;\n            sphere_type=VoxelSphere(), n_layers=-1, layer_outwards=false,\n            cutout_min=(0.0, 0.0), cutout_max=(0.0, 0.0), tlsph=false,\n            velocity=zeros(length(center_position)), mass=nothing, pressure=0.0)\n\nGenerate a sphere that is either completely filled (by default) or hollow (by passing n_layers).\n\nWith the sphere type VoxelSphere, a sphere of voxels (where particles are placed in the voxel center) with a regular inner structure but corners on the surface is created. Essentially, a grid of particles is generated and all particles outside the sphere are removed. With the sphere type RoundSphere, a perfectly round sphere with an imperfect inner structure is created.\n\nA cuboid can be cut out of the sphere by specifying the two corners in negative and positive coordinate directions as cutout_min and cutout_max.\n\nArguments\n\nparticle_spacing:   Spacing between the particles.\nradius:             Radius of the sphere.\ncenter_position:    The coordinates of the center of the sphere.\ndensity:            Either a function mapping each particle's coordinates to its density,                       or a scalar for a constant density over all particles.\n\nKeywords\n\nsphere_type:    Either VoxelSphere or RoundSphere (see                   explanation above).\nn_layers:       Set to an integer greater than zero to generate a hollow sphere,                   where the shell consists of n_layers layers.\nlayer_outwards: When set to false (by default), radius is the outer radius                   of the sphere. When set to true, radius is the inner radius                   of the sphere. This is only used when n_layers > 0.\ncutout_min:     Corner in negative coordinate directions of a cuboid that is to be                   cut out of the sphere.\ncutout_max:     Corner in positive coordinate directions of a cuboid that is to be                   cut out of the sphere.\ntlsph:          With the TotalLagrangianSPHSystem, particles need to be placed                   on the boundary of the shape and not one particle radius away, as for fluids.                   When tlsph=true, particles will be placed on the boundary of the shape.\nvelocity:   Either a function mapping each particle's coordinates to its velocity,               or, for a constant fluid velocity, a vector holding this velocity.               Velocity is constant zero by default.\nmass:       Either nothing (default) to automatically compute particle mass from particle               density and spacing, or a function mapping each particle's coordinates to its mass,               or a scalar for a constant mass over all particles.\npressure:   Either a function mapping each particle's coordinates to its pressure,               or a scalar for a constant pressure over all particles. This is optional and               only needed when using the EntropicallyDampedSPHSystem.\n\nExamples\n\n# Filled circle with radius 0.5, center in (0.2, 0.4) and a particle spacing of 0.1\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0)\n\n# Same as before, but perfectly round\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, sphere_type=RoundSphere())\n\n# Hollow circle with ~3 layers, outer radius 0.5, center in (0.2, 0.4) and a particle\n# spacing of 0.1.\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, n_layers=3)\n\n# Same as before, but perfectly round\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, n_layers=3, sphere_type=RoundSphere())\n\n# Hollow circle with 3 layers, inner radius 0.5, center in (0.2, 0.4) and a particle spacing\n# of 0.1.\nSphereShape(0.1, 0.5, (0.2, 0.4), 1000.0, n_layers=3, layer_outwards=true)\n\n# Filled circle with radius 0.1, center in (0.0, 0.0), particle spacing 0.1, but the\n# rectangle [0, 1] x [-0.2, 0.2] is cut out.\nSphereShape(0.1, 1.0, (0.0, 0.0), 1000.0, cutout_min=(0.0, -0.2), cutout_max=(1.0, 0.2))\n\n# Filled 3D sphere with radius 0.5, center in (0.2, 0.4, 0.3) and a particle spacing of 0.1\nSphereShape(0.1, 0.5, (0.2, 0.4, 0.3), 1000.0)\n\n# Same as before, but perfectly round\nSphereShape(0.1, 0.5, (0.2, 0.4, 0.3), 1000.0, sphere_type=RoundSphere())\n\n\n\n\n\n","category":"method"},{"location":"systems/weakly_compressible_sph/#wcsph","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Weakly compressible SPH as introduced by Monaghan (1994). This formulation relies on a stiff equation of state that generates large pressure changes for small density variations.","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.WeaklyCompressibleSPHSystem","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.WeaklyCompressibleSPHSystem","text":"WeaklyCompressibleSPHSystem(initial_condition,\n                            density_calculator, state_equation,\n                            smoothing_kernel, smoothing_length;\n                            acceleration=ntuple(_ -> 0.0, NDIMS),\n                            viscosity=nothing, density_diffusion=nothing,\n                            pressure_acceleration=nothing,\n                            transport_velocity=nothing,\n                            buffer_size=nothing,\n                            correction=nothing, source_terms=nothing,\n                            surface_tension=nothing, surface_normal_method=nothing,\n                            reference_particle_spacing=0.0))\n\nSystem for particles of a fluid. The weakly compressible SPH (WCSPH) scheme is used, wherein a stiff equation of state generates large pressure changes for small density variations. See Weakly Compressible SPH for more details on the method.\n\nArguments\n\ninitial_condition:  InitialCondition representing the system's particles.\ndensity_calculator: Density calculator for the system.                       See ContinuityDensity and SummationDensity.\nstate_equation:     Equation of state for the system. See StateEquationCole.\nsmoothing_kernel:   Smoothing kernel to be used for this system.                       See Smoothing Kernels.\nsmoothing_length:   Smoothing length to be used for this system.                       See Smoothing Kernels.\n\nKeyword Arguments\n\nacceleration:               Acceleration vector for the system. (default: zero vector)\nviscosity:                  Viscosity model for this system (default: no viscosity).                               See ArtificialViscosityMonaghan or ViscosityAdami.\ndensity_diffusion:          Density diffusion terms for this system. See DensityDiffusion.\npressure_acceleration:      Pressure acceleration formulation for this system.                               By default, the correct formulation is chosen based on the                               density calculator and the correction method.                               To use Tensile Instability Control, pass                               tensile_instability_control here.\ntransport_velocity:         Transport Velocity Formulation (TVF).                               Default is no TVF.\nbuffer_size:                Number of buffer particles.                               This is needed when simulating with OpenBoundarySPHSystem.\ncorrection:                 Correction method used for this system. (default: no correction, see Corrections)\nsource_terms:               Additional source terms for this system. Has to be either nothing                               (by default), or a function of (coords, velocity, density, pressure, t)                               (which are the quantities of a single particle), returning a Tuple                               or SVector that is to be added to the acceleration of that particle.                               See, for example, SourceTermDamping.                               Note that these source terms will not be used in the calculation of the                               boundary pressure when using a boundary with                               BoundaryModelDummyParticles and AdamiPressureExtrapolation.                               The keyword argument acceleration should be used instead for                               gravity-like source terms.\nsurface_tension:            Surface tension model used for this SPH system. (default: no surface tension)\nsurface_normal_method:      The surface normal method to be used for this SPH system.                               (default: no surface normal method or ColorfieldSurfaceNormal() if a surface_tension model is used)\nreference_particle_spacing: The reference particle spacing used for weighting values at the boundary,                               which currently is only needed when using surface tension.\ncolor_value:                The value used to initialize the color of particles in the system.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#equation_of_state","page":"Weakly Compressible SPH (Fluid)","title":"Equation of State","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The equation of state is used to relate fluid density to pressure and thus allow an explicit simulation of the WCSPH system. The equation in the following formulation was introduced by Cole (1948) (pp. 39 and 43). The pressure p is calculated as","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"    p = B left(left(fracrhorho_0right)^gamma - 1right) + p_textbackground","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"where rho denotes the density, rho_0 the reference density, and p_textbackground the background pressure, which is set to zero when applied to free-surface flows (Adami et al., 2012).","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The bulk modulus, B =  fracrho_0 c^2gamma, is calculated from the artificial speed of sound c and the isentropic exponent gamma.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"An ideal gas equation of state with a linear relationship between pressure and density can be obtained by choosing exponent=1, i.e.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"    p = B left( fracrhorho_0 -1 right) = c^2(rho - rho_0)","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"For higher Reynolds numbers, exponent=7 is recommended, whereas at lower Reynolds numbers exponent=1 yields more accurate pressure estimates since pressure and density are proportional (see Morris, 1997).","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"When using SummationDensity (or DensityReinitializationCallback) and free surfaces, initializing particles with equal spacing will cause underestimated density and therefore strong attractive forces between particles at the free surface. Setting clip_negative_pressure=true can avoid this.","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.StateEquationCole","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.StateEquationCole","text":"StateEquationCole(; sound_speed, reference_density, exponent,\n                  background_pressure=0.0, clip_negative_pressure=false)\n\nEquation of state to describe the relationship between pressure and density of water up to high pressures.\n\nKeywords\n\nsound_speed:             Artificial speed of sound.\nreference_density:       Reference density of the fluid.\nexponent:                A value of 7 is usually used for most simulations.\nbackground_pressure=0.0: Background pressure.\nclip_negative_pressure=false: Negative pressure values are clipped to 0, which prevents spurious surface tension with SummationDensity but allows unphysical rarefaction of the fluid.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.StateEquationIdealGas","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.StateEquationIdealGas","text":"StateEquationIdealGas( ;sound_speed, reference_density, gamma, background_pressure=0.0,\n                       clip_negative_pressure=false)\n\nEquation of state to describe the relationship between pressure and density of a gas using the Ideal Gas Law.\n\nKeywords\n\nsound_speed                 : Artificial speed of sound.\nreference_density           : Reference density of the fluid.\ngamma                       : Heat-capacity ratio\nbackground_pressure=0.0     : Background pressure.\nclip_negative_pressure=false: Negative pressure values are clipped to 0, which prevents spurious surface tension with SummationDensity but allows unphysical rarefaction of the fluid.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#density_diffusion","page":"Weakly Compressible SPH (Fluid)","title":"Density Diffusion","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Density diffusion can be used with ContinuityDensity to remove the noise in the pressure field. It is highly recommended to use density diffusion when using WCSPH.","category":"page"},{"location":"systems/weakly_compressible_sph/#Formulation","page":"Weakly Compressible SPH (Fluid)","title":"Formulation","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"All density diffusion terms extend the continuity equation (see ContinuityDensity) by an additional term","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"fracmathrmdrho_amathrmdt = sum_b m_b v_ab cdot nabla W_ab\n    + delta h c sum_b V_b psi_ab cdot nabla W_ab","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"where V_b = m_b  rho_b is the volume of particle b and psi_ab depends on the density diffusion method (see DensityDiffusion for available terms). Also, rho_a denotes the density of particle a and r_ab = r_a - r_b is the difference of the coordinates, v_ab = v_a - v_b of the velocities of particles a and b.","category":"page"},{"location":"systems/weakly_compressible_sph/#Numerical-Results","page":"Weakly Compressible SPH (Fluid)","title":"Numerical Results","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"All density diffusion terms remove numerical noise in the pressure field and produce more accurate results than weakly commpressible SPH without density diffusion. This can be demonstrated with dam break examples in 2D and 3D. Here, δ = 01 has been used for all terms. Note that, due to added stability, the adaptive time integration method that was used here can choose higher time steps in the simulations with density diffusion. For the cheap DensityDiffusionMolteniColagrossi, this results in reduced runtime.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"<figure>\n  <img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/44124897/01289e3b-98ce-4b2d-8151-cd20782d5823\" alt=\"density_diffusion_2d\"/>\n  <figcaption>Dam break in 2D with different density diffusion terms</figcaption>\n</figure>","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"<figure>\n  <img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/44124897/63a05b2a-6c37-468e-b895-15ab142a4eba\" alt=\"density_diffusion_3d\"/>\n  <figcaption>Dam break in 3D with different density diffusion terms</figcaption>\n</figure>","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The simpler terms DensityDiffusionMolteniColagrossi and DensityDiffusionFerrari do not solve the hydrostatic problem and lead to incorrect solutions in long-running steady-state hydrostatic simulations with free surfaces (Antuono et al., 2012). This can be seen when running the simple rectangular tank example until t = 40 (again using δ = 01):","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"<figure>\n  <img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/44124897/440debc9-6051-4a3b-aa9c-02a6b32fccf3\" alt=\"density_diffusion_tank\"/>\n  <figcaption>Tank in rest under gravity in 3D with different density diffusion terms</figcaption>\n</figure>","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"DensityDiffusionAntuono adds a correction term to solve this problem, but this term is very expensive and adds about 40–50% of computational cost.","category":"page"},{"location":"systems/weakly_compressible_sph/#API","page":"Weakly Compressible SPH (Fluid)","title":"API","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusion","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusion","text":"DensityDiffusion\n\nAn abstract supertype of all density diffusion formulations.\n\nCurrently, the following formulations are available:\n\nFormulation Suitable for Steady-State Simulations Low Computational Cost\nDensityDiffusionMolteniColagrossi ❌ ✅\nDensityDiffusionFerrari ❌ ✅\nDensityDiffusionAntuono ✅ ❌\n\nSee Density Diffusion for a comparison and more details.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusionAntuono","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusionAntuono","text":"DensityDiffusionAntuono(initial_condition; delta)\n\nThe commonly used density diffusion terms by Antuono (2010), also referred to as δ-SPH. The density diffusion term by Molteni (2009) is extended by a second term, which is nicely written down by Antuono (2012).\n\nThe term psi_ab in the continuity equation in DensityDiffusion is defined by\n\npsi_ab = 2left(rho_a - rho_b - frac12big(nablarho^L_a + nablarho^L_bbig) cdot r_abright)\n    fracr_abVert r_ab Vert^2\n\nwhere rho_a and rho_b denote the densities of particles a and b respectively and r_ab = r_a - r_b is the difference of the coordinates of particles a and b. The symbol nablarho^L_a denotes the renormalized density gradient defined as\n\nnablarho^L_a = -sum_b (rho_a - rho_b) V_b L_a nabla W_ab\n\nwith\n\nL_a = left( -sum_b V_b r_ab otimes nabla W_ab right)^-1 in R^d times d\n\nwhere d is the number of dimensions.\n\nSee DensityDiffusion for an overview and comparison of implemented density diffusion terms.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusionFerrari","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusionFerrari","text":"DensityDiffusionFerrari()\n\nA density diffusion term by Ferrari (2009).\n\nThe term psi_ab in the continuity equation in DensityDiffusion is defined by\n\npsi_ab = fracrho_a - rho_bh_a + h_b fracr_abVert r_ab Vert\n\nwhere rho_a and rho_b denote the densities of particles a and b respectively, r_ab = r_a - r_b is the difference of the coordinates of particles a and b and h_a and h_b are the smoothing lengths of particles a and b respectively.\n\nSee DensityDiffusion for an overview and comparison of implemented density diffusion terms.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.DensityDiffusionMolteniColagrossi","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.DensityDiffusionMolteniColagrossi","text":"DensityDiffusionMolteniColagrossi(; delta)\n\nThe commonly used density diffusion term by Molteni (2009).\n\nThe term psi_ab in the continuity equation in DensityDiffusion is defined by\n\npsi_ab = 2(rho_a - rho_b) fracr_abVert r_ab Vert^2\n\nwhere rho_a and rho_b denote the densities of particles a and b respectively and r_ab = r_a - r_b is the difference of the coordinates of particles a and b.\n\nSee DensityDiffusion for an overview and comparison of implemented density diffusion terms.\n\n\n\n\n\n","category":"type"},{"location":"systems/weakly_compressible_sph/#shifting","page":"Weakly Compressible SPH (Fluid)","title":"Particle Shifting Technique","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The Particle Shifting Technique (PST) is used to correct tensile instability in regions of low pressure, as observed in viscous flow around an object. Without PST, tensile instability causes non-physical separation of the fluid from the object, introducing void regions behind the object.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"At lower resolutions, PST alone can be effective to correct a viscous flow around a cylinder, as shown in this figure. (Image: particle_shifting) At higher resolutions, PST alone is not effective anymore; see the figure in Tensile Instability Control. We recommend using PST and Tensile Instability Control together in such simulations.","category":"page"},{"location":"systems/weakly_compressible_sph/#Mathematical-formulation","page":"Weakly Compressible SPH (Fluid)","title":"Mathematical formulation","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"We use the following formulation by Sun et al. (2018). After each time step, a correction term delta r_a is added to the position r_a of particle a, which is given by","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"delta r_a = -4 Delta t  v_textmax h\n    sum_b left( 1 + R left( fracW_abW(Delta x_a) right)^n right) nabla W_ab\n    fracm_brho_a + rho_b","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"where:","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Delta t is the time step,\nv_textmax is the maximum velocity over all particles,\nh is the smoothing length,\nR and n are constants, which are set to 02 and 4 respectively,\nW(Delta x_a) is the smoothing kernel of the particle size of particle a, which can be interpreted as the target particle spacing that we want to achieve.\nnabla W_ab is the gradient of the smoothing kernel,\nm_b is the mass of particle b,\nrho_a rho_b is the density of particles a and b, respectively.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Note that we replaced textCFL cdot textMa by Delta t cdot v_textmax  h, as explained in Sun2018 on page 29, right above Equation 9.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The delta-SPH method (WCSPH with density diffusion) together with this formulation of PST is commonly referred to as delta^+-SPH.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The Particle Shifting Technique can be applied in form of the ParticleShiftingCallback.","category":"page"},{"location":"systems/weakly_compressible_sph/#tic","page":"Weakly Compressible SPH (Fluid)","title":"Tensile Instability Control","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Tensile Instability Control (TIC) is a pressure acceleration formulation to correct tensile instability in regions of low pressure, as observed in viscous flow around an object. The technique was introduced by Sun et al. (2018). The formulation is described in Section 2.1 of this paper. It can be used in combination with the Particle Shifting Technique (PST) to effectively prevent non-physical separation of the fluid from the object.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"As can be seen in the following figure, TIC alone can cause instabilities and does not improve the simulation. PST alone can mostly prevent separation at lower resolutions. A small void region is still visible, but quickly disappears. The combination of PST and TIC prevents separation effectively. (Image: low_res)","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"At higher resolutions, PST alone is not effective to prevent separation, as can be seen in the next figure. Only the combination of PST and TIC is able to produce physical results. (Image: high_res)","category":"page"},{"location":"systems/weakly_compressible_sph/#Mathematical-formulation-2","page":"Weakly Compressible SPH (Fluid)","title":"Mathematical formulation","text":"","category":"section"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The force that particle a experiences from particle b due to pressure is given by","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"f_ab = -m_a m_b fracp_a + p_brho_a rho_b nabla W_ab","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"for the WCSPH method with ContinuityDensity.","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"The TIC formulation changes this force to","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"f_ab = -m_a m_b fracp_a + p_brho_a rho_b nabla W_ab","category":"page"},{"location":"systems/weakly_compressible_sph/","page":"Weakly Compressible SPH (Fluid)","title":"Weakly Compressible SPH (Fluid)","text":"Note that this formulation is asymmetric and sacrifices conservation of linear and angular momentum.","category":"page"},{"location":"systems/weakly_compressible_sph/#TrixiParticles.tensile_instability_control","page":"Weakly Compressible SPH (Fluid)","title":"TrixiParticles.tensile_instability_control","text":"tensile_instability_control\n\nPressure acceleration formulation to prevent tensile instability by Sun et al. (2018).\n\nThis formulation can be passed as keyword argument pressure_acceleration to the WeaklyCompressibleSPHSystem constructor. See Tensile Instability Control for more information on this technique.\n\nwarning: Warning\nTensile Instability Control needs to be disabled close to the free surface and therefore requires a free surface detection method. This is not yet implemented. This technique cannot be used in a free surface simulation.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/tut_dam_break/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_dam_break/","page":"Example file","title":"Example file","text":"# 2D dam break simulation based on\n#\n# S. Marrone, M. Antuono, A. Colagrossi, G. Colicchio, D. le Touzé, G. Graziani.\n# \"δ-SPH model for simulating violent impact flows\".\n# In: Computer Methods in Applied Mechanics and Engineering, Volume 200, Issues 13–16 (2011), pages 1526–1542.\n# https://doi.org/10.1016/J.CMA.2010.12.016\n\nusing TrixiParticles\nusing OrdinaryDiffEq\n\n# Size parameters\nH = 0.6\nW = 2 * H\n\n# ==========================================================================================\n# ==== Resolution\nfluid_particle_spacing = H / 40\n\n# Change spacing ratio to 3 and boundary layers to 1 when using Monaghan-Kajtar boundary model\nboundary_layers = 4\nspacing_ratio = 1\n\nboundary_particle_spacing = fluid_particle_spacing / spacing_ratio\n\n# ==========================================================================================\n# ==== Experiment Setup\ngravity = 9.81\n\ntspan = (0.0, 5.7 / sqrt(gravity))\n\n# Boundary geometry and initial fluid particle positions\ninitial_fluid_size = (W, H)\ntank_size = (floor(5.366 * H / boundary_particle_spacing) * boundary_particle_spacing, 4.0)\n\nfluid_density = 1000.0\nsound_speed = 20 * sqrt(gravity * H)\nstate_equation = StateEquationCole(; sound_speed, reference_density=fluid_density,\n                                   exponent=1, clip_negative_pressure=false)\n\ntank = RectangularTank(fluid_particle_spacing, initial_fluid_size, tank_size, fluid_density,\n                       n_layers=boundary_layers, spacing_ratio=spacing_ratio,\n                       acceleration=(0.0, -gravity), state_equation=state_equation)\n\n# ==========================================================================================\n# ==== Fluid\nsmoothing_length = 1.75 * fluid_particle_spacing\nsmoothing_kernel = WendlandC2Kernel{2}()\n\nfluid_density_calculator = ContinuityDensity()\nalpha = 0.02\nviscosity_fluid = ArtificialViscosityMonaghan(alpha=alpha, beta=0.0)\n# A typical formula to convert Artificial viscosity to a\n# kinematic viscosity is provided by Monaghan as\n# nu = alpha * smoothing_length * sound_speed/8\n\n# Alternatively a kinematic viscosity for water can be set\n# nu = 1.0e-6\n\n# This allows the use of a physical viscosity model like:\n# viscosity_fluid = ViscosityAdami(nu=nu)\n# or with additional dissipation through a Smagorinsky model\n# viscosity_fluid = ViscosityAdamiSGS(nu=nu)\n# For more details see the documentation \"Viscosity model overview\".\n\n# Alternatively the density diffusion model by Molteni & Colagrossi can be used,\n# which will run faster.\n# density_diffusion = DensityDiffusionMolteniColagrossi(delta=0.1)\ndensity_diffusion = DensityDiffusionAntuono(tank.fluid, delta=0.1)\n\nfluid_system = WeaklyCompressibleSPHSystem(tank.fluid, fluid_density_calculator,\n                                           state_equation, smoothing_kernel,\n                                           smoothing_length, viscosity=viscosity_fluid,\n                                           density_diffusion=density_diffusion,\n                                           acceleration=(0.0, -gravity), correction=nothing,\n                                           surface_tension=nothing,\n                                           reference_particle_spacing=0)\n\n# ==========================================================================================\n# ==== Boundary\nboundary_density_calculator = AdamiPressureExtrapolation()\nviscosity_wall = nothing\n# For a no-slip condition the corresponding wall viscosity without SGS can be set\n# viscosity_wall = ViscosityAdami(nu=nu)\n# viscosity_wall = ViscosityMorris(nu=nu)\nboundary_model = BoundaryModelDummyParticles(tank.boundary.density, tank.boundary.mass,\n                                             state_equation=state_equation,\n                                             boundary_density_calculator,\n                                             smoothing_kernel, smoothing_length,\n                                             correction=nothing,\n                                             reference_particle_spacing=0,\n                                             viscosity=viscosity_wall)\n\nboundary_system = BoundarySPHSystem(tank.boundary, boundary_model, adhesion_coefficient=0.0)\n\n# ==========================================================================================\n# ==== Simulation\n# `nothing` will automatically choose the best update strategy. This is only to be able\n# to change this with `trixi_include`.\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=GridNeighborhoodSearch{2}(update_strategy=nothing),\n                          parallelization_backend=PolyesterBackend())\node = semidiscretize(semi, tspan)\n\ninfo_callback = InfoCallback(interval=100)\n\nsolution_prefix = \"\"\nsaving_callback = SolutionSavingCallback(dt=0.02, prefix=solution_prefix)\n\n# Save at certain timepoints which allows comparison to the results of Marrone et al.,\n# i.e. (1.5, 2.36, 3.0, 5.7, 6.45).\n# Please note that the images in Marrone et al. are obtained at a particle_spacing = H/320,\n# which takes between 2 and 4 hours.\nsaving_paper = SolutionSavingCallback(save_times=[0.0, 0.371, 0.584, 0.743, 1.411, 1.597],\n                                      prefix=\"marrone_times\")\n\n# This can be overwritten with `trixi_include`\nextra_callback = nothing\n\nuse_reinit = false\ndensity_reinit_cb = use_reinit ?\n                    DensityReinitializationCallback(semi.systems[1], interval=10) :\n                    nothing\nstepsize_callback = StepsizeCallback(cfl=0.9)\n\ncallbacks = CallbackSet(info_callback, saving_callback, stepsize_callback, extra_callback,\n                        density_reinit_cb, saving_paper)\n\nsol = solve(ode, CarpenterKennedy2N54(williamson_condition=false),\n            dt=1.0, # This is overwritten by the stepsize callback\n            save_everystep=false, callback=callbacks);\n\n","category":"page"},{"location":"general/neighborhood_search/#Neighborhood-Search","page":"Neighborhood Search","title":"Neighborhood Search","text":"","category":"section"},{"location":"general/neighborhood_search/","page":"Neighborhood Search","title":"Neighborhood Search","text":"The neighborhood search is the most essential component for performance. We provide several implementations in the package PointNeighbors.jl. See the docs of this package for an overview and a comparison of different implementations.","category":"page"},{"location":"general/neighborhood_search/","page":"Neighborhood Search","title":"Neighborhood Search","text":"note: Usage\nTo run a simulation with a neighborhood search implementation, pass a template of the neighborhood search to the constructor of the Semidiscretization. A template is just an empty neighborhood search with search radius 0.0. See copy_neighborhood_search and the examples below for more details.semi = Semidiscretization(system1, system2,\n                          neighborhood_search=PrecomputedNeighborhoodSearch{2}())The keyword argument periodic_box in the neighborhood search constructors can be used to define a periodic domain. See the PointNeighbors.jl docs for more details.periodic_box = PeriodicBox(min_corner=[0.0, -0.25], max_corner=[1.0, 0.75])\nsemi = Semidiscretization(system1, system2,\n                          neighborhood_search=GridNeighborhoodSearch{2}(; periodic_box))","category":"page"},{"location":"tutorials/tut_falling/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_falling/","page":"Example file","title":"Example file","text":"using TrixiParticles\nusing OrdinaryDiffEq\n\n# ==========================================================================================\n# ==== Resolution\nfluid_particle_spacing = 0.02\nsolid_particle_spacing = fluid_particle_spacing\n\n# Change spacing ratio to 3 and boundary layers to 1 when using Monaghan-Kajtar boundary model\nboundary_layers = 3\nspacing_ratio = 1\n\n# ==========================================================================================\n# ==== Experiment Setup\ngravity = 9.81\ntspan = (0.0, 1.0)\n\n# Boundary geometry and initial fluid particle positions\ninitial_fluid_size = (2.0, 0.9)\ntank_size = (2.0, 1.0)\n\nfluid_density = 1000.0\nsound_speed = 10 * sqrt(gravity * initial_fluid_size[2])\nstate_equation = StateEquationCole(; sound_speed, reference_density=fluid_density,\n                                   exponent=1)\n\ntank = RectangularTank(fluid_particle_spacing, initial_fluid_size, tank_size, fluid_density,\n                       n_layers=boundary_layers, spacing_ratio=spacing_ratio,\n                       faces=(true, true, true, false),\n                       acceleration=(0.0, -gravity), state_equation=state_equation)\n\nsphere1_radius = 0.3\nsphere2_radius = 0.2\nsphere1_density = 500.0\nsphere2_density = 1100.0\n\n# Young's modulus and Poisson ratio\nsphere1_E = 7e4\nsphere2_E = 1e5\nnu = 0.0\n\nsphere1_center = (0.5, 1.6)\nsphere2_center = (1.5, 1.6)\nsphere1 = SphereShape(solid_particle_spacing, sphere1_radius, sphere1_center,\n                      sphere1_density, sphere_type=VoxelSphere())\nsphere2 = SphereShape(solid_particle_spacing, sphere2_radius, sphere2_center,\n                      sphere2_density, sphere_type=VoxelSphere())\n\n# ==========================================================================================\n# ==== Fluid\nfluid_smoothing_length = 1.5 * fluid_particle_spacing\nfluid_smoothing_kernel = WendlandC2Kernel{2}()\n\nfluid_density_calculator = ContinuityDensity()\nviscosity = ArtificialViscosityMonaghan(alpha=0.02, beta=0.0)\ndensity_diffusion = DensityDiffusionMolteniColagrossi(delta=0.1)\n\nfluid_system = WeaklyCompressibleSPHSystem(tank.fluid, fluid_density_calculator,\n                                           state_equation, fluid_smoothing_kernel,\n                                           fluid_smoothing_length, viscosity=viscosity,\n                                           density_diffusion=density_diffusion,\n                                           acceleration=(0.0, -gravity))\n\n# ==========================================================================================\n# ==== Boundary\nboundary_density_calculator = BernoulliPressureExtrapolation()\nboundary_model = BoundaryModelDummyParticles(tank.boundary.density, tank.boundary.mass,\n                                             state_equation=state_equation,\n                                             boundary_density_calculator,\n                                             fluid_smoothing_kernel, fluid_smoothing_length)\n\nboundary_system = BoundarySPHSystem(tank.boundary, boundary_model)\n\n# ==========================================================================================\n# ==== Solid\nsolid_smoothing_length = sqrt(2) * solid_particle_spacing\nsolid_smoothing_kernel = WendlandC2Kernel{2}()\n\n# For the FSI we need the hydrodynamic masses and densities in the solid boundary model\nhydrodynamic_densites_1 = fluid_density * ones(size(sphere1.density))\nhydrodynamic_masses_1 = hydrodynamic_densites_1 * solid_particle_spacing^ndims(fluid_system)\n\nsolid_boundary_model_1 = BoundaryModelDummyParticles(hydrodynamic_densites_1,\n                                                     hydrodynamic_masses_1,\n                                                     state_equation=state_equation,\n                                                     boundary_density_calculator,\n                                                     fluid_smoothing_kernel,\n                                                     fluid_smoothing_length)\n\nhydrodynamic_densites_2 = fluid_density * ones(size(sphere2.density))\nhydrodynamic_masses_2 = hydrodynamic_densites_2 * solid_particle_spacing^ndims(fluid_system)\n\nsolid_boundary_model_2 = BoundaryModelDummyParticles(hydrodynamic_densites_2,\n                                                     hydrodynamic_masses_2,\n                                                     state_equation=state_equation,\n                                                     boundary_density_calculator,\n                                                     fluid_smoothing_kernel,\n                                                     fluid_smoothing_length)\n\nsolid_system_1 = TotalLagrangianSPHSystem(sphere1,\n                                          solid_smoothing_kernel, solid_smoothing_length,\n                                          sphere1_E, nu,\n                                          acceleration=(0.0, -gravity),\n                                          boundary_model=solid_boundary_model_1,\n                                          penalty_force=PenaltyForceGanzenmueller(alpha=0.3))\n\nsolid_system_2 = TotalLagrangianSPHSystem(sphere2,\n                                          solid_smoothing_kernel, solid_smoothing_length,\n                                          sphere2_E, nu,\n                                          acceleration=(0.0, -gravity),\n                                          boundary_model=solid_boundary_model_2,\n                                          penalty_force=PenaltyForceGanzenmueller(alpha=0.3))\n\n# ==========================================================================================\n# ==== Simulation\nsemi = Semidiscretization(fluid_system, boundary_system, solid_system_1, solid_system_2)\node = semidiscretize(semi, tspan)\n\ninfo_callback = InfoCallback(interval=10)\nsaving_callback = SolutionSavingCallback(dt=0.02, output_directory=\"out\", prefix=\"\",\n                                         write_meta_data=true)\n\ncallbacks = CallbackSet(info_callback, saving_callback)\n\n# Use a Runge-Kutta method with automatic (error based) time step size control.\nsol = solve(ode, RDPK3SpFSAL49(),\n            abstol=1e-6, # Default abstol is 1e-6\n            reltol=1e-3, # Default reltol is 1e-3\n            save_everystep=false, callback=callbacks);\n\n","category":"page"},{"location":"tutorials/tut_beam/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials/tut_beam/","page":"Example file","title":"Example file","text":"using TrixiParticles\nusing OrdinaryDiffEq\n\n# ==========================================================================================\n# ==== Resolution\nn_particles_y = 5\n\n# ==========================================================================================\n# ==== Experiment Setup\ngravity = 2.0\ntspan = (0.0, 5.0)\n\nelastic_beam = (length=0.35, thickness=0.02)\nmaterial = (density=1000.0, E=1.4e6, nu=0.4)\nclamp_radius = 0.05\n\n# The structure starts at the position of the first particle and ends\n# at the position of the last particle.\nparticle_spacing = elastic_beam.thickness / (n_particles_y - 1)\n\n# Add particle_spacing/2 to the clamp_radius to ensure that particles are also placed on the radius\nfixed_particles = SphereShape(particle_spacing, clamp_radius + particle_spacing / 2,\n                              (0.0, elastic_beam.thickness / 2), material.density,\n                              cutout_min=(0.0, 0.0),\n                              cutout_max=(clamp_radius, elastic_beam.thickness),\n                              tlsph=true)\n\nn_particles_clamp_x = round(Int, clamp_radius / particle_spacing)\n\n# Beam and clamped particles\nn_particles_per_dimension = (round(Int, elastic_beam.length / particle_spacing) +\n                             n_particles_clamp_x + 1, n_particles_y)\n\n# Note that the `RectangularShape` puts the first particle half a particle spacing away\n# from the boundary, which is correct for fluids, but not for solids.\n# We therefore need to pass `tlsph=true`.\nbeam = RectangularShape(particle_spacing, n_particles_per_dimension,\n                        (0.0, 0.0), density=material.density, tlsph=true)\n\nsolid = union(beam, fixed_particles)\n\n# ==========================================================================================\n# ==== Solid\nsmoothing_length = sqrt(2) * particle_spacing\nsmoothing_kernel = WendlandC2Kernel{2}()\n\nsolid_system = TotalLagrangianSPHSystem(solid, smoothing_kernel, smoothing_length,\n                                        material.E, material.nu,\n                                        n_fixed_particles=nparticles(fixed_particles),\n                                        acceleration=(0.0, -gravity),\n                                        penalty_force=nothing)\n\n# ==========================================================================================\n# ==== Simulation\nsemi = Semidiscretization(solid_system,\n                          neighborhood_search=PrecomputedNeighborhoodSearch{2}(),\n                          parallelization_backend=PolyesterBackend())\node = semidiscretize(semi, tspan)\n\ninfo_callback = InfoCallback(interval=1000)\n\n# Track the position of the particle in the middle of the tip of the beam.\nmiddle_particle_id = Int(n_particles_per_dimension[1] * (n_particles_per_dimension[2] + 1) /\n                         2)\n\n# Make these constants because global variables in the functions below are slow\nconst STARTPOSITION_X = beam.coordinates[1, middle_particle_id]\nconst STARTPOSITION_Y = beam.coordinates[2, middle_particle_id]\n\nfunction deflection_x(system, data, t)\n    return data.coordinates[1, middle_particle_id] - STARTPOSITION_X\nend\n\nfunction deflection_y(system, data, t)\n    return data.coordinates[2, middle_particle_id] - STARTPOSITION_Y\nend\n\nsaving_callback = SolutionSavingCallback(dt=0.02, prefix=\"\",\n                                         deflection_x=deflection_x,\n                                         deflection_y=deflection_y)\n\ncallbacks = CallbackSet(info_callback, saving_callback)\n\n# Use a Runge-Kutta method with automatic (error based) time step size control\nsol = solve(ode, RDPK3SpFSAL49(), save_everystep=false, callback=callbacks);\n\n","category":"page"},{"location":"general/density_calculators/#density_calculator","page":"Density Calculators","title":"Density Calculators","text":"","category":"section"},{"location":"general/density_calculators/#TrixiParticles.ContinuityDensity","page":"Density Calculators","title":"TrixiParticles.ContinuityDensity","text":"ContinuityDensity()\n\nDensity calculator to integrate the density from the continuity equation\n\nfracmathrmdrho_amathrmdt = sum_b m_b v_ab cdot nabla_r_a W(Vert r_a - r_b Vert h)\n\nwhere rho_a denotes the density of particle a and r_ab = r_a - r_b is the difference of the coordinates, v_ab = v_a - v_b of the velocities of particles a and b.\n\n\n\n\n\n","category":"type"},{"location":"general/density_calculators/#TrixiParticles.SummationDensity","page":"Density Calculators","title":"TrixiParticles.SummationDensity","text":"SummationDensity()\n\nDensity calculator to use the summation formula\n\nrho(r) = sum_b m_b W(Vert r - r_b Vert h)\n\nfor the density estimation, where r_b denotes the coordinates and m_b the mass of particle b.\n\n\n\n\n\n","category":"type"},{"location":"general/semidiscretization/#Semidiscretization","page":"Semidiscretization","title":"Semidiscretization","text":"","category":"section"},{"location":"general/semidiscretization/#TrixiParticles.Semidiscretization","page":"Semidiscretization","title":"TrixiParticles.Semidiscretization","text":"Semidiscretization(systems...; neighborhood_search=GridNeighborhoodSearch{NDIMS}())\n\nThe semidiscretization couples the passed systems to one simulation.\n\nArguments\n\nsystems: Systems to be coupled in this semidiscretization\n\nKeywords\n\nneighborhood_search:    The neighborhood search to be used in the simulation.                           By default, the GridNeighborhoodSearch is used.                           Use nothing to loop over all particles (no neighborhood search).                           To use other neighborhood search implementations, pass a template                           of a neighborhood search. See copy_neighborhood_search                           and the examples below for more details.                           To use a periodic domain, pass a PeriodicBox to the                           neighborhood search.\nthreaded_nhs_update=true:   Can be used to deactivate thread parallelization in the neighborhood search update.                               This can be one of the largest sources of variations between simulations                               with different thread numbers due to particle ordering changes.\n\nExamples\n\nsemi = Semidiscretization(fluid_system, boundary_system)\n\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=GridNeighborhoodSearch{2}(update_strategy=SerialUpdate()))\n\nperiodic_box = PeriodicBox(min_corner = [0.0, 0.0], max_corner = [1.0, 1.0])\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=GridNeighborhoodSearch{2}(; periodic_box))\n\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=PrecomputedNeighborhoodSearch{2}())\n\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=nothing)\n\n\n\n\n\n","category":"type"},{"location":"general/semidiscretization/#TrixiParticles.SourceTermDamping","page":"Semidiscretization","title":"TrixiParticles.SourceTermDamping","text":"SourceTermDamping(; damping_coefficient)\n\nA source term to be used when a damping step is required before running a full simulation. The term -c cdot v_a is added to the acceleration fracmathrmdv_amathrmdt of particle a, where c is the damping coefficient and v_a is the velocity of particle a.\n\nKeywords\n\ndamping_coefficient:    The coefficient d above. A higher coefficient means more                           damping. A coefficient of 1e-4 is a good starting point for                           damping a fluid at rest.\n\nExamples\n\nsource_terms = SourceTermDamping(; damping_coefficient=1e-4)\n\n\n\n\n\n","category":"type"},{"location":"general/semidiscretization/#TrixiParticles.restart_with!-Tuple{Any, Any}","page":"Semidiscretization","title":"TrixiParticles.restart_with!","text":"restart_with!(semi, sol)\n\nSet the initial coordinates and velocities of all systems in semi to the final values in the solution sol. semidiscretize has to be called again afterwards, or another Semidiscretization can be created with the updated systems.\n\nArguments\n\nsemi:   The semidiscretization\nsol:    The ODESolution returned by solve of OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"general/semidiscretization/#TrixiParticles.semidiscretize-Tuple{Any, Any}","page":"Semidiscretization","title":"TrixiParticles.semidiscretize","text":"semidiscretize(semi, tspan; reset_threads=true)\n\nCreate an ODEProblem from the semidiscretization with the specified tspan.\n\nArguments\n\nsemi: A Semidiscretization holding the systems involved in the simulation.\ntspan: The time span over which the simulation will be run.\n\nKeywords\n\nreset_threads: A boolean flag to reset Polyester.jl threads before the simulation (default: true). After an error within a threaded loop, threading might be disabled. Resetting the threads before the simulation ensures that threading is enabled again for the simulation. See also trixi-framework/Trixi.jl#1583.\n\nReturns\n\nA DynamicalODEProblem (see the OrdinaryDiffEq.jl docs) to be integrated with OrdinaryDiffEq.jl. Note that this is not a true DynamicalODEProblem where the acceleration does not depend on the velocity. Therefore, not all integrators designed for DynamicalODEProblems will work properly. However, all integrators designed for ODEProblems can be used. See time integration for more details.\n\nExamples\n\nsemi = Semidiscretization(fluid_system, boundary_system)\ntspan = (0.0, 1.0)\node_problem = semidiscretize(semi, tspan)\n\n\n\n\n\n","category":"method"},{"location":"systems/boundary/#Boundary-System","page":"Boundary","title":"Boundary System","text":"","category":"section"},{"location":"systems/boundary/#TrixiParticles.BoundarySPHSystem","page":"Boundary","title":"TrixiParticles.BoundarySPHSystem","text":"BoundarySPHSystem(initial_condition, boundary_model; movement=nothing, adhesion_coefficient=0.0)\n\nSystem for boundaries modeled by boundary particles. The interaction between fluid and boundary particles is specified by the boundary model.\n\nArguments\n\ninitial_condition: Initial condition (see InitialCondition)\nboundary_model: Boundary model (see Boundary Models)\n\nKeyword Arguments\n\nmovement: For moving boundaries, a BoundaryMovement can be passed.\nadhesion_coefficient: Coefficient specifying the adhesion of a fluid to the surface.  Note: currently it is assumed that all fluids have the same adhesion coefficient.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#TrixiParticles.BoundaryDEMSystem","page":"Boundary","title":"TrixiParticles.BoundaryDEMSystem","text":"BoundaryDEMSystem(initial_condition, normal_stiffness)\n\nSystem for boundaries modeled by boundary particles. The interaction between fluid and boundary particles is specified by the boundary model.\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in a future releases.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#TrixiParticles.BoundaryMovement","page":"Boundary","title":"TrixiParticles.BoundaryMovement","text":"BoundaryMovement(movement_function, is_moving; moving_particles=nothing)\n\nArguments\n\nmovement_function: Time-dependent function returning an SVector of d dimensions                      for a d-dimensional problem.\nis_moving: Function to determine in each timestep if the particles are moving or not. Its   boolean return value is mandatory to determine if the neighborhood search will be updated.\n\nKeyword Arguments\n\nmoving_particles: Indices of moving particles. Default is each particle in BoundarySPHSystem.\n\nIn the example below, movement describes particles moving in a circle as long as the time is lower than 1.5.\n\nExamples\n\nmovement_function(t) = SVector(cos(2pi*t), sin(2pi*t))\nis_moving(t) = t < 1.5\n\nmovement = BoundaryMovement(movement_function, is_moving)\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#boundary_models","page":"Boundary","title":"Boundary Models","text":"","category":"section"},{"location":"systems/boundary/#Dummy-Particles","page":"Boundary","title":"Dummy Particles","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Boundaries modeled as dummy particles, which are treated like fluid particles, but their positions and velocities are not evolved in time. Since the force towards the fluid should not change with the material density when used with a TotalLagrangianSPHSystem, the dummy particles need to have a mass corresponding to the fluid's rest density, which we call \"hydrodynamic mass\", as opposed to mass corresponding to the material density of a TotalLagrangianSPHSystem.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Here, initial_density and hydrodynamic_mass are vectors that contains the initial density and the hydrodynamic mass respectively for each boundary particle. Note that when used with SummationDensity (see below), this is only used to determine the element type and the number of boundary particles.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"To establish a relationship between density and pressure, a state_equation has to be passed, which should be the same as for the adjacent fluid systems. To sum over neighboring particles, a smoothing_kernel and smoothing_length needs to be passed. This should be the same as for the adjacent fluid system with the largest smoothing length.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"In the literature, this kind of boundary particles is referred to as \"dummy particles\" (Adami et al., 2012 and Valizadeh & Monaghan, 2015), \"frozen fluid particles\" (Akinci et al., 2012) or \"dynamic boundaries Crespo et al., 2007. The key detail of this boundary condition and the only difference between the boundary models in these references is the way the density and pressure of boundary particles is computed.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Since boundary particles are treated like fluid particles, the force on fluid particle a due to boundary particle b is given by","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"f_ab = m_a m_b left( fracp_arho_a^2 + fracp_brho_b^2 right) nabla_r_a W(Vert r_a - r_b Vert h)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The quantities to be defined here are the density rho_b and pressure p_b of the boundary particle b.","category":"page"},{"location":"systems/boundary/#TrixiParticles.BoundaryModelDummyParticles","page":"Boundary","title":"TrixiParticles.BoundaryModelDummyParticles","text":"BoundaryModelDummyParticles(initial_density, hydrodynamic_mass,\n                            density_calculator, smoothing_kernel,\n                            smoothing_length; viscosity=nothing,\n                            state_equation=nothing, correction=nothing,\n                            reference_particle_spacing=0.0)\n\nBoundary model for BoundarySPHSystem.\n\nArguments\n\ninitial_density: Vector holding the initial density of each boundary particle.\nhydrodynamic_mass: Vector holding the \"hydrodynamic mass\" of each boundary particle.                      See description above for more information.\ndensity_calculator: Strategy to compute the hydrodynamic density of the boundary particles.                       See description below for more information.\nsmoothing_kernel: Smoothing kernel should be the same as for the adjacent fluid system.\nsmoothing_length: Smoothing length should be the same as for the adjacent fluid system.\n\nKeywords\n\nstate_equation:             This should be the same as for the adjacent fluid system                               (see e.g. StateEquationCole).\ncorrection:                 Correction method of the adjacent fluid system (see Corrections).\nviscosity:                  Slip (default) or no-slip condition. See description below for further                               information.\nreference_particle_spacing: The reference particle spacing used for weighting values at the boundary,                               which currently is only needed when using surface tension.\n\nExamples\n\n# Free-slip condition\nboundary_model = BoundaryModelDummyParticles(densities, masses, AdamiPressureExtrapolation(),\n                                             smoothing_kernel, smoothing_length)\n\n# No-slip condition\nboundary_model = BoundaryModelDummyParticles(densities, masses, AdamiPressureExtrapolation(),\n                                             smoothing_kernel, smoothing_length,\n                                             viscosity=ViscosityAdami(nu=1e-6))\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#Hydrodynamic-density-of-dummy-particles","page":"Boundary","title":"Hydrodynamic density of dummy particles","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"We provide six options to compute the boundary density and pressure, determined by the density_calculator:","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"(Recommended) With AdamiPressureExtrapolation, the pressure is extrapolated from the pressure of the fluid according to Adami et al., 2012, and the density is obtained by applying the inverse of the state equation. This option usually yields the best results of the options listed here.\n(Only relevant for FSI) With BernoulliPressureExtrapolation, the pressure is extrapolated from the pressure similar to the AdamiPressureExtrapolation, but a relative velocity-dependent pressure part is calculated between moving solids and fluids, which increases the boundary pressure in areas prone to penetrations.\nWith SummationDensity, the density is calculated by summation over the neighboring particles, and the pressure is computed from the density with the state equation.\nWith ContinuityDensity, the density is integrated from the continuity equation, and the pressure is computed from the density with the state equation. Note that this causes a gap between fluid and boundary where the boundary is initialized without any contact to the fluid. This is due to overestimation of the boundary density as soon as the fluid comes in contact with boundary particles that initially did not have contact to the fluid. Therefore, in dam break simulations, there is a visible \"step\", even though the boundary is supposed to be flat. See also dual.sphysics.org/faq/#Q_13.\nWith PressureZeroing, the density is set to the reference density and the pressure is computed from the density with the state equation. This option is not recommended. The other options yield significantly better results.\nWith PressureMirroring, the density is set to the reference density. The pressure is not used. Instead, the fluid pressure is mirrored as boundary pressure in the momentum equation. This option is not recommended due to stability issues. See PressureMirroring for more details.","category":"page"},{"location":"systems/boundary/#1.-[AdamiPressureExtrapolation](@ref)","page":"Boundary","title":"1. AdamiPressureExtrapolation","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The pressure of the boundary particles is obtained by extrapolating the pressure of the fluid according to Adami et al., 2012. The pressure of a boundary particle b is given by","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"p_b = fracsum_f (p_f + rho_f (bmg - bma_b) cdot bmr_bf) W(Vert r_bf Vert h)sum_f W(Vert r_bf Vert h)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the sum is over all fluid particles, rho_f and p_f denote the density and pressure of fluid particle f, respectively, r_bf = r_b - r_f denotes the difference of the coordinates of particles b and f, bmg denotes the gravitational acceleration acting on the fluid, and bma_b denotes the acceleration of the boundary particle b.","category":"page"},{"location":"systems/boundary/#TrixiParticles.AdamiPressureExtrapolation","page":"Boundary","title":"TrixiParticles.AdamiPressureExtrapolation","text":"AdamiPressureExtrapolation(; pressure_offset=0, allow_loop_flipping=true)\n\ndensity_calculator for BoundaryModelDummyParticles.\n\nKeywords\n\npressure_offset=0: Sometimes it is necessary to artificially increase the boundary pressure                      to prevent penetration, which is possible by increasing this value.\nallow_loop_flipping=true: Allow to flip the loop order for the pressure extrapolation.                             Disable to prevent error variations between simulations with                             different numbers of threads.                             Usually, the first (multithreaded) loop is over the boundary                             particles and the second loop over the fluid neighbors.                             When the number of boundary particles is larger than                             ceil(0.5 * nthreads()) times the number of fluid particles,                             it is usually more efficient to flip the loop order and loop                             over the fluid particles first.                             The factor depends on the number of threads, as the flipped                             loop is not thread parallelizable.                             This can cause error variations between simulations with                             different numbers of threads.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#2.-[BernoulliPressureExtrapolation](@ref)","page":"Boundary","title":"2. BernoulliPressureExtrapolation","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Identical to the pressure p_b calculated via AdamiPressureExtrapolation, but it adds the dynamic pressure component of the Bernoulli equation:","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"p_b = fracsum_f (p_f + frac12  rho_textneighbor left( frac (mathbfv_f - mathbfv_textbody) cdot (mathbfx_f - mathbfx_textneighbor)  left mathbfx_f - mathbfx_textneighbor right  right)^2 times textfactor +rho_f (bmg - bma_b) cdot bmr_bf) W(Vert r_bf Vert h)sum_f W(Vert r_bf Vert h)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where mathbfv_f is the velocity of the fluid and mathbfv_textbody is the velocity of the body. This adjustment provides a higher boundary pressure for solid bodies moving with a relative velocity to the fluid to prevent penetration. This modification is original and not derived from any literature source.","category":"page"},{"location":"systems/boundary/#TrixiParticles.BernoulliPressureExtrapolation","page":"Boundary","title":"TrixiParticles.BernoulliPressureExtrapolation","text":"BernoulliPressureExtrapolation(; pressure_offset=0, factor=1)\n\ndensity_calculator for BoundaryModelDummyParticles.\n\nKeywords\n\npressure_offset=0:   Sometimes it is necessary to artificially increase the boundary pressure                        to prevent penetration, which is possible by increasing this value.\nfactor=1         :   Setting factor allows to just increase the strength of the dynamic                        pressure part.\nallow_loop_flipping=true: Allow to flip the loop order for the pressure extrapolation.                             Disable to prevent error variations between simulations with                             different numbers of threads.                             Usually, the first (multithreaded) loop is over the boundary                             particles and the second loop over the fluid neighbors.                             When the number of boundary particles is larger than                             ceil(0.5 * nthreads()) times the number of fluid particles,                             it is usually more efficient to flip the loop order and loop                             over the fluid particles first.                             The factor depends on the number of threads, as the flipped                             loop is not thread parallelizable.                             This can cause error variations between simulations with                             different numbers of threads.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#5.-[PressureZeroing](@ref)","page":"Boundary","title":"5. PressureZeroing","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"This is the simplest way to implement dummy boundary particles. The density of each particle is set to the reference density and the pressure to the reference pressure (the corresponding pressure to the reference density by the state equation).","category":"page"},{"location":"systems/boundary/#TrixiParticles.PressureZeroing","page":"Boundary","title":"TrixiParticles.PressureZeroing","text":"PressureZeroing()\n\ndensity_calculator for BoundaryModelDummyParticles.\n\nnote: Note\nThis boundary model produces significantly worse results than all other models and is only included for research purposes.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#6.-[PressureMirroring](@ref)","page":"Boundary","title":"6. PressureMirroring","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Instead of calculating density and pressure for each boundary particle, we modify the momentum equation,","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"fracmathrmdv_amathrmdt = -sum_b m_b left( fracp_arho_a^2 + fracp_brho_b^2 right) nabla_a W_ab","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"to replace the unknown density rho_b if b is a boundary particle by the reference density and the unknown pressure p_b if b is a boundary particle by the pressure p_a of the interacting fluid particle. The momentum equation therefore becomes","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"fracmathrmdv_amathrmdt = -sum_f m_f left( fracp_arho_a^2 + fracp_frho_f^2 right) nabla_a W_af\n-sum_b m_b left( fracp_arho_a^2 + fracp_arho_0^2 right) nabla_a W_ab","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the first sum is over all fluid particles and the second over all boundary particles.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"This approach was first mentioned by Akinci et al. (2012) and written down in this form by Band et al. (2018).","category":"page"},{"location":"systems/boundary/#TrixiParticles.PressureMirroring","page":"Boundary","title":"TrixiParticles.PressureMirroring","text":"PressureMirroring()\n\ndensity_calculator for BoundaryModelDummyParticles.\n\nnote: Note\nThis boundary model requires high viscosity for stability with WCSPH. It also produces significantly worse results than AdamiPressureExtrapolation and is not more efficient because smaller time steps are required due to more noise in the pressure. We added this model only for research purposes and for comparison with SPlisHSPlasH.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#No-slip-conditions","page":"Boundary","title":"No-slip conditions","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"For the interaction of dummy particles and fluid particles, Adami et al. (2012) impose a no-slip boundary condition by assigning a wall velocity v_w to the dummy particle.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The wall velocity of particle a is calculated from the prescribed boundary particle velocity v_a and the smoothed velocity field","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"v_w = 2 v_a - fracsum_b v_b W_absum_b W_ab","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the sum is over all fluid particles.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"By choosing the viscosity model ViscosityAdami for viscosity, a no-slip condition is imposed. It is recommended to choose nu in the order of either the kinematic viscosity parameter of the adjacent fluid or the equivalent from the artificial parameter alpha of the adjacent fluid (nu = fracalpha h c 2d + 4). When omitting the viscous interaction (default viscosity=nothing), a free-slip wall boundary condition is applied.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"warning: Warning\nThe viscosity model ArtificialViscosityMonaghan for BoundaryModelDummyParticles has not been verified yet.","category":"page"},{"location":"systems/boundary/#Repulsive-Particles","page":"Boundary","title":"Repulsive Particles","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Boundaries modeled as boundary particles which exert forces on the fluid particles (Monaghan, Kajtar, 2009). The force on fluid particle a due to boundary particle b is given by","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"f_ab = m_a left(tildef_ab - m_b Pi_ab nabla_r_a W(Vert r_a - r_b Vert h)right)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"with","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"tildef_ab = fracKbeta^n-1 fracr_abVert r_ab Vert (Vert r_ab Vert - d) Phi(Vert r_ab Vert h)\nfrac2 m_bm_a + m_b","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where m_a and m_b are the masses of fluid particle a and boundary particle b respectively, r_ab = r_a - r_b is the difference of the coordinates of particles a and b, d denotes the boundary particle spacing and n denotes the number of dimensions (see Monaghan & Kajtar, 2009, Equation (3.1) and Valizadeh & Monaghan, 2015). Note that the repulsive acceleration tildef_ab does not depend on the masses of the boundary particles. Here, Phi denotes the 1D Wendland C4 kernel, normalized to 177 for q=0 (Monaghan & Kajtar, 2009, Section 4), with Phi(r h) = w(rh) and","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"w(q) =\nbegincases\n  (17732) (1 + (52)q + 2q^2)(2 - q)^5   textif  0 leq q  2 \n  0                                        textif  q geq 2\nendcases","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The boundary particles are assumed to have uniform spacing by the factor beta smaller than the expected fluid particle spacing. For example, if the fluid particles have an expected spacing of 03 and the boundary particles have a uniform spacing of 01, then this parameter should be set to beta = 3. According to Monaghan & Kajtar (2009), a value of beta = 3 for the Wendland C4 that we use here is reasonable for most computing purposes.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The parameter K is used to scale the force exerted by the boundary particles. In Monaghan & Kajtar (2009), a value of gD is used for static tank simulations, where g is the gravitational acceleration and D is the depth of the fluid.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The viscosity Pi_ab is calculated according to the viscosity used in the simulation, where the density of the boundary particle if needed is assumed to be identical to the density of the fluid particle.","category":"page"},{"location":"systems/boundary/#No-slip-condition","page":"Boundary","title":"No-slip condition","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"By choosing the viscosity model ArtificialViscosityMonaghan for viscosity, a no-slip condition is imposed. When omitting the viscous interaction (default viscosity=nothing), a free-slip wall boundary condition is applied.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"warning: Warning\nThe no-slip conditions for BoundaryModelMonaghanKajtar have not been verified yet.","category":"page"},{"location":"systems/boundary/#TrixiParticles.BoundaryModelMonaghanKajtar","page":"Boundary","title":"TrixiParticles.BoundaryModelMonaghanKajtar","text":"BoundaryModelMonaghanKajtar(K, beta, boundary_particle_spacing, mass;\n                            viscosity=nothing)\n\nBoundary model for BoundarySPHSystem.\n\nArguments\n\nK: Scaling factor for repulsive force.\nbeta: Ratio of fluid particle spacing to boundary particle spacing.\nboundary_particle_spacing: Boundary particle spacing.\nmass: Vector holding the mass of each boundary particle.\n\nKeywords\n\nviscosity:  Free-slip (default) or no-slip condition. See description above for further               information.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#open_boundary","page":"Boundary","title":"Open Boundaries","text":"","category":"section"},{"location":"systems/boundary/#TrixiParticles.OpenBoundarySPHSystem","page":"Boundary","title":"TrixiParticles.OpenBoundarySPHSystem","text":"OpenBoundarySPHSystem(boundary_zone::BoundaryZone;\n                      fluid_system::FluidSystem, buffer_size::Integer,\n                      boundary_model,\n                      reference_velocity=nothing,\n                      reference_pressure=nothing,\n                      reference_density=nothing)\n\nOpen boundary system for in- and outflow particles.\n\nArguments\n\nboundary_zone: See BoundaryZone.\n\nKeywords\n\nfluid_system: The corresponding fluid system\nboundary_model: Boundary model (see Open Boundary Models)\nbuffer_size: Number of buffer particles.\nreference_velocity: Reference velocity is either a function mapping each particle's coordinates                       and time to its velocity, an array where the i-th column holds                       the velocity of particle i or, for a constant fluid velocity,                       a vector holding this velocity.\nreference_pressure: Reference pressure is either a function mapping each particle's coordinates                       and time to its pressure, a vector holding the pressure of each particle,                       or a scalar for a constant pressure over all particles.\nreference_density: Reference density is either a function mapping each particle's coordinates                      and time to its density, a vector holding the density of each particle,                      or a scalar for a constant density over all particles.\n\nnote: Note\nWhen using the BoundaryModelTafuni(), the reference values (reference_velocity, reference_pressure, reference_density) can also be set to nothing since this model allows for either assigning physical quantities a priori or extrapolating them from the fluid domaim to the buffer zones (inflow and outflow) using ghost nodes.\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in future releases. It is GPU-compatible (e.g., with CUDA.jl and AMDGPU.jl), but currently not supported with Metal.jl.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#TrixiParticles.BoundaryZone","page":"Boundary","title":"TrixiParticles.BoundaryZone","text":"BoundaryZone(; plane, plane_normal, density, particle_spacing,\n             initial_condition=nothing, extrude_geometry=nothing,\n             open_boundary_layers::Integer, boundary_type=BidirectionalFlow())\n\nBoundary zone for OpenBoundarySPHSystem.\n\nThe specified plane (line in 2D or rectangle in 3D) will be extruded in the direction opposite to plane_normal to create a box for the boundary zone. There are three ways to specify the actual shape of the boundary zone:\n\nDon't pass initial_condition or extrude_geometry. The boundary zone box will then be filled with boundary particles (default).\nSpecify extrude_geometry by passing a 1D shape in 2D or a 2D shape in 3D, which is then extruded in the direction opposite to plane_normal to create the boundary particles.\nIn 2D, the shape must be either an initial condition with 2D coordinates, which lies on the line specified by plane, or an initial condition with 1D coordinates, which lies on the line specified by plane when a y-coordinate of 0 is added.\nIn 3D, the shape must be either an initial condition with 3D coordinates, which lies in the rectangle specified by plane, or an initial condition with 2D coordinates, which lies in the rectangle specified by plane when a z-coordinate of 0 is added.\nSpecify initial_condition by passing a 2D initial condition in 2D or a 3D initial condition in 3D, which will be used for the boundary particles.\n\nnote: Note\nParticles outside the boundary zone box will be removed.\n\nKeywords\n\nplane: Tuple of points defining a part of the surface of the domain.          The points must either span a line in 2D or a rectangle in 3D.          This line or rectangle is then extruded in upstream direction to obtain          the boundary zone.          In 2D, pass two points (A B), so that the interval A B is          the inflow surface.          In 3D, pass three points (A B C), so that the rectangular inflow surface          is spanned by the vectors widehatAB and widehatAC.          These two vectors must be orthogonal.\nplane_normal: Vector defining the plane normal. It always points inside the fluid domain.\nboundary_type=BidirectionalFlow(): Specify the type of the boundary. Available types are\nInFlow() for an inflow boundary\nOutFlow() for an outflow boundary\nBidirectionalFlow() (default) for an bidirectional flow boundary\nopen_boundary_layers: Number of particle layers in the direction opposite to plane_normal.\nparticle_spacing: The spacing between the particles (see InitialCondition).\ndensity: Particle density (see InitialCondition).\ninitial_condition=nothing: InitialCondition for the inflow particles.                              Particles outside the boundary zone will be removed.                              Do not use together with extrude_geometry.\nextrude_geometry=nothing: 1D shape in 2D or 2D shape in 3D, which lies on the plane                             and is extruded upstream to obtain the inflow particles.                             See point 2 above for more details.\n\nExamples\n\n# 2D\nplane_points = ([0.0, 0.0], [0.0, 1.0])\nplane_normal=[1.0, 0.0]\n\ninflow = BoundaryZone(; plane=plane_points, plane_normal, particle_spacing=0.1, density=1.0,\n                      open_boundary_layers=4, boundary_type=InFlow())\n\n# 3D\nplane_points = ([0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0])\nplane_normal=[0.0, 0.0, 1.0]\n\noutflow = BoundaryZone(; plane=plane_points, plane_normal, particle_spacing=0.1, density=1.0,\n                       open_boundary_layers=4, boundary_type=OutFlow())\n\n# 3D particles sampled as cylinder\ncircle = SphereShape(0.1, 0.5, (0.5, 0.5), 1.0, sphere_type=RoundSphere())\n\nbidirectional_flow = BoundaryZone(; plane=plane_points, plane_normal, particle_spacing=0.1,\n                                  density=1.0, extrude_geometry=circle, open_boundary_layers=4)\n\nwarning: Experimental Implementation\nThis is an experimental feature and may change in any future releases.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/#open_boundary_models","page":"Boundary","title":"Open Boundary Models","text":"","category":"section"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"We offer two models for open boundaries, with the choice depending on the specific problem and flow characteristics near the boundary:","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Method of characteristics: The method of characteristics is typically used in problems where tracking of wave propagation  or flow in a domain that interacts with open boundaries (e.g., shock waves, wave fronts, or any behavior that depends on the direction of propagation) is needed.  It avoids artificial reflections that could arise from boundary conditions.\nMirroring: The mirroring method is often applied when the flow near the boundary is expected to behave in a way that is easier to model by using symmetry  or when the fluid does not exhibit complex wave behavior near the boundary (e.g., free-surface flows and simple outflow).","category":"page"},{"location":"systems/boundary/#method_of_characteristics","page":"Boundary","title":"Method of characteristics","text":"","category":"section"},{"location":"systems/boundary/#TrixiParticles.BoundaryModelLastiwka","page":"Boundary","title":"TrixiParticles.BoundaryModelLastiwka","text":"BoundaryModelLastiwka(; extrapolate_reference_values::Bool=false)\n\nBoundary model for OpenBoundarySPHSystem. This model uses the characteristic variables to propagate the appropriate values to the outlet or inlet and have been proposed by Lastiwka et al. (2009). It requires a specific flow direction to be passed to the BoundaryZone. For more information about the method see description below.\n\nKeywords\n\nextrapolate_reference_values=false: If true, the reference values are extrapolated from the fluid domain to the boundary particles. This is useful for open boundaries where the reference values are not known a priori. Note: This feature is experimental and has not been fully validated yet. As of now, we are not aware of any published literature supporting its use.\n\n\n\n\n\n","category":"type"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"The difficulty in non-reflecting boundary conditions, also called open boundaries, is to determine the appropriate boundary values of the exact characteristics of the Euler equations. Assuming the flow near the boundaries is normal to the boundary and free of shock waves and significant viscous effects, it can be shown that three characteristic variables exist:","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"J_1, associated with convection of entropy and propagates at flow velocity,\nJ_2, downstream-running characteristics,\nJ_3, upstream-running characteristics.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Giles (1990) derived those variables based on a linearized set of governing equations:","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"J_1 = -c_s^2 (rho - rho_textref) + (p - p_textref)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"J_2 = rho c_s (v - v_textref) + (p - p_textref)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"J_3 = - rho c_s (v - v_textref) + (p - p_textref)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the subscript \"ref\" denotes the reference flow near the boundaries, which can be prescribed.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Specifying the reference variables is not equivalent to prescription of rho, v and p directly, since the perturbation from the reference flow is allowed.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Lastiwka et al. (2009) applied the method of characteristic to SPH and determined the number of variables that should be prescribed at the boundary and the number which should be propagated from the fluid domain to the boundary:","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"For an inflow boundary:\nPrescribe downstream-running characteristics J_1 and J_2\nTransmit J_3 from the fluid domain (allow J_3 to propagate upstream to the boundary).\nFor an outflow boundary:\nPrescribe upstream-running characteristic J_3\nTransmit J_1 and J_2 from the fluid domain.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"Prescribing is done by simply setting the characteristics to zero. To transmit the characteristics from the fluid domain, or in other words, to carry the information of the fluid to the boundaries, Negi et al. (2020) use a Shepard Interpolation","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"f_i = fracsum_j^N f_j W_ijsum_j^N W_ij","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"where the i-th particle is a boundary particle, f is either  J_1, J_2 or J_3 and N is the set of neighboring fluid particles.","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"To express pressure p, density rho and velocity v as functions of the characteristic variables, the system of equations from the characteristic variables is inverted and gives","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":" rho - rho_textref = frac1c_s^2 left( -J_1 + frac12 J_2 + frac12 J_3 right)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"u - u_textref= frac12rho c_s left( J_2 - J_3 right)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"p - p_textref = frac12 left( J_2 + J_3 right)","category":"page"},{"location":"systems/boundary/","page":"Boundary","title":"Boundary","text":"With J_1, J_2 and J_3 determined, we can easily solve for the actual variables for each particle.","category":"page"},{"location":"systems/boundary/#mirroring","page":"Boundary","title":"Mirroring","text":"","category":"section"},{"location":"systems/boundary/#TrixiParticles.BoundaryModelTafuni","page":"Boundary","title":"TrixiParticles.BoundaryModelTafuni","text":"BoundaryModelTafuni()\n\nBoundary model for the OpenBoundarySPHSystem. This model implements the method of Tafuni et al. (2018) to extrapolate the properties from the fluid domain to the buffer zones (inflow and outflow) using ghost nodes. The position of the ghost nodes is obtained by mirroring the boundary particles into the fluid along a direction that is normal to the open boundary.\n\n\n\n\n\n","category":"type"},{"location":"tutorials_template/tut_setup/#Setting-up-your-simulation-from-scratch","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In this tutorial, we will guide you through the general structure of simulation files. We will set up a simulation similar to the example simulation examples/fluid/dam_break_2d.jl, which is one of our simplest example simulations. In the second part of this tutorial, we will show how to replace components of TrixiParticles.jl by custom implementations from within a simulation file, without ever cloning the repository.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"For different setups and physics, have a look at our other example files.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"First, we import TrixiParticles.jl and OrdinaryDiffEq.jl, which we will use at the very end for the time integration.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using TrixiParticles\nusing OrdinaryDiffEq","category":"page"},{"location":"tutorials_template/tut_setup/#Resolution","page":"Setting up your simulation from scratch","title":"Resolution","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Now, we define the particle spacing, which is our numerical resolution. For a fluid, we usually call the variable fluid_particle_spacing, so that we can easily change the resolution of an example file by overwriting this variable with trixi_include. In 2D, the number of particles will grow quadratically, in 3D cubically with the spacing.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We also set the number of boundary layers, which need to be sufficiently large, depending on the smoothing kernel and smoothing length, so that the compact support of the smoothing kernel is fully sampled with particles for a fluid particle close to a boundary. In particular, we require the boundary thickness boundary_layers * fluid_particle_spacing to be larger than the compact support of the kernel. The compact support of each kernel can be found in the smoothing kernel overview.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"fluid_particle_spacing = 0.02\nboundary_layers = 3\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/#Experiment-setup","page":"Setting up your simulation from scratch","title":"Experiment setup","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We want to simulate a small dam break problem inside a rectangular tank. (Image: Experiment Setup) First, we define physical parameters like gravitational acceleration, simulation time, initial fluid size, tank size and fluid density.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"gravity = 9.81\ntspan = (0.0, 1.0)\ninitial_fluid_size = (1.0, 0.5)\ntank_size = (2.0, 1.0)\nfluid_density = 1000.0\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In order to have the initial particle mass and density correspond to the hydrostatic pressure gradient, we need to define a state equation, which relates the fluid density to pressure. Note that we could also skip this part here and define the state equation later when we define the fluid system, but then the fluid would be initialized with constant density, which would cause it to oscillate under gravity.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"sound_speed = 10.0\nstate_equation = StateEquationCole(; sound_speed, reference_density=fluid_density,\n                                   exponent=7)\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"The speed of sound here is numerical and not physical. We artificially lower the speed of sound, since the physical speed of sound in water would lead to prohibitively small time steps. The speed of sound in Weakly Compressible SPH should be chosen as small as possible for numerical efficiency, but large enough to limit density fluctuations to about 1%. We usually choose the speed of sound as 10 v_textmax, where v_textmax is the largest velocity in the simulation. This can also be done by approximating the expected maximum velocity. For example, in dam break simulations, the speed of sound is often chosen as 10 sqrtgH, where H is the initial height of the water column and g is the gravitational acceleration, using the shallow water wave velocity as an estimate. See e.g. Adami et al., 2012.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"TrixiParticles.jl requires the initial particle positions and quantities in form of an InitialCondition. Instead of manually defining particle positions, you can work with our pre-defined setups. Among others, we provide setups for rectangular shapes, circles, and spheres. Initial conditions can also be combined with common set operations. See this page for a list of pre-defined setups and details on set operations on initial conditions.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Here, we use the RectangularTank setup, which generates a rectangular fluid inside a rectangular tank, and supports a hydrostatic pressure gradient by passing a gravitational acceleration and a state equation (see above).","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"tank = RectangularTank(fluid_particle_spacing, initial_fluid_size, tank_size,\n                       fluid_density, n_layers=boundary_layers,\n                       acceleration=(0.0, -gravity), state_equation=state_equation)\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"A RectangularTank consists of two InitialConditions, tank.fluid and tank.boundary. We can plot these initial conditions to visualize the initial setup.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using Plots\nplot(tank.fluid, tank.boundary, labels=[\"fluid\" \"boundary\"])\nplot!(dpi=200); savefig(\"tut_setup_plot_tank.png\"); nothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"(Image: plot tank)","category":"page"},{"location":"tutorials_template/tut_setup/#Fluid-system","page":"Setting up your simulation from scratch","title":"Fluid system","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"To model the water column, we use the Weakly Compressible Smoothed Particle Hydrodynamics (WCSPH) method. This method requires a smoothing kernel and a corresponding smoothing length, which should be chosen in relation to the particle spacing.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"smoothing_length = 1.2 * fluid_particle_spacing\nsmoothing_kernel = SchoenbergCubicSplineKernel{2}()\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"You can find an overview over smoothing kernels and corresponding smoothing lengths here.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"For stability, we need numerical dissipation in form of an artificial viscosity term. Other viscosity models offer a physical approach based on the kinematic viscosity of the fluid.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"viscosity = ArtificialViscosityMonaghan(alpha=0.02, beta=0.0)\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We choose the parameters as small as possible to avoid non-physical behavior, but as large as possible to stabilize the simulation.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"The WCSPH method can either compute the particle density directly with a kernel summation over all neighboring particles (see SummationDensity) or by making the particle density a variable in the ODE system and integrating its change over time. We choose the latter approach here by using the density calculator ContinuityDensity, which is more efficient and handles free surfaces without the need for additional correction terms. The simulation quality greatly benefits from using density diffusion.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"fluid_density_calculator = ContinuityDensity()\ndensity_diffusion = DensityDiffusionMolteniColagrossi(delta=0.1)\nfluid_system = WeaklyCompressibleSPHSystem(tank.fluid, fluid_density_calculator,\n                                           state_equation, smoothing_kernel,\n                                           smoothing_length, viscosity=viscosity,\n                                           density_diffusion=density_diffusion,\n                                           acceleration=(0.0, -gravity))\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/#Boundary-system","page":"Setting up your simulation from scratch","title":"Boundary system","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"To model the boundary, we use particle-based boundary conditions, in which particles are sampled in the boundary that interact with the fluid particles to avoid penetration. In order to define a boundary system, we first have to choose a boundary model, which defines how the fluid interacts with boundary particles. We will use the BoundaryModelDummyParticles with AdamiPressureExtrapolation. See here for a comprehensive overview over boundary models.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"boundary_model = BoundaryModelDummyParticles(tank.boundary.density, tank.boundary.mass,\n                                             state_equation=state_equation,\n                                             AdamiPressureExtrapolation(),\n                                             smoothing_kernel, smoothing_length)\nboundary_system = BoundarySPHSystem(tank.boundary, boundary_model)\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/#Semidiscretization","page":"Setting up your simulation from scratch","title":"Semidiscretization","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"The key component of every simulation is the Semidiscretization, which couples all systems of the simulation. All simulation methods in TrixiParticles.jl are semidiscretizations, which discretize the equations in space to provide an ordinary differential equation that still has to be solved in time. By providing a simulation time span, we can call semidiscretize, which returns an ODEProblem that can be solved with a time integration method.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"semi = Semidiscretization(fluid_system, boundary_system)\node = semidiscretize(semi, tspan)\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/#Time-integration","page":"Setting up your simulation from scratch","title":"Time integration","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We use the methods provided by OrdinaryDiffEq.jl, but note that other packages or custom implementations can also be used.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"OrdinaryDiffEq.jl supports callbacks, which are executed during the simulation. For this simulation, we use the InfoCallback, which prints information about the simulation setup at the beginning of the simulation, information about the current simulation time and runtime during the simulation, and a performance summary at the end of the simulation. We also want to save the current solution in regular intervals in terms of simulation time as VTK, so that we can look at the solution in ParaView. The SolutionSavingCallback provides this functionality. To pass the callbacks to OrdinaryDiffEq.jl, we have to bundle them into a CallbackSet.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"info_callback = InfoCallback(interval=50)\nsaving_callback = SolutionSavingCallback(dt=0.02)\n\ncallbacks = CallbackSet(info_callback, saving_callback)\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Finally, we can start the simulation by solving the ODEProblem. We use the method RDPK3SpFSAL35 of OrdinaryDiffEq.jl, which is a Runge-Kutta method with automatic (error based) time step size control. This method is usually a good choice for prototyping, since we do not have to worry about choosing a stable step size and can just run the simulation. For better performance, it might be beneficial to tweak the tolerances of this method or choose a different method that is more efficient for the respective simulation. You can find both approaches in our example files. Here, we just use the method with the default parameters, and only disable save_everystep to avoid expensive saving of the solution in every time step.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"See Visualization for how to visualize the final solution. For the simplest visualization, we can use Plots.jl:","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using Plots\nplot(sol)\nplot!(dpi=200); savefig(\"tut_setup_plot.png\"); nothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"(Image: plot)","category":"page"},{"location":"tutorials_template/tut_setup/#Replacing-components-with-custom-implementations","page":"Setting up your simulation from scratch","title":"Replacing components with custom implementations","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"If we would like to use an implementation of a component that is not available in TrixiParticles.jl, we can implement it ourselves within the simulation file, without ever cloning the TrixiParticles.jl repository. A good starting point is to check out the available implementations in TrixiParticles.jl, then copy the relevant functions to the simulation file and modify them as needed.","category":"page"},{"location":"tutorials_template/tut_setup/#Custom-smoothing-kernel","page":"Setting up your simulation from scratch","title":"Custom smoothing kernel","text":"","category":"section"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"To implement a custom smoothing kernel, we define a struct extending TrixiParticles.SmoothingKernel. This abstract struct has a type parameter for the number of dimensions, which we set to 2 in this case.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"struct MyGaussianKernel <: TrixiParticles.SmoothingKernel{2} end","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"This kernel is going to be an implementation of the Gaussian kernel with a cutoff for compact support, which reads","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"W(r h) =\nbegincases\nfrac1pi h^2 exp(-(rh)^2)  textfor  r  2h\n0  textfor  r geq 2h\nendcases","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Note that the same kernel in a more optimized version and with a cutoff at 3 is already implemented in TrixiParticles.jl as GaussianKernel.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In order to use our new kernel, we have to define three functions. TrixiParticles.kernel, which is the kernel function itself, TrixiParticles.kernel_deriv, which is the derivative of the kernel function, and TrixiParticles.compact_support, which defines the compact support of the kernel in relation to the smoothing length. The latter is relevant for determining the search radius of the neighborhood search.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"function TrixiParticles.kernel(kernel::MyGaussianKernel, r, h)\n    q = r / h\n\n    if q < 2\n        return 1 / (pi * h^2) * exp(-q^2)\n    end\n\n    return 0.0\nend\n\nfunction TrixiParticles.kernel_deriv(kernel::MyGaussianKernel, r, h)\n    q = r / h\n\n    if q < 2\n        return 1 / (pi * h^2)  * (-2 * q) * exp(-q^2) / h\n    end\n\n    return 0.0\nend\n\nTrixiParticles.compact_support(::MyGaussianKernel, h) = 2 * h","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"For this kernel, we use a different smoothing length, which yields a similar kernel to the SchoenbergCubicSplineKernel that we used earlier.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"smoothing_length_gauss = 1.0 * fluid_particle_spacing\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We can compare these kernels in a plot.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using Plots\nx = range(-0.05, 0.05, length=500)\nplot(x, r -> TrixiParticles.kernel(SchoenbergCubicSplineKernel{2}(), abs(r), smoothing_length),\n     label=\"SchoenbergCubicSplineKernel\", xlabel=\"r\")\nplot!(x, r -> TrixiParticles.kernel(MyGaussianKernel(), abs(r), smoothing_length_gauss),\n      label=\"MyGaussianKernel\")\nplot!(dpi=200); savefig(\"tut_setup_plot2.png\"); nothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"(Image: plot)","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"This is all we need to use our custom kernel implementation in a simulation. We only need to replace the definition above by","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"smoothing_kernel = MyGaussianKernel()\nnothing # hide","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"and run the simulation file again.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In order to use our kernel in a pre-defined example file, we can use the function trixi_include to replace the definition of the variable smoothing_kernel. The following will run the example simulation examples/fluid/hydrostatic_water_column_2d.jl with our custom kernel and the corresponding smoothing length.","category":"page"},{"location":"tutorials_template/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"page"},{"location":"news/#Changelog","page":"News","title":"Changelog","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"TrixiParticles.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.","category":"page"},{"location":"news/#Version-0.3.1","page":"News","title":"Version 0.3.1","text":"","category":"section"},{"location":"news/#Features","page":"News","title":"Features","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"New viscosity models ViscosityMorrisSGS and ViscosityAdamiSGS were added, which use a simplified Smagorinsky-type SGS (#753).  \nWith all CPU backends, a new array type is used for the integration array, which defines broadcasting to be multithreaded, leading to speedups of up to 5x with large thread counts when combined with thread pinning (#722).","category":"page"},{"location":"news/#Version-0.3","page":"News","title":"Version 0.3","text":"","category":"section"},{"location":"news/#API-Changes","page":"News","title":"API Changes","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Rescaled the Wendland kernels by a factor of 2 to be consistent with literature. This requires adjusting the previously used smoothing length for the Wendland Kernels by dividing them by 2 as well to obtain the same results (#775).\nAPI for custom quantities and functions in the PostprocessCallback changed (#755).\nThe API for choosing parallelization backends changed. The keyword argument data_type in semidiscretize was removed and a keyword argument parallelization_backend was added to Semidiscretization. See the docs on GPU support for more details.","category":"page"},{"location":"news/#Features-2","page":"News","title":"Features","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Explicit Contact Models: Added explicit contact models, LinearContactModel and HertzContactModel, to the DEM solver. (#756)\nParticle Shifting Technique (PST) for Closed Systems: Integrated the Particle Shifting Technique to enhance particle distribution, reduce clumping and prevent void regions due to tensile instability in closed system simulations. (#735)\nOpen Boundary Model: Added an open boundary model based on Tafuni et al. (2018), utilizing mirroring and extrapolation to transfer fluid quantities to the buffer zones. This enhancement allows for more accurate handling of simulation boundaries in open systems, ensuring better consistency between the computed domain and its buffer areas. (#574)\nTransport Velocity Formulation (TVF) for WCSPH Solver: Added support for TVF to the WCSPH solver, improving the consistency and stability of weakly compressible SPH simulations. (#600)","category":"page"},{"location":"news/#Refactoring","page":"News","title":"Refactoring","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Variable Smoothing Length Structures: Introduced new structures to support a variable smoothing length, providing enhanced flexibility in simulation configurations. (#736)\nFlexible Parallelization Backend: Improved the parallelization backend support, making it possible to switch the parallelization backend for single simulations. (#748)\nTotal Lagrangian SPH: Added per-particle material parameters. (#740)","category":"page"},{"location":"news/#Version-0.2.7","page":"News","title":"Version 0.2.7","text":"","category":"section"},{"location":"news/#Features-3","page":"News","title":"Features","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Added the classic Continuum Surface Force (CSF) model based on Morris 2000 (#584), which computes surface tension as a body force proportional to curvature and directed along the interface normal. This method is efficient and accurate for capillary effects but does not explicitly conserve momentum.\nAdded the classic Continuum Surface Stress (CSS) model based on Morris 2000 (#584), which is a momentum-conserving approach that formulates surface tension as the divergence of a stress tensor. However, it requires additional computation and stabilization to handle high-density interfaces and reduce numerical instabilities.\nAdded BoundaryZone to allow for bidirectional flow (#623)\nAdded the symplectic time integration scheme used in DualSPHysics (#716)","category":"page"},{"location":"news/#Documentation","page":"News","title":"Documentation","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Added documentation for time integration (#716)","category":"page"},{"location":"news/#Testing","page":"News","title":"Testing","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Run CI tests on GPUs via Buildkite CI (#723)","category":"page"},{"location":"news/#Bugs","page":"News","title":"Bugs","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Fix GPU computations (#689)","category":"page"},{"location":"news/#Version-0.2.6","page":"News","title":"Version 0.2.6","text":"","category":"section"},{"location":"news/#Features-4","page":"News","title":"Features","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Support for surface tension was added to EDAC (#539)","category":"page"},{"location":"news/#Refactored","page":"News","title":"Refactored","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Surface normal calculation was moved from surface_tension.jl to surface_normal_sph.jl (#539)","category":"page"},{"location":"news/#Version-0.2.5","page":"News","title":"Version 0.2.5","text":"","category":"section"},{"location":"news/#Features-5","page":"News","title":"Features","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Add particle packing for 2D (.asc) and 3D (.stl) geometries (#529)","category":"page"},{"location":"news/#Compatibility-Changes","page":"News","title":"Compatibility Changes","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Dropped support for Julia 1.9","category":"page"},{"location":"news/#Version-0.2.4","page":"News","title":"Version 0.2.4","text":"","category":"section"},{"location":"news/#Features-6","page":"News","title":"Features","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"A method to prevent penetration of fast moving particles with solids was added (#498)\nAdded the callback SteadyStateReachedCallback to detect convergence of static simulations (#601)\nAdded ideal gas state equation (#607)\nSimulations can be run with Float32 (#662)","category":"page"},{"location":"news/#Documentation-2","page":"News","title":"Documentation","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Documentation for GPU support was added (#660)\nA new user tutorial was added (#514)\nSeveral docs fixes (#663, #659, #637, #658, #664)","category":"page"},{"location":"news/#Version-0.2.3","page":"News","title":"Version 0.2.3","text":"","category":"section"},{"location":"news/#Highlights","page":"News","title":"Highlights","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Transport Velocity Formulation (TVF) based on the work of Ramachandran et al. \"Entropically damped artiﬁcial compressibility for SPH\" (2019) was added.","category":"page"},{"location":"news/#Version-0.2.2","page":"News","title":"Version 0.2.2","text":"","category":"section"},{"location":"news/#Highlights-2","page":"News","title":"Highlights","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Hotfix for threaded sampling of complex geometries.","category":"page"},{"location":"news/#Version-0.2.1","page":"News","title":"Version 0.2.1","text":"","category":"section"},{"location":"news/#Highlights-3","page":"News","title":"Highlights","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Particle sampling of complex geometries from .stl and .asc files.","category":"page"},{"location":"news/#Version-0.2.0","page":"News","title":"Version 0.2.0","text":"","category":"section"},{"location":"news/#Removed","page":"News","title":"Removed","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Use of the internal neighborhood search has been removed and replaced with PointNeighbors.jl.","category":"page"},{"location":"news/#Development-Cycle-0.1","page":"News","title":"Development Cycle 0.1","text":"","category":"section"},{"location":"news/#Highlights-4","page":"News","title":"Highlights","text":"","category":"section"},{"location":"news/#Discrete-Element-Method","page":"News","title":"Discrete Element Method","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"A basic implementation of the discrete element method was added.","category":"page"},{"location":"news/#Surface-Tension-and-Adhesion-Model","page":"News","title":"Surface Tension and Adhesion Model","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"A surface tension and adhesion model based on the work by Akinci et al., \"Versatile Surface Tension and Adhesion for SPH Fluids\" (2013) was added to WCSPH.","category":"page"},{"location":"news/#Support-for-Open-Boundaries","page":"News","title":"Support for Open Boundaries","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Open boundaries using the method of characteristics based on the work of Lastiwka et al., \"Permeable and non-reflecting boundary conditions in SPH\" (2009) were added for WCSPH and EDAC.","category":"page"},{"location":"news/#Pre-Initial-Release-(v0.1.0)","page":"News","title":"Pre Initial Release (v0.1.0)","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"This section summarizes the initial features that TrixiParticles.jl was released with.","category":"page"},{"location":"news/#Highlights-5","page":"News","title":"Highlights","text":"","category":"section"},{"location":"news/#EDAC","page":"News","title":"EDAC","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"An implementation of EDAC (Entropically Damped Artificial Compressibility) was added, which allows for more stable simulations compared to basic WCSPH and reduces spurious pressure oscillations.","category":"page"},{"location":"news/#WCSPH","page":"News","title":"WCSPH","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"An implementation of WCSPH (Weakly Compressible Smoothed Particle Hydrodynamics), which is the classical SPH approach.","category":"page"},{"location":"news/","page":"News","title":"News","text":"Features:","category":"page"},{"location":"news/","page":"News","title":"News","text":"Correction schemes (Shepard (0. Order) ... MixedKernelGradient (1. Order))\nDensity reinitialization\nKernel summation and Continuity equation density formulations\nFlexible boundary conditions e.g. dummy particles with Adami pressure extrapolation, pressure zeroing, pressure mirroring...\nMoving boundaries\nDensity diffusion based on the models by Molteni & Colagrossi (2009), Ferrari et al. (2009) and Antuono et al. (2010).","category":"page"},{"location":"news/#TLSPH","page":"News","title":"TLSPH","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"An implementation of TLSPH (Total Lagrangian Smoothed Particle Hydrodynamics) for solid bodies enabling FSI (Fluid Structure Interactions).","category":"page"},{"location":"general/util/#Util","page":"Util","title":"Util","text":"","category":"section"},{"location":"general/util/#TrixiParticles.examples_dir-Tuple{}","page":"Util","title":"TrixiParticles.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with TrixiParticles.jl are located. If TrixiParticles is installed as a regular package (with ]add TrixiParticles), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir.\n\nCopied from Trixi.jl.\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"general/util/#TrixiParticles.validation_dir-Tuple{}","page":"Util","title":"TrixiParticles.validation_dir","text":"validation_dir()\n\nReturn the directory where the validation files provided with TrixiParticles.jl are located. If TrixiParticles is installed as a regular package (with ]add TrixiParticles), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir.\n\nCopied from Trixi.jl.\n\nExamples\n\nreaddir(validation_dir())\n\n\n\n\n\n","category":"method"},{"location":"general/util/#TrixiParticles.@autoinfiltrate","page":"Util","title":"TrixiParticles.@autoinfiltrate","text":"@autoinfiltrate\n@autoinfiltrate condition::Bool\n\nInvoke the @infiltrate macro of the package Infiltrator.jl to create a breakpoint for ad-hoc interactive debugging in the REPL. If the optional argument condition is given, the breakpoint is only enabled if condition evaluates to true.\n\nAs opposed to using Infiltrator.@infiltrate directly, this macro does not require Infiltrator.jl to be added as a dependency to TrixiParticles.jl. As a bonus, the macro will also attempt to load the Infiltrator module if it has not yet been loaded manually.\n\nNote: For this macro to work, the Infiltrator.jl package needs to be installed in your current Julia environment stack.\n\nSee also: Infiltrator.jl\n\nwarning: Internal use only\nPlease note that this macro is intended for internal use only. It is not part of the public API of TrixiParticles.jl, and it thus can altered (or be removed) at any time without it being considered a breaking change.\n\n\n\n\n\n","category":"macro"},{"location":"tutorials_template/tut_falling/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials_template/tut_falling/","page":"Example file","title":"Example file","text":"!!include:examples/fsi/falling_spheres_2d.jl!!\n","category":"page"},{"location":"code_of_conduct/#Code-of-Conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Michael Schlottke-Lakemper, Sven Berger, or any other of the principal developers responsible for enforcement listed in Authors. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/codeofconduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"page"},{"location":"systems/fluid/#fluid_models","page":"Overview","title":"Fluid Models","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Currently available fluid methods are the weakly compressible SPH method and the entropically damped artificial compressibility for SPH. This page lists models and techniques that apply to both of these methods.","category":"page"},{"location":"systems/fluid/#viscosity_sph","page":"Overview","title":"Viscosity","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Viscosity is a critical physical property governing momentum diffusion within a fluid. In the context of SPH, viscosity determines how rapidly velocity gradients are smoothed out, influencing key flow characteristics such as boundary layer formation, vorticity diffusion, and dissipation of kinetic energy. It also helps determine whether a flow is laminar or turbulent under a given set of conditions.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Implementing viscosity correctly in SPH is essential for producing physically accurate results, and different methods exist to capture both numerical stabilization and true viscous effects.","category":"page"},{"location":"systems/fluid/#Artificial-(numerical)-viscosity","page":"Overview","title":"Artificial (numerical) viscosity","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Artificial (numerical) viscosity is a technique used to stabilize simulations of inviscid flows, which would otherwise show unphysical particle movement due to numerical instability. To achieve this, a dissipative term is added to the momentum equations in a way that it does not significantly alter the physical behavior of the flow. This approach is especially useful in simulations such as high-speed flows with strong shocks or astrophysical scenarios, where other approaches are insufficient to stabilize the simulation.","category":"page"},{"location":"systems/fluid/#Physical-(real)-viscosity","page":"Overview","title":"Physical (real) viscosity","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Physical viscosity is essential for accurately modeling the true viscous stresses within a fluid. It ensures that simulations align with a target Reynolds number or adhere to experimentally measured fluid properties. This is achieved by incorporating forces that replicate the viscous stress term found in the Navier–Stokes equations. As a result, the method is particularly effective for simulating low-speed, incompressible, or weakly compressible flows, where it is crucial to capture the actual behavior of the fluid.","category":"page"},{"location":"systems/fluid/#Model-comparison","page":"Overview","title":"Model comparison","text":"","category":"section"},{"location":"systems/fluid/#ArtificialViscosityMonaghan","page":"Overview","title":"ArtificialViscosityMonaghan","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"ArtificialViscosityMonaghan by Monaghan ([10], [11]) should be mainly used for inviscid flows (Euler), artificial stabilization or shock-capturing, for which Monaghan [11] originally designed this term to provide smoothing across shocks, intentionally overestimating the physical viscosity. The implementation includes a dissipation term that becomes more significant as particles approach one another. This helps suppress tensile instabilities, which can lead to particle clumping and effectively smooths out high-frequency pressure fluctuations. This increase in dissipation is triggered by the relative motion between particles: as particles come closer and compress the local flow, the artificial viscosity term becomes stronger to damp out rapid changes and prevent unphysical clustering. This ensures that while the simulation remains stable in challenging flow regimes with large density or pressure variations, the physical behavior is not overly altered. Several extensions have been proposed to limit the dissipation effect for example by Balsara ([12]) or Morris ([13]).","category":"page"},{"location":"systems/fluid/#Mathematical-Formulation","page":"Overview","title":"Mathematical Formulation","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The force exerted by particle b on particle a due to artificial viscosity is given by:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"F_ab^textAV = - m_a m_b Pi_ab nabla W_ab","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Pi_ab is the artificial viscosity term defined as:\nPi_ab =\nbegincases\n    -fracalpha c mu_ab + beta mu_ab^2barrho_ab  textif  mathbfv_ab cdot mathbfr_ab  0 \n    0  textotherwise\nendcases\nalpha and beta are viscosity parameters,\nc is the local speed of sound,\nbarrho_ab is the arithmetic mean of the densities of particles a and b.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The term mu_ab is defined as:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"mu_ab = frach  v_ab cdot r_abVert r_ab Vert^2 + epsilon h^2","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"with:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"h being the smoothing length,\nepsilon a small parameter to prevent singularities,\nr_ab = r_a - r_b representing the difference of the coordinate vectors,\nv_ab = v_a - v_b representing the relative velocity between particles.","category":"page"},{"location":"systems/fluid/#Resolution-Dependency-and-Effective-Viscosity","page":"Overview","title":"Resolution Dependency and Effective Viscosity","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"To ensure that the simulation maintains a consistent Reynolds number when the resolution changes, the parameter alpha must be adjusted accordingly. Monaghan (2005) introduced an effective physical kinematic viscosity nu defined as:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"nu = fracalpha h c2d + 4","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where d is the number of spatial dimensions. This relation allows the calibration of alpha to achieve the desired viscous behavior as the resolution or simulation conditions vary.","category":"page"},{"location":"systems/fluid/#ViscosityMorris","page":"Overview","title":"ViscosityMorris","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"ViscosityMorris is ideal for moderate to low Mach number flows where accurately modeling physical viscous behavior is essential. Developed by Morris (1997) and later applied by Fourtakas (2019), this method directly simulates the viscous stresses found in fluids rather than relying on artificial viscosity. By approximating momentum diffusion based on local fluid properties, the method captures the actual viscous forces without excessive damping. This results in a more realistic representation of flow dynamics in weakly compressible scenarios.","category":"page"},{"location":"systems/fluid/#Mathematical-Formulation-2","page":"Overview","title":"Mathematical Formulation","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"An additional force term tildef_ab is introduced to the pressure gradient force f_ab between particles a and b:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"tildef_ab = m_a m_b frac(mu_a + mu_b) r_ab cdot nabla W_abrho_a rho_b (Vert r_ab Vert^2 + epsilon h^2) v_ab","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"mu_a = rho_a nu and mu_b = rho_b nu represent the dynamic viscosities of particles aand b (with nu being the kinematic viscosity),\nr_ab = r_a - r_b represents the difference of the coordinate vectors,\nv_ab = v_a - v_b represents the relative velocity between particles.\nh is the smoothing length,\nnabla W_ab is the gradient of the smoothing kernel,\nepsilon is a small parameter to prevent singularities.","category":"page"},{"location":"systems/fluid/#ViscosityAdami","page":"Overview","title":"ViscosityAdami","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"ViscosityAdami, introduced by Adami (2012), is optimized for incompressible or weakly compressible flows where precise modeling of shear stress is critical. It enhances boundary layer representation by better resolving shear gradients, increasing dissipation in regions with steep velocity differences (e.g., near solid boundaries) while minimizing compressibility effects. This results in accurate laminar flow simulations and accurate physical shear stresses.","category":"page"},{"location":"systems/fluid/#Mathematical-Formulation-3","page":"Overview","title":"Mathematical Formulation","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The viscous interaction is modeled through a shear force for incompressible flows:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"f_ab = sum_w bareta_ab left( V_a^2 + V_b^2 right) fracv_abr_ab^2 + epsilon h_ab^2  (nabla W_ab cdot r_ab)","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"r_ab = r_a - r_b is the difference of the coordinate vectors,\nv_ab = v_a - v_b is their relative velocity,\nV_a = m_a  rho_a and V_b = m_b  rho_b are the particle volumes,\nh_ab is the smoothing length,\nnabla W_ab is the gradient of the smoothing kernel,\nepsilon is a small parameter that prevents singularities (see Ramachandran (2019)).","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The inter-particle-averaged shear stress is defined as:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"bareta_ab = frac2 eta_a eta_beta_a + eta_b","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"with the dynamic viscosity of each particle given by eta_a = rho_a nu_a, where nu_a is the kinematic viscosity.","category":"page"},{"location":"systems/fluid/#TrixiParticles.ArtificialViscosityMonaghan","page":"Overview","title":"TrixiParticles.ArtificialViscosityMonaghan","text":"ArtificialViscosityMonaghan(; alpha, beta=0.0, epsilon=0.01)\n\nArtificial viscosity by Monaghan ([10], [11]).\n\nSee Viscosity for an overview and comparison of implemented viscosity models.\n\nKeywords\n\nalpha: A value of 0.02 is usually used for most simulations. For a relation with the          kinematic viscosity, see description above.\nbeta=0.0: A value of 0.0 works well for most fluid simulations and simulations             with shocks of moderate strength. In simulations where the Mach number can be             very high, eg. astrophysical calculation, good results can be obtained by             choosing a value of beta=2.0 and alpha=1.0.\nepsilon=0.01: Parameter to prevent singularities.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.ViscosityAdami","page":"Overview","title":"TrixiParticles.ViscosityAdami","text":"ViscosityAdami(; nu, epsilon=0.01)\n\nViscosity by Adami (2012).\n\nSee Viscosity for an overview and comparison of implemented viscosity models.\n\nKeywords\n\nnu: Kinematic viscosity\nepsilon=0.01: Parameter to prevent singularities\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.ViscosityAdamiSGS","page":"Overview","title":"TrixiParticles.ViscosityAdamiSGS","text":"ViscosityAdamiSGS(; nu, C_S=0.1, epsilon=0.01)\n\nViscosity model that extends the standard Adami formulation by incorporating a subgrid-scale (SGS) eddy viscosity via a Smagorinsky-type Smagorinsky (1963) closure. The effective kinematic viscosity is defined as\n\nnu_texteff = nu_textstd + nu_textSGS\n\nwith\n\nnu_textSGS = (C_S h)^2 S\n\nand an approximation for the strain rate magnitude given by\n\nS approx fracv_abr_ab + epsilon\n\nwhere:\n\nC_S is the Smagorinsky constant (typically 0.1 to 0.2),\nh is the local smoothing length.\n\nThe effective dynamic viscosities are then computed as\n\neta_atexteff = rho_a nu_texteff\n\nand averaged as\n\nbareta_ab = frac2 eta_atexteff eta_btexteffeta_atexteff+eta_btexteff\n\nThis model is appropriate for turbulent flows where unresolved scales contribute additional dissipation.\n\nKeywords\n\nnu:      Standard kinematic viscosity.\nC_S:     Smagorinsky constant.\nepsilon=0.01: Parameter to prevent singularities\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.ViscosityMorris","page":"Overview","title":"TrixiParticles.ViscosityMorris","text":"ViscosityMorris(; nu, epsilon=0.01)\n\nViscosity by Morris (1997) also used by Fourtakas (2019).\n\nSee Viscosity for an overview and comparison of implemented viscosity models.\n\nKeywords\n\nnu: Kinematic viscosity\nepsilon=0.01: Parameter to prevent singularities\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.ViscosityMorrisSGS","page":"Overview","title":"TrixiParticles.ViscosityMorrisSGS","text":"ViscosityMorrisSGS(; nu, C_S=0.1, epsilon=0.001)\n\nSubgrid-scale (SGS) viscosity model based on the formulation by Morris (1997), by incorporating a subgrid-scale (SGS) eddy viscosity via a Smagorinsky-type Smagorinsky (1963) closure. The effective kinematic viscosity is defined as\n\nnu_texteff = nu_textstd + nu_textSGS\n\nwith\n\nnu_textSGS = (C_S h)^2 S\n\nand an approximation for the strain rate magnitude given by\n\nS approx fracv_abr_ab + epsilon\n\nwhere:\n\nC_S is the Smagorinsky constant (typically 0.1 to 0.2),\nh is the local smoothing length.\n\nThe effective dynamic viscosities are then computed as\n\neta_atexteff = rho_a nu_texteff\n\nand averaged as\n\nbareta_ab = frac2 eta_atexteff eta_btexteffeta_atexteff+eta_btexteff\n\nThis model is appropriate for turbulent flows where unresolved scales contribute additional dissipation.\n\nKeywords\n\nnu:      Standard kinematic viscosity.\nC_S:     Smagorinsky constant.\nepsilon=0.01: Parameter to prevent singularities\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#corrections","page":"Overview","title":"Corrections","text":"","category":"section"},{"location":"systems/fluid/#TrixiParticles.AkinciFreeSurfaceCorrection","page":"Overview","title":"TrixiParticles.AkinciFreeSurfaceCorrection","text":"AkinciFreeSurfaceCorrection(rho0)\n\nFree surface correction according to Akinci et al. (2013). At a free surface, the mean density is typically lower than the reference density, resulting in reduced surface tension and viscosity forces. The free surface correction adjusts the viscosity, pressure, and surface tension forces near free surfaces to counter this effect. It's important to note that this correlation is unphysical and serves as an approximation. The computation time added by this method is about 2–3%.\n\nMathematically the idea is quite simple. If we have an SPH particle in the middle of a volume at rest, its density will be identical to the rest density rho_0. If we now consider an SPH particle at a free surface at rest, it will have neighbors missing in the direction normal to the surface, which will result in a lower density. If we calculate the correction factor\n\nk = rho_0rho_textmean\n\nthis value will be about ~1.5 for particles at the free surface and can then be used to increase the pressure and viscosity accordingly.\n\nArguments\n\nrho0: Rest density.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.BlendedGradientCorrection","page":"Overview","title":"TrixiParticles.BlendedGradientCorrection","text":"BlendedGradientCorrection()\n\nCalculate a blended gradient to reduce the stability issues of the GradientCorrection as explained by Bonet (1999).\n\nThis calculates the following,\n\ntildenabla A_i = (1-lambda) nabla A_i + lambda L_i nabla A_i\n\nwith 0 leq lambda leq 1 being the blending factor.\n\nArguments\n\nblending_factor: Blending factor between corrected and regular SPH gradient.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.GradientCorrection","page":"Overview","title":"TrixiParticles.GradientCorrection","text":"GradientCorrection()\n\nCompute the corrected gradient of particle interactions based on their relative positions (see Bonet, 1999).\n\nMathematical Details\n\nGiven the standard SPH representation, the gradient of a field A at particle a is given by\n\nnabla A_a = sum_b m_b fracA_b - A_arho_b nabla_r_a W(Vert r_a - r_b Vert h)\n\nwhere m_b is the mass of particle b and rho_b is the density of particle b.\n\nThe gradient correction, as commonly proposed, involves multiplying this gradient with a correction matrix L:\n\ntildenabla A_a = bmL_a nabla A_a\n\nThe correction matrix  bmL_a is computed based on the provided particle configuration, aiming to make the corrected gradient more accurate, especially near domain boundaries.\n\nTo satisfy\n\nsum_b V_b r_ba otimes tildenablaW_b(r_a) = left( sum_b V_b r_ba otimes nabla W_b(r_a) right) bmL_a^T = bmI\n\nthe correction matrix bmL_a is evaluated explicitly as\n\nbmL_a = left( sum_b V_b nabla W_b(r_a) otimes r_ba right)^-1\n\nnote: Note\nStability issues arise, especially when particles separate into small clusters.\nDoubles the computational effort.\nBetter stability with smoother smoothing Kernels with larger support, e.g. SchoenbergQuinticSplineKernel or WendlandC6Kernel.\nSet dt_max =< 1e-3 for stability.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.KernelCorrection","page":"Overview","title":"TrixiParticles.KernelCorrection","text":"KernelCorrection()\n\nKernel correction, as explained by Bonet (1999), uses Shepard interpolation to obtain a 0-th order accurate result, which was first proposed by Li et al. This can be further extended to obtain a kernel corrected gradient as shown by Basa et al. (2008).\n\nThe kernel correction coefficient is determined by\n\nc(x) = sum_b=1 V_b W_b(x)\n\nThe gradient of corrected kernel is determined by\n\nnabla tildeW_b(r) =fracnabla W_b(r) - W_b(r) gamma(r)sum_b=1 V_b W_b(r)  quad  textwhere quad\ngamma(r) = fracsum_b=1 V_b nabla W_b(r)sum_b=1 V_b W_b(r)\n\nThis correction can be applied with SummationDensity and ContinuityDensity, which leads to an improvement, especially at free surfaces.\n\nnote: Note\nThis only works when the boundary model uses SummationDensity (yet).\nIt is also referred to as \"0th order correction\".\nIn 2D, we can expect an increase of about 10–15% in computation time.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.MixedKernelGradientCorrection","page":"Overview","title":"TrixiParticles.MixedKernelGradientCorrection","text":"MixedKernelGradientCorrection()\n\nCombines GradientCorrection and KernelCorrection, which results in a 1st-order-accurate SPH method (see Bonet, 1999).\n\nNotes:\n\nStability issues, especially when particles separate into small clusters.\nDoubles the computational effort.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.ShepardKernelCorrection","page":"Overview","title":"TrixiParticles.ShepardKernelCorrection","text":"ShepardKernelCorrection()\n\nKernel correction, as explained by Bonet (1999), uses Shepard interpolation to obtain a 0-th order accurate result, which was first proposed by Li et al. (1996).\n\nThe kernel correction coefficient is determined by\n\nc(x) = sum_b=1 V_b W_b(x)\n\nwhere V_b = m_b  rho_b is the volume of particle b.\n\nThis correction is applied with SummationDensity to correct the density and leads to an improvement, especially at free surfaces.\n\nnote: Note\nIt is also referred to as \"0th order correction\".\nIn 2D, we can expect an increase of about 5–6% in computation time.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"systems/fluid/#surface_normal","page":"Overview","title":"Surface Normals","text":"","category":"section"},{"location":"systems/fluid/#Overview-of-surface-normal-calculation-in-SPH","page":"Overview","title":"Overview of surface normal calculation in SPH","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Surface normals are essential for modeling surface tension as they provide the directionality of forces acting at the fluid interface. They are calculated based on the particle properties and their spatial distribution.","category":"page"},{"location":"systems/fluid/#Color-field-and-gradient-based-surface-normals","page":"Overview","title":"Color field and gradient-based surface normals","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The surface normal at a particle is derived from the color field, a scalar field assigned to particles to distinguish between different fluid phases or between fluid and air. The color field gradients point towards the interface, and the normalized gradient defines the surface normal direction.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The simplest SPH formulation for a surface normal, n_a is given as","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"n_a = sum_b m_b fracc_brho_b nabla_a W_ab","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"c_b is the color field value for particle b,\nm_b is the mass of particle b,\nrho_b is the density of particle b,\nnabla_a W_ab is the gradient of the smoothing kernel W_ab with respect to particle a.","category":"page"},{"location":"systems/fluid/#Normalization-of-surface-normals","page":"Overview","title":"Normalization of surface normals","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The calculated normals are normalized to unit vectors:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"hatn_a = fracn_aVert n_a Vert","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Normalization ensures that the magnitude of the normals does not bias the curvature calculations or the resulting surface tension forces.","category":"page"},{"location":"systems/fluid/#Handling-noise-and-errors-in-normal-calculation","page":"Overview","title":"Handling noise and errors in normal calculation","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"In regions distant from the interface, the calculated normals may be small or inaccurate due to the smoothing kernel's support radius. To mitigate this:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Normals below a threshold are excluded from further calculations.\nCurvature calculations use a corrected formulation to reduce errors near interface fringes.","category":"page"},{"location":"systems/fluid/#TrixiParticles.ColorfieldSurfaceNormal","page":"Overview","title":"TrixiParticles.ColorfieldSurfaceNormal","text":"ColorfieldSurfaceNormal(; boundary_contact_threshold=0.1, interface_threshold=0.01,\n                          ideal_density_threshold=0.0)\n\nColor field based computation of the interface normals.\n\nKeyword Arguments\n\nboundary_contact_threshold=0.1: If this threshold is reached the fluid is assumed to be in contact with the boundary.\ninterface_threshold=0.01:       Threshold for normals to be removed as being invalid.\nideal_density_threshold=0.0:    Assume particles are inside if they are above this threshold, which is relative to the ideal_neighbor_count.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"systems/fluid/#surface_tension","page":"Overview","title":"Surface Tension","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Surface tension is a key phenomenon in fluid dynamics, influencing the behavior of droplets, bubbles, and fluid interfaces. In SPH, surface tension is modeled as forces arising due to surface curvature and relative particle movement, ensuring realistic simulation of capillary effects, droplet coalescence, and fragmentation.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The surface tension coefficient sigma is a physical parameter that quantifies the energy required to increase the surface area of a fluid by a unit amount. A higher value of sigma indicates that the fluid resists changes to its surface area more strongly, causing droplets or bubbles to assume shapes (often spherical) that minimize their surface. In practice, sigma can be measured experimentally through techniques such as the pendant drop method, the Wilhelmy plate method, or the du Noüy ring method, each of which relates a measurable force or change in shape to the fluid’s surface tension. For pure substances, tabulated reference values of sigma at given temperatures are commonly used, while for mixtures or complex fluids, direct experimental measurements or values can be estimated from empirical equation (see Poling or Lange). In the following table some values are shown for reference. The values marked with a '~' are complex mixtures that are estimated by an empirical equation (see Poling).","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Fluid Surface Tension (sigma) [N/m at 20°C]\nGasoline ~0.022   Poling\nEthanol 0.022386 Lange\nAcetone 0.02402  Lange\nMineral Oil ~0.030   Poling\nOlive Oil 0.03303  Hui, MeloEspinosa\nGlycerol 0.06314  Lange\nWater 0.07288  Lange\nMercury 0.486502 Lange","category":"page"},{"location":"systems/fluid/#akinci_ipf","page":"Overview","title":"Akinci-based intra-particle force surface tension and wall adhesion model","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The Akinci model divides surface tension into distinct force components:","category":"page"},{"location":"systems/fluid/#Cohesion-force","page":"Overview","title":"Cohesion force","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The cohesion force captures the attraction between particles at the fluid interface, creating the effect of surface tension. It is defined by the distance between particles and the support radius h_c, using a kernel-based formulation.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Key features:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Particles within half the support radius experience a repulsive force to prevent clustering.\nParticles beyond half the radius but within the support radius experience an attractive force to simulate cohesion.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"Mathematically:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"F_textcohesion = -sigma m_b C(r) fracrVert r Vert","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where C(r), the cohesion kernel, is defined as:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"C(r)=frac32pi h_c^9\nbegincases\n(h_c-r)^3 r^3  textif  2r  h_c \n2(h_c-r)^3 r^3 - frach^664  textif  r  0 text and  2r leq h_c \n0  textotherwise\nendcases","category":"page"},{"location":"systems/fluid/#Surface-area-minimization-force","page":"Overview","title":"Surface area minimization force","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The surface area minimization force models the curvature reduction effects, aligning particle motion to reduce the interface's total area. It acts based on the difference in surface normals:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"F_textcurvature = -sigma (n_a - n_b)","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where n_a and n_b are the surface normals of the interacting particles.","category":"page"},{"location":"systems/fluid/#Wall-adhesion-force","page":"Overview","title":"Wall adhesion force","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"This force models the interaction between fluid and solid boundaries, simulating adhesion effects at walls. It uses a custom kernel with a peak at 0.75 times the support radius:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"F_textadhesion = -beta m_b A(r) fracrVert r Vert","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"where A(r) is the adhesion kernel:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"A(r) = frac0007h_c^325\nbegincases\nsqrt4-frac4r^2h_c + 6r - 2h_c  textif  2r  h_c text and  r leq h_c \n0  textotherwise\nendcases","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"systems/fluid/#morris_csf","page":"Overview","title":"Morris surface tension model","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The method described by Morris estimates curvature by combining particle color gradients (see surface_normal) and smoothing functions to derive surface normals. The computed curvature is then used to determine forces acting perpendicular to the interface. While this method provides accurate surface tension forces, it does not explicitly conserve momentum.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"In the Morris model, surface tension is computed based on local interface curvature kappa and the unit surface normal hatn By estimating hatn and kappa at each particle near the interface, the surface tension force for particle a can be written as:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"F_textsurface tension = - sigma frackappa_arho_ahatn_a","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"This formulation focuses directly on geometric properties of the interface, making it relatively straightforward to implement when a reliable interface detection (e.g., a color function) is available. However, accurately estimating kappa and n may require fine resolutions.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"systems/fluid/#moriss_css","page":"Overview","title":"Morris-based momentum-conserving surface tension model","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"In addition to the simpler curvature-based formulation, Morris introduced a momentum-conserving approach. This method treats surface tension forces as arising from the divergence of a stress tensor, ensuring exact conservation of linear momentum and offering more robust behavior for high-resolution or long-duration simulations where accumulated numerical error can be significant.","category":"page"},{"location":"systems/fluid/#Stress-tensor-formulation","page":"Overview","title":"Stress tensor formulation","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"The surface tension force can be seen as a divergence of a stress tensor S","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"F_textsurface tension = nabla cdot S","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"with S defined as","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"S = sigma delta_s (I - hatn otimes hatn)","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"with:","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"delta_s: Surface delta function,\nhatn: Unit normal vector,\nI: Identity matrix.","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"This divergence can be computed numerically in the SPH framework as","category":"page"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"sum_b fracm_brho_a rho_b (S_a + S_b) nabla W_ab","category":"page"},{"location":"systems/fluid/#Advantages-and-limitations","page":"Overview","title":"Advantages and limitations","text":"","category":"section"},{"location":"systems/fluid/","page":"Overview","title":"Overview","text":"While momentum conservation makes this model attractive, it requires additional computational effort and stabilization techniques to address instabilities in high-density regions.","category":"page"},{"location":"systems/fluid/#API","page":"Overview","title":"API","text":"","category":"section"},{"location":"systems/fluid/#TrixiParticles.CohesionForceAkinci","page":"Overview","title":"TrixiParticles.CohesionForceAkinci","text":"CohesionForceAkinci(surface_tension_coefficient=1.0)\n\nThis model only implements the cohesion force of the Akinci [18] surface tension model.\n\nSee surface_tension for more details.\n\nKeywords\n\nsurface_tension_coefficient=1.0: Modifies the intensity of the surface tension-induced force,  enabling the tuning of the fluid's surface tension properties within the simulation.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.SurfaceTensionAkinci","page":"Overview","title":"TrixiParticles.SurfaceTensionAkinci","text":"SurfaceTensionAkinci(surface_tension_coefficient=1.0)\n\nImplements a model for surface tension and adhesion effects drawing upon the principles outlined by Akinci [18]. This model is instrumental in capturing the nuanced behaviors of fluid surfaces, such as droplet formation and the dynamics of merging or separation, by utilizing intra-particle forces.\n\nSee surface_tension for more details.\n\nKeywords\n\nsurface_tension_coefficient=1.0: A parameter to adjust the magnitude of  surface tension forces, facilitating the fine-tuning of how surface tension phenomena  are represented in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.SurfaceTensionMomentumMorris","page":"Overview","title":"TrixiParticles.SurfaceTensionMomentumMorris","text":"SurfaceTensionMomentumMorris(surface_tension_coefficient=1.0)\n\nThis model implements the momentum-conserving surface tension approach outlined by Morris [26]. It calculates surface tension forces using the divergence of a stress tensor, ensuring exact conservation of linear momentum. This method is particularly useful for simulations where momentum conservation is critical, though it may require numerical adjustments at higher resolutions.\n\nSee surface_tension for more details.\n\nKeywords\n\nsurface_tension_coefficient=1.0: A parameter to adjust the strength of surface tension  forces, allowing fine-tuning to replicate physical behavior.\n\n\n\n\n\n","category":"type"},{"location":"systems/fluid/#TrixiParticles.SurfaceTensionMorris","page":"Overview","title":"TrixiParticles.SurfaceTensionMorris","text":"SurfaceTensionMorris(surface_tension_coefficient=1.0)\n\nThis model implements the surface tension approach described by Morris [26]. It calculates surface tension forces based on the curvature of the fluid interface using particle normals and their divergence, making it suitable for simulating phenomena like droplet formation and capillary wave dynamics.\n\nSee surface_tension for more details.\n\nKeywords\n\nsurface_tension_coefficient=1.0: Adjusts the magnitude of the surface tension  forces, enabling tuning of fluid surface behaviors in simulations.\n\n\n\n\n\n","category":"type"},{"location":"systems/entropically_damped_sph/#edac","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility (EDAC) for SPH","text":"","category":"section"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"As opposed to the weakly compressible SPH scheme, which uses an equation of state, this scheme uses a pressure evolution equation to calculate the pressure","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"fracmathrmd p_amathrmdt =  - rho c_s^2 nabla cdot v + nu nabla^2 p","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"which is derived by Clausen (2013). This equation is similar to the continuity equation (first term, see ContinuityDensity), but also contains a pressure damping term (second term, similar to density diffusion see DensityDiffusion), which reduces acoustic pressure waves through an entropy-generation mechanism.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The pressure evolution is discretized with the SPH method by Ramachandran (2019) as following:","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The first term is equivalent to the classical artificial compressible methods, which are commonly motivated by assuming the artificial equation of state (StateEquationCole with exponent=1) and is discretized as","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"- rho c_s^2 nabla cdot v = sum_b m_b fracrho_arho_b c_s^2 v_ab cdot nabla_r_a W(Vert r_a - r_b Vert h)","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where rho_a, rho_b,  r_a, r_b, denote the density and coordinates of particles a and b respectively, c_s is the speed of sound and v_ab = v_a - v_b is the difference in the velocity.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The second term smooths the pressure through the introduction of entropy and is discretized as","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"nu nabla^2 p = fracV_a^2 + V_b^2m_a tildeeta_ab fracp_abVert r_ab^2 Vert + eta h_ab^2 nabla_r_a\nW(Vert r_a - r_b Vert h) cdot r_ab","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where V_a, V_b denote the volume of particles a and b respectively and p_ab= p_a -p_b  is the difference in the pressure.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The viscosity parameter eta_a for a particle a is given as","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"eta_a = rho_a fracalpha h c_s8","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where it is found in the numerical experiments of Ramachandran (2019) that alpha = 05 is a good choice for a wide range of Reynolds numbers (0.0125 to 10000).","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"note: Note\nThe EDAC formulation keeps the density constant and this eliminates the need for the continuity equation or the use of a summation density to ﬁnd the pressure. However, in SPH discretizations, mrho is typically used as a proxy for the particle volume. The density of the ﬂuids can therefore be computed using the summation density approach. [16]","category":"page"},{"location":"systems/entropically_damped_sph/#TrixiParticles.EntropicallyDampedSPHSystem","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"TrixiParticles.EntropicallyDampedSPHSystem","text":"EntropicallyDampedSPHSystem(initial_condition, smoothing_kernel,\n                            smoothing_length, sound_speed;\n                            pressure_acceleration=inter_particle_averaged_pressure,\n                            density_calculator=SummationDensity(),\n                            transport_velocity=nothing,\n                            alpha=0.5, viscosity=nothing,\n                            acceleration=ntuple(_ -> 0.0, NDIMS), surface_tension=nothing,\n                            surface_normal_method=nothing, buffer_size=nothing,\n                            reference_particle_spacing=0.0, source_terms=nothing)\n\nSystem for particles of a fluid. As opposed to the weakly compressible SPH scheme, which uses an equation of state, this scheme uses a pressure evolution equation to calculate the pressure. See Entropically Damped Artificial Compressibility for SPH for more details on the method.\n\nArguments\n\ninitial_condition:  Initial condition representing the system's particles.\nsound_speed:        Speed of sound.\nsmoothing_kernel:   Smoothing kernel to be used for this system.                       See Smoothing Kernels.\nsmoothing_length:   Smoothing length to be used for this system.                       See Smoothing Kernels.\n\nKeyword Arguments\n\nviscosity:                  Viscosity model for this system (default: no viscosity).                               Recommended: ViscosityAdami.\nacceleration:               Acceleration vector for the system. (default: zero vector)\npressure_acceleration:      Pressure acceleration formulation (default: inter-particle averaged pressure).                               When set to nothing, the pressure acceleration formulation for the                               corresponding density calculator is chosen.\ndensity_calculator:         Density calculator (default: SummationDensity)\ntransport_velocity:         Transport Velocity Formulation (TVF). Default is no TVF.\nbuffer_size:                Number of buffer particles.                               This is needed when simulating with OpenBoundarySPHSystem.\ncorrection:                 Correction method used for this system. (default: no correction, see Corrections)\nsource_terms:               Additional source terms for this system. Has to be either nothing                               (by default), or a function of (coords, velocity, density, pressure, t)                               (which are the quantities of a single particle), returning a Tuple                               or SVector that is to be added to the acceleration of that particle.                               See, for example, SourceTermDamping.                               Note that these source terms will not be used in the calculation of the                               boundary pressure when using a boundary with                               BoundaryModelDummyParticles and AdamiPressureExtrapolation.                               The keyword argument acceleration should be used instead for                               gravity-like source terms.\nsurface_tension:            Surface tension model used for this SPH system. (default: no surface tension)\nsurface_normal_method:      The surface normal method to be used for this SPH system.                               (default: no surface normal method or ColorfieldSurfaceNormal() if a surface_tension model is used)\nreference_particle_spacing: The reference particle spacing used for weighting values at the boundary,                               which currently is only needed when using surface tension.\ncolor_value:                The value used to initialize the color of particles in the system.\n\n\n\n\n\n","category":"type"},{"location":"systems/entropically_damped_sph/#transport_velocity_formulation","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Transport Velocity Formulation (TVF)","text":"","category":"section"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"Standard SPH suffers from problems like tensile instability or the creation of void regions in the flow. To address these problems, Adami (2013) modified the advection velocity and added an extra term to the momentum equation. The authors introduced the so-called Transport Velocity Formulation (TVF) for WCSPH. Ramachandran (2019) applied the TVF also for the EDAC scheme.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The transport velocity tildev_a of particle a is used to evolve the position of the particle r_a from one time step to the next by","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"fracmathrmd r_amathrmdt = tildev_a","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"and is obtained at every time-step Delta t from","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"tildev_a (t + Delta t) = v_a (t) + Delta t left(fractildemathrmd v_amathrmdt - frac1rho_a nabla p_textbackground right)","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where rho_a is the density of particle a and p_textbackground is a constant background pressure field. The tilde in the second term of the right hand side indicates that the material derivative has an advection part.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The discretized form of the last term is","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":" -frac1rho_a nabla p_textbackground approx  -fracp_textbackgroundm_a sum_b left(V_a^2 + V_b^2 right) nabla_a W_ab","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where V_a, V_b denote the volume of particles a and b respectively. Note that although in the continuous case nabla p_textbackground = 0, the discretization is not 0th-order consistent for non-uniform particle distribution, which means that there is a non-vanishing contribution only when particles are disordered. That also means that p_textbackground occurs as prefactor to correct the trajectory of a particle resulting in uniform pressure distributions. Suggested is a background pressure which is in the order of the reference pressure but can be chosen arbitrarily large when the time-step criterion is adjusted.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The inviscid momentum equation with an additional convection term for a particle moving with tildev is","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"fractildemathrmd left( rho v right)mathrmdt = -nabla p +  nabla cdot bmA","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"where the tensor bmA = rho vleft(tildev-vright)^T is a consequence of the modified  advection velocity and can be interpreted as the convection of momentum with the relative velocity tildev-v.","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"The discretized form of the momentum equation for a particle a reads as","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"fractildemathrmd v_amathrmdt = frac1m_a sum_b left(V_a^2 + V_b^2 right) left -tildep_ab nabla_a W_ab + frac12 left(bmA_a + bmA_b right) cdot nabla_a W_ab right","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"Here, tildep_ab is the density-weighted pressure","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"tildep_ab = fracrho_b p_a + rho_a p_brho_a + rho_b","category":"page"},{"location":"systems/entropically_damped_sph/","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"Entropically Damped Artificial Compressibility for SPH (Fluid)","text":"with the density  rho_a,  rho_b and the pressure  p_a,  p_b of particles a and b respectively. bmA_a and bmA_b are the convection tensors for particle a and b respectively and are given, e.g. for particle a, as bmA_a = rho v_aleft(tildev_a-v_aright)^T.","category":"page"},{"location":"systems/entropically_damped_sph/#TrixiParticles.TransportVelocityAdami","page":"Entropically Damped Artificial Compressibility for SPH (Fluid)","title":"TrixiParticles.TransportVelocityAdami","text":"TransportVelocityAdami(background_pressure::Real)\n\nTransport Velocity Formulation (TVF) to suppress pairing and tensile instability. See TVF for more details of the method.\n\nArguments\n\nbackground_pressure: Background pressure. Suggested is a background pressure which is                        on the order of the reference pressure.\n\nnote: Note\nThere is no need for an artificial viscosity to suppress tensile instability when using TransportVelocityAdami. Thus, it is highly recommended to use ViscosityAdami as viscosity model, since ArtificialViscosityMonaghan leads to bad results.\n\n\n\n\n\n","category":"type"},{"location":"authors/#Authors","page":"Authors","title":"Authors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"TrixiParticles.jl's development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about TrixiParticles.jl. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The TrixiParticles.jl Authors\" as mentioned under License.","category":"page"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"Erik Faulhaber, University of Cologne, Germany\nNiklas Neher, High-Performance Computing Center Stuttgart (HLRS), Germany\nSven Berger, Helmholtz Center Hereon, Germany","category":"page"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"","category":"section"},{"location":"authors/","page":"Authors","title":"Authors","text":"The following people contributed major additions or modifications to TrixiParticles.jl and are listed in alphabetical order:","category":"page"},{"location":"authors/","page":"Authors","title":"Authors","text":"Sven Berger\nErik Faulhaber\nGregor Gassner\nNiklas Neher\nHendrik Ranocha\nMichael Schlottke-Lakemper","category":"page"},{"location":"tutorials_template/tut_dam_break/#Example-file","page":"Example file","title":"Example file","text":"","category":"section"},{"location":"tutorials_template/tut_dam_break/","page":"Example file","title":"Example file","text":"!!include:examples/fluid/dam_break_2d.jl!!\n","category":"page"},{"location":"tutorials/tut_setup/#Setting-up-your-simulation-from-scratch","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In this tutorial, we will guide you through the general structure of simulation files. We will set up a simulation similar to the example simulation examples/fluid/dam_break_2d.jl, which is one of our simplest example simulations. In the second part of this tutorial, we will show how to replace components of TrixiParticles.jl by custom implementations from within a simulation file, without ever cloning the repository.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"For different setups and physics, have a look at our other example files.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"First, we import TrixiParticles.jl and OrdinaryDiffEq.jl, which we will use at the very end for the time integration.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using TrixiParticles\nusing OrdinaryDiffEq","category":"page"},{"location":"tutorials/tut_setup/#Resolution","page":"Setting up your simulation from scratch","title":"Resolution","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Now, we define the particle spacing, which is our numerical resolution. For a fluid, we usually call the variable fluid_particle_spacing, so that we can easily change the resolution of an example file by overwriting this variable with trixi_include. In 2D, the number of particles will grow quadratically, in 3D cubically with the spacing.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We also set the number of boundary layers, which need to be sufficiently large, depending on the smoothing kernel and smoothing length, so that the compact support of the smoothing kernel is fully sampled with particles for a fluid particle close to a boundary. In particular, we require the boundary thickness boundary_layers * fluid_particle_spacing to be larger than the compact support of the kernel. The compact support of each kernel can be found in the smoothing kernel overview.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"fluid_particle_spacing = 0.02\nboundary_layers = 3\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/#Experiment-setup","page":"Setting up your simulation from scratch","title":"Experiment setup","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We want to simulate a small dam break problem inside a rectangular tank. (Image: Experiment Setup) First, we define physical parameters like gravitational acceleration, simulation time, initial fluid size, tank size and fluid density.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"gravity = 9.81\ntspan = (0.0, 1.0)\ninitial_fluid_size = (1.0, 0.5)\ntank_size = (2.0, 1.0)\nfluid_density = 1000.0\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In order to have the initial particle mass and density correspond to the hydrostatic pressure gradient, we need to define a state equation, which relates the fluid density to pressure. Note that we could also skip this part here and define the state equation later when we define the fluid system, but then the fluid would be initialized with constant density, which would cause it to oscillate under gravity.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"sound_speed = 10.0\nstate_equation = StateEquationCole(; sound_speed, reference_density=fluid_density,\n                                   exponent=7)\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"The speed of sound here is numerical and not physical. We artificially lower the speed of sound, since the physical speed of sound in water would lead to prohibitively small time steps. The speed of sound in Weakly Compressible SPH should be chosen as small as possible for numerical efficiency, but large enough to limit density fluctuations to about 1%. We usually choose the speed of sound as 10 v_textmax, where v_textmax is the largest velocity in the simulation. This can also be done by approximating the expected maximum velocity. For example, in dam break simulations, the speed of sound is often chosen as 10 sqrtgH, where H is the initial height of the water column and g is the gravitational acceleration, using the shallow water wave velocity as an estimate. See e.g. Adami et al., 2012.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"TrixiParticles.jl requires the initial particle positions and quantities in form of an InitialCondition. Instead of manually defining particle positions, you can work with our pre-defined setups. Among others, we provide setups for rectangular shapes, circles, and spheres. Initial conditions can also be combined with common set operations. See this page for a list of pre-defined setups and details on set operations on initial conditions.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Here, we use the RectangularTank setup, which generates a rectangular fluid inside a rectangular tank, and supports a hydrostatic pressure gradient by passing a gravitational acceleration and a state equation (see above).","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"tank = RectangularTank(fluid_particle_spacing, initial_fluid_size, tank_size,\n                       fluid_density, n_layers=boundary_layers,\n                       acceleration=(0.0, -gravity), state_equation=state_equation)\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"A RectangularTank consists of two InitialConditions, tank.fluid and tank.boundary. We can plot these initial conditions to visualize the initial setup.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using Plots\nplot(tank.fluid, tank.boundary, labels=[\"fluid\" \"boundary\"])\nplot!(dpi=200); savefig(\"tut_setup_plot_tank.png\"); nothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"(Image: plot tank)","category":"page"},{"location":"tutorials/tut_setup/#Fluid-system","page":"Setting up your simulation from scratch","title":"Fluid system","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"To model the water column, we use the Weakly Compressible Smoothed Particle Hydrodynamics (WCSPH) method. This method requires a smoothing kernel and a corresponding smoothing length, which should be chosen in relation to the particle spacing.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"smoothing_length = 1.2 * fluid_particle_spacing\nsmoothing_kernel = SchoenbergCubicSplineKernel{2}()\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"You can find an overview over smoothing kernels and corresponding smoothing lengths here.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"For stability, we need numerical dissipation in form of an artificial viscosity term. Other viscosity models offer a physical approach based on the kinematic viscosity of the fluid.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"viscosity = ArtificialViscosityMonaghan(alpha=0.02, beta=0.0)\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We choose the parameters as small as possible to avoid non-physical behavior, but as large as possible to stabilize the simulation.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"The WCSPH method can either compute the particle density directly with a kernel summation over all neighboring particles (see SummationDensity) or by making the particle density a variable in the ODE system and integrating its change over time. We choose the latter approach here by using the density calculator ContinuityDensity, which is more efficient and handles free surfaces without the need for additional correction terms. The simulation quality greatly benefits from using density diffusion.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"fluid_density_calculator = ContinuityDensity()\ndensity_diffusion = DensityDiffusionMolteniColagrossi(delta=0.1)\nfluid_system = WeaklyCompressibleSPHSystem(tank.fluid, fluid_density_calculator,\n                                           state_equation, smoothing_kernel,\n                                           smoothing_length, viscosity=viscosity,\n                                           density_diffusion=density_diffusion,\n                                           acceleration=(0.0, -gravity))\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/#Boundary-system","page":"Setting up your simulation from scratch","title":"Boundary system","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"To model the boundary, we use particle-based boundary conditions, in which particles are sampled in the boundary that interact with the fluid particles to avoid penetration. In order to define a boundary system, we first have to choose a boundary model, which defines how the fluid interacts with boundary particles. We will use the BoundaryModelDummyParticles with AdamiPressureExtrapolation. See here for a comprehensive overview over boundary models.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"boundary_model = BoundaryModelDummyParticles(tank.boundary.density, tank.boundary.mass,\n                                             state_equation=state_equation,\n                                             AdamiPressureExtrapolation(),\n                                             smoothing_kernel, smoothing_length)\nboundary_system = BoundarySPHSystem(tank.boundary, boundary_model)\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/#Semidiscretization","page":"Setting up your simulation from scratch","title":"Semidiscretization","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"The key component of every simulation is the Semidiscretization, which couples all systems of the simulation. All simulation methods in TrixiParticles.jl are semidiscretizations, which discretize the equations in space to provide an ordinary differential equation that still has to be solved in time. By providing a simulation time span, we can call semidiscretize, which returns an ODEProblem that can be solved with a time integration method.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"semi = Semidiscretization(fluid_system, boundary_system)\node = semidiscretize(semi, tspan)\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/#Time-integration","page":"Setting up your simulation from scratch","title":"Time integration","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We use the methods provided by OrdinaryDiffEq.jl, but note that other packages or custom implementations can also be used.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"OrdinaryDiffEq.jl supports callbacks, which are executed during the simulation. For this simulation, we use the InfoCallback, which prints information about the simulation setup at the beginning of the simulation, information about the current simulation time and runtime during the simulation, and a performance summary at the end of the simulation. We also want to save the current solution in regular intervals in terms of simulation time as VTK, so that we can look at the solution in ParaView. The SolutionSavingCallback provides this functionality. To pass the callbacks to OrdinaryDiffEq.jl, we have to bundle them into a CallbackSet.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"info_callback = InfoCallback(interval=50)\nsaving_callback = SolutionSavingCallback(dt=0.02)\n\ncallbacks = CallbackSet(info_callback, saving_callback)\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Finally, we can start the simulation by solving the ODEProblem. We use the method RDPK3SpFSAL35 of OrdinaryDiffEq.jl, which is a Runge-Kutta method with automatic (error based) time step size control. This method is usually a good choice for prototyping, since we do not have to worry about choosing a stable step size and can just run the simulation. For better performance, it might be beneficial to tweak the tolerances of this method or choose a different method that is more efficient for the respective simulation. You can find both approaches in our example files. Here, we just use the method with the default parameters, and only disable save_everystep to avoid expensive saving of the solution in every time step.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"See Visualization for how to visualize the final solution. For the simplest visualization, we can use Plots.jl:","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using Plots\nplot(sol)\nplot!(dpi=200); savefig(\"tut_setup_plot.png\"); nothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"(Image: plot)","category":"page"},{"location":"tutorials/tut_setup/#Replacing-components-with-custom-implementations","page":"Setting up your simulation from scratch","title":"Replacing components with custom implementations","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"If we would like to use an implementation of a component that is not available in TrixiParticles.jl, we can implement it ourselves within the simulation file, without ever cloning the TrixiParticles.jl repository. A good starting point is to check out the available implementations in TrixiParticles.jl, then copy the relevant functions to the simulation file and modify them as needed.","category":"page"},{"location":"tutorials/tut_setup/#Custom-smoothing-kernel","page":"Setting up your simulation from scratch","title":"Custom smoothing kernel","text":"","category":"section"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"To implement a custom smoothing kernel, we define a struct extending TrixiParticles.SmoothingKernel. This abstract struct has a type parameter for the number of dimensions, which we set to 2 in this case.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"struct MyGaussianKernel <: TrixiParticles.SmoothingKernel{2} end","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"This kernel is going to be an implementation of the Gaussian kernel with a cutoff for compact support, which reads","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"W(r h) =\nbegincases\nfrac1pi h^2 exp(-(rh)^2)  textfor  r  2h\n0  textfor  r geq 2h\nendcases","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"Note that the same kernel in a more optimized version and with a cutoff at 3 is already implemented in TrixiParticles.jl as GaussianKernel.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In order to use our new kernel, we have to define three functions. TrixiParticles.kernel, which is the kernel function itself, TrixiParticles.kernel_deriv, which is the derivative of the kernel function, and TrixiParticles.compact_support, which defines the compact support of the kernel in relation to the smoothing length. The latter is relevant for determining the search radius of the neighborhood search.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"function TrixiParticles.kernel(kernel::MyGaussianKernel, r, h)\n    q = r / h\n\n    if q < 2\n        return 1 / (pi * h^2) * exp(-q^2)\n    end\n\n    return 0.0\nend\n\nfunction TrixiParticles.kernel_deriv(kernel::MyGaussianKernel, r, h)\n    q = r / h\n\n    if q < 2\n        return 1 / (pi * h^2)  * (-2 * q) * exp(-q^2) / h\n    end\n\n    return 0.0\nend\n\nTrixiParticles.compact_support(::MyGaussianKernel, h) = 2 * h","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"For this kernel, we use a different smoothing length, which yields a similar kernel to the SchoenbergCubicSplineKernel that we used earlier.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"smoothing_length_gauss = 1.0 * fluid_particle_spacing\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"We can compare these kernels in a plot.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"using Plots\nx = range(-0.05, 0.05, length=500)\nplot(x, r -> TrixiParticles.kernel(SchoenbergCubicSplineKernel{2}(), abs(r), smoothing_length),\n     label=\"SchoenbergCubicSplineKernel\", xlabel=\"r\")\nplot!(x, r -> TrixiParticles.kernel(MyGaussianKernel(), abs(r), smoothing_length_gauss),\n      label=\"MyGaussianKernel\")\nplot!(dpi=200); savefig(\"tut_setup_plot2.png\"); nothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"(Image: plot)","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"This is all we need to use our custom kernel implementation in a simulation. We only need to replace the definition above by","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"smoothing_kernel = MyGaussianKernel()\nnothing # hide","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"and run the simulation file again.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"In order to use our kernel in a pre-defined example file, we can use the function trixi_include to replace the definition of the variable smoothing_kernel. The following will run the example simulation examples/fluid/hydrostatic_water_column_2d.jl with our custom kernel and the corresponding smoothing length.","category":"page"},{"location":"tutorials/tut_setup/","page":"Setting up your simulation from scratch","title":"Setting up your simulation from scratch","text":"","category":"page"},{"location":"systems/total_lagrangian_sph/#tlsph","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH","text":"","category":"section"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"A Total Lagrangian framework is used wherein the governing equations are formulated such that all relevant quantities and operators are measured with respect to the initial configuration (O’Connor & Rogers, 2021, Belytschko et al., 2000).","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The governing equations with respect to the initial configuration are given by:","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"fracmathrmDbmvmathrmDt = frac1rho_0 nabla_0 cdot bmP + bmg","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"where the zero subscript denotes a derivative with respect to the initial configuration and bmP is the first Piola-Kirchhoff (PK1) stress tensor.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The discretized version of this equation is given by O’Connor & Rogers (2021):","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"fracmathrmdbmv_amathrmdt = sum_b m_0b\n    left( fracbmP_a bmL_0arho_0a^2 + fracbmP_b bmL_0brho_0b^2 right)\n    nabla_0a W(bmX_ab) + fracbmf_a^PFm_0a + bmg","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"with the correction matrix (see also GradientCorrection)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmL_0a = left( -sum_b fracm_0brho_0b nabla_0a W(bmX_ab) bmX_ab^T right)^-1 in R^d times d","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The subscripts a and b denote quantities of particle a and b, respectively. The zero subscript on quantities denotes that the quantity is to be measured in the initial configuration. The difference in the initial coordinates is denoted by bmX_ab = bmX_a - bmX_b, the difference in the current coordinates is denoted by bmx_ab = bmx_a - bmx_b.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"For the computation of the PK1 stress tensor, the deformation gradient bmF is computed per particle as","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmF_a = sum_b fracm_0brho_0b bmx_ba (bmL_0anabla_0a W(bmX_ab))^T \n    qquad  = -left(sum_b fracm_0brho_0b bmx_ab (nabla_0a W(bmX_ab))^T right) bmL_0a^T","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"with 1 leq ij leq d. From the deformation gradient, the Green-Lagrange strain","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmE = frac12(bmF^TbmF - bmI)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"and the second Piola-Kirchhoff stress tensor","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmS = lambda operatornametr(bmE) bmI + 2mu bmE","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"are computed to obtain the PK1 stress tensor as","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmP = bmFbmS","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Here,","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"mu = fracE2(1 + nu)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"and","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"lambda = fracEnu(1 + nu)(1 - 2nu)","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"are the Lamé coefficients, where E is the Young's modulus and nu is the Poisson ratio.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The term bmf_a^PF is an optional penalty force. See e.g. PenaltyForceGanzenmueller.","category":"page"},{"location":"systems/total_lagrangian_sph/#TrixiParticles.TotalLagrangianSPHSystem","page":"Total Lagrangian SPH (Elastic Structure)","title":"TrixiParticles.TotalLagrangianSPHSystem","text":"TotalLagrangianSPHSystem(initial_condition,\n                         smoothing_kernel, smoothing_length,\n                         young_modulus, poisson_ratio;\n                         n_fixed_particles=0, boundary_model=nothing,\n                         acceleration=ntuple(_ -> 0.0, NDIMS),\n                         penalty_force=nothing, source_terms=nothing)\n\nSystem for particles of an elastic structure.\n\nA Total Lagrangian framework is used wherein the governing equations are formulated such that all relevant quantities and operators are measured with respect to the initial configuration (O’Connor & Rogers 2021, Belytschko et al. 2000). See Total Lagrangian SPH for more details on the method.\n\nArguments\n\ninitial_condition:  Initial condition representing the system's particles.\nyoung_modulus:      Young's modulus.\npoisson_ratio:      Poisson ratio.\nsmoothing_kernel:   Smoothing kernel to be used for this system.                       See Smoothing Kernels.\nsmoothing_length:   Smoothing length to be used for this system.                       See Smoothing Kernels.\n\nKeyword Arguments\n\nn_fixed_particles:  Number of fixed particles which are used to clamp the structure                       particles. Note that the fixed particles must be the last                       particles in the InitialCondition. See the info box below.\nboundary_model: Boundary model to compute the hydrodynamic density and pressure for                   fluid-structure interaction (see Boundary Models).\npenalty_force:  Penalty force to ensure regular particle position under large deformations                   (see PenaltyForceGanzenmueller).\nacceleration:   Acceleration vector for the system. (default: zero vector)\nsource_terms:   Additional source terms for this system. Has to be either nothing                   (by default), or a function of (coords, velocity, density, pressure)                   (which are the quantities of a single particle), returning a Tuple                   or SVector that is to be added to the acceleration of that particle.                   See, for example, SourceTermDamping.\n\nnote: Note\nThe fixed particles must be the last particles in the InitialCondition. To do so, e.g. use the union function:solid = union(beam, fixed_particles)where beam and fixed_particles are of type InitialCondition.\n\n\n\n\n\n","category":"type"},{"location":"systems/total_lagrangian_sph/#Penalty-Force","page":"Total Lagrangian SPH (Elastic Structure)","title":"Penalty Force","text":"","category":"section"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"In FEM, underintegrated elements can deform without an associated increase of energy. This is caused by the stiffness matrix having zero eigenvalues (so-called hourglass modes). The name \"hourglass modes\" comes from the fact that elements can deform into an hourglass shape.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Similar effects can occur in SPH as well. Particles can change positions without changing the SPH approximation of the deformation gradient bmF, thus, without causing an increase of energy. To ensure regular particle positions, we can apply similar correction forces as are used in FEM.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"Ganzenmüller (2015) introduced a so-called hourglass correction force or penalty force f^PF, which is given by","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"bmf_a^PF = frac12 alpha sum_b fracm_0a m_0b W_0abrho_0arho_0b bmX_ab^2\n                left( E delta_ab^a + E delta_ba^b right) fracbmx_abbmx_ab","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"The subscripts a and b denote quantities of particle a and b, respectively. The zero subscript on quantities denotes that the quantity is to be measured in the initial configuration. The difference in the initial coordinates is denoted by bmX_ab = bmX_a - bmX_b, the difference in the current coordinates is denoted by bmx_ab = bmx_a - bmx_b. Note that Ganzenmüller (2015) has a flipped sign here because they define bmx_ab the other way around.","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"This correction force is based on the potential energy density of a Hookean material. Thus, E is the Young's modulus and alpha is a dimensionless coefficient that controls the amplitude of hourglass correction. The separation vector delta_ab^a indicates the change of distance which the particle separation should attain in order to minimize the error and is given by","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"    delta_ab^a = fracbmepsilon_ab^a cdot bmx_abbmx_ab","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"where the error vector is defined as","category":"page"},{"location":"systems/total_lagrangian_sph/","page":"Total Lagrangian SPH (Elastic Structure)","title":"Total Lagrangian SPH (Elastic Structure)","text":"    bmepsilon_ab^a = bmF_a bmX_ab - bmx_ab","category":"page"},{"location":"systems/total_lagrangian_sph/#TrixiParticles.PenaltyForceGanzenmueller","page":"Total Lagrangian SPH (Elastic Structure)","title":"TrixiParticles.PenaltyForceGanzenmueller","text":"PenaltyForceGanzenmueller(; alpha=0.1)\n\nPenalty force to ensure regular particle positions under large deformations.\n\nKeywords\n\nalpha: Coefficient to control the amplitude of hourglass correction.\n\n\n\n\n\n","category":"type"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2023-present The TrixiParticles.jl Authors (see Authors) \nCopyright (c) 2023-present Helmholtz-Zentrum hereon GmbH, Institute of Surface Science \n \nPermission is hereby granted, free of charge, to any person obtaining a copy   of this software and associated documentation files (the \"Software\"), to deal   in the Software without restriction, including without limitation the rights   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell   copies of the Software, and to permit persons to whom the Software is   furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all   copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.","category":"page"},{"location":"getting_started/#getting_started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you have not installed TrixiParticles.jl, please follow the instructions given here.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In the following sections, we will give a short introduction. For a more thorough discussion, take a look at our Tutorials.","category":"page"},{"location":"getting_started/#Running-an-Example","page":"Getting started","title":"Running an Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The easiest way to run a simulation is to run one of our predefined example files. We will run the file examples/fluid/hydrostatic_water_column_2d.jl, which simulates a fluid resting in a rectangular tank. Since TrixiParticles.jl uses multithreading, you should start Julia with the flag --threads auto (or, e.g. --threads 4 for 4 threads).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In the Julia REPL, first load the package TrixiParticles.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> using TrixiParticles","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Then start the simulation by executing","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> trixi_include(joinpath(examples_dir(), \"fluid\", \"hydrostatic_water_column_2d.jl\"))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The easiest way to quickly visualize the result is to use Plots.jl:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> using Plots; plot(sol)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This will open a new window with a 2D visualization of the final solution: (Image: plot_hydrostatic_water_column)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For more information about visualization, see Visualization.","category":"page"},{"location":"getting_started/#Running-other-Examples","page":"Getting started","title":"Running other Examples","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You can find a list of our other predefined examples under Examples. Execute them as follows from the Julia REPL by replacing subfolder and example_name","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> trixi_include(joinpath(examples_dir(), \"subfolder\", \"example_name.jl\"))","category":"page"},{"location":"getting_started/#Modifying-an-example","page":"Getting started","title":"Modifying an example","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"You can pass keyword arguments to the function trixi_include to overwrite assignments in the file.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"With trixi_include, we can overwrite variables defined in the example file to run a different simulation without modifying the example file.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> trixi_include(joinpath(examples_dir(), \"fluid\", \"hydrostatic_water_column_2d.jl\"), initial_fluid_size=(1.0, 0.5))","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This for example, will change the fluid size from (09 10) to (10 05).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To understand why, take a look into the file hydrostatic_water_column_2d.jl in the subfolder fluid inside the examples directory, which is the file that we executed earlier. You can see that the initial size of the fluid is defined in the variable initial_fluid_size, which we could overwrite with the trixi_include call above. Another variable that is worth experimenting with is fluid_particle_spacing, which controls the resolution of the simulation in this case. A lower value will increase the resolution and the runtime.","category":"page"},{"location":"getting_started/#Set-up-you-first-simulation-from-scratch","page":"Getting started","title":"Set up you first simulation from scratch","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"See Set up your first simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Find an overview over the available tutorials under Tutorials.","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Fluid","page":"Examples","title":"Fluid","text":"","category":"section"},{"location":"examples/#Accelerated-Tank-2D-(fluid/accelerated_tank_2d.jl)","page":"Examples","title":"Accelerated Tank 2D (fluid/accelerated_tank_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/4c4c537a-8585-4456-9a1b-8b5adbf68533\" width=\"60%\"/>","category":"page"},{"location":"examples/#Dam-Break-2D-(fluid/dam_break_2d.jl)","page":"Examples","title":"Dam Break 2D (fluid/dam_break_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/683e9363-5705-49cc-9a5c-3b47d73ea4b8\" width=\"60%\"/>","category":"page"},{"location":"examples/#Dam-Break-3D-(fluid/dam_break_3d.jl)","page":"Examples","title":"Dam Break 3D (fluid/dam_break_3d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/76a2b235-1b49-465f-a207-76859410b783\" width=\"60%\"/>","category":"page"},{"location":"examples/#Falling-Water-Column-(fluid/falling_water_column_2d.jl)","page":"Examples","title":"Falling Water Column (fluid/falling_water_column_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/06a522f0-424f-49d3-afd0-29593373aa29\" width=\"60%\"/>","category":"page"},{"location":"examples/#Hydrostatic-Water-Column-(fluid/hydrostatic_water_column_*.jl)","page":"Examples","title":"Hydrostatic Water Column (fluid/hydrostatic_water_column_*.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/fac6c41f-7af8-4936-9dd5-b6ff2b9f6ff4\" width=\"60%\"/>","category":"page"},{"location":"examples/#Moving-Wall-(fluid/moving_wall_2d.jl)","page":"Examples","title":"Moving Wall (fluid/moving_wall_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/c10faddf-0400-47c9-b225-f5d286a8ecb8\" width=\"60%\"/>","category":"page"},{"location":"examples/#Oscillating-Drop-(fluid/oscillating_drop_2d.jl)","page":"Examples","title":"Oscillating Drop (fluid/oscillating_drop_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/1dfa9dcf-7fc1-4221-ad83-a54c5d9ab9fb\" width=\"60%\"/>","category":"page"},{"location":"examples/#Periodic-Channel-(fluid/periodic_channel_2d.jl)","page":"Examples","title":"Periodic Channel (fluid/periodic_channel_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/f9a542bf-956b-4647-843b-94cbb085a4fa\" width=\"60%\"/>","category":"page"},{"location":"examples/#Fluid-Structure-Interaction","page":"Examples","title":"Fluid Structure Interaction","text":"","category":"section"},{"location":"examples/#Dam-Break-with-Elastic-Plate-(fsi/dam_break_plate_2d.jl)","page":"Examples","title":"Dam Break with Elastic Plate (fsi/dam_break_plate_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/ada0d554-e0ba-44ed-923d-2b77ef252258\" width=\"60%\"/>","category":"page"},{"location":"examples/#Falling-Sphere-2D-(fsi/falling_sphere_2d.jl)","page":"Examples","title":"Falling Sphere 2D (fsi/falling_sphere_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/217c80b5-3472-41c9-8003-7163641dd452\" width=\"60%\"/>","category":"page"},{"location":"examples/#Falling-Spheres-2D-(fsi/falling_spheres_2d.jl)","page":"Examples","title":"Falling Spheres 2D (fsi/falling_spheres_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/b3964f68-2782-43e6-b6ff-be96f9f224ae\" width=\"60%\"/>","category":"page"},{"location":"examples/#Structure-Mechanics","page":"Examples","title":"Structure Mechanics","text":"","category":"section"},{"location":"examples/#Oscillating-Beam-(solid/oscillating_beam_2d.jl)","page":"Examples","title":"Oscillating Beam (solid/oscillating_beam_2d.jl)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/e05ace63-e330-441a-a391-eda3d2764074\" width=\"60%\"/>","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The actual API reference is not listed on a single page, like in most Julia packages, but instead is split into multiple sections that follow a similar structure as the code files themselves. In these sections, API docs are combined with explanations of the theoretical background of these methods.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The following page gives a rough overview of important parts of the code.","category":"page"},{"location":"overview/#Program-flow","page":"Overview","title":"Program flow","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"To initiate a simulation, the goal is to solve an ordinary differential equation, for example, by employing the time integration schemes provided by OrdinaryDiffEq.jl. These schemes are then utilized to integrate mathrmdumathrmdt and mathrmdvmathrmdt, where u represents the particles' positions and v their properties such as velocity and density. During a single time step or an intermediate step of the time integration scheme, the functions drift! and kick! are invoked, followed by the functions depicted in this diagram (with key parts highlighted in orange/yellow).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: Main Program Flow)","category":"page"},{"location":"overview/#Structure","page":"Overview","title":"Structure","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"What we refer to as schemes are various models such as Weakly Compressible Smoothed Particle Hydrodynamics (WCSPH) or Total Lagrangian Smoothed Particle Hydrodynamics (TLSPH). These schemes are categorized based on the applicable physical regimes, namely fluid, solid, gas, and others. Each scheme comprises at least two files: a system.jl file and an rhs.jl file. The system.jl file provides the data structure holding the particles of this scheme and some routines, particularly those for allocation and the main update routines, excluding system interactions. The interactions between particles of this scheme (and with particles of other schemes) are handled in the rhs.jl file.","category":"page"},{"location":"callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/#TrixiParticles.DensityReinitializationCallback","page":"Callbacks","title":"TrixiParticles.DensityReinitializationCallback","text":"DensityReinitializationCallback(; interval::Integer=0, dt=0.0)\n\nCallback to reinitialize the density field when using ContinuityDensity [54].\n\nKeywords\n\ninterval=0:              Reinitialize the density every interval time steps.\ndt:                      Reinitialize the density in regular intervals of dt in terms                            of integration time.\nreinit_initial_solution: Reinitialize the initial solution (default=false)\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#TrixiParticles.InfoCallback-Tuple{}","page":"Callbacks","title":"TrixiParticles.InfoCallback","text":"InfoCallback()\n\nCreate and return a callback that prints a human-readable summary of the simulation setup at the beginning of a simulation and then resets the timer. When the returned callback is executed directly, the current timer values are shown.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.ParticleShiftingCallback-Tuple{}","page":"Callbacks","title":"TrixiParticles.ParticleShiftingCallback","text":"ParticleShiftingCallback()\n\nCallback to apply the Particle Shifting Technique by Sun et al. (2017). Following the original paper, the callback is applied in every time step and not in every stage of a multi-stage time integration method to reduce the computational cost and improve the stability of the scheme.\n\nSee Callbacks for more information on how to use this callback. See Particle Shifting Technique for more information on the method itself.\n\nwarning: Warning\nThe Particle Shifting Technique needs to be disabled close to the free surface and therefore requires a free surface detection method. This is not yet implemented. This callback cannot be used in a free surface simulation.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.PostprocessCallback","page":"Callbacks","title":"TrixiParticles.PostprocessCallback","text":"PostprocessCallback(; interval::Integer=0, dt=0.0, exclude_boundary=true, filename=\"values\",\n                    output_directory=\"out\", append_timestamp=false, write_csv=true,\n                    write_json=true, write_file_interval=1, funcs...)\n\nCreate a callback to post-process simulation data at regular intervals. This callback allows for the execution of a user-defined function func at specified intervals during the simulation. The function is applied to the current state of the simulation, and its results can be saved or used for further analysis. The provided function cannot be anonymous as the function name will be used as part of the name of the value.\n\nThe callback can be triggered either by a fixed number of time steps (interval) or by a fixed interval of simulation time (dt).\n\nKeywords\n\nfuncs...:   Functions to be executed at specified intervals during the simulation.               Each function must have the arguments (system, data, t),               which will be called for every system, where data is a named               tuple with fields depending on the system type, and t is the               current simulation time. Check the available data for each               system with available_data(system).               See Custom Quantities               for a list of pre-defined custom quantities that can be used here.\ninterval=0: Specifies the number of time steps between each invocation of the callback.               If set to 0, the callback will not be triggered based on time steps.               Either interval or dt must be set to something larger than 0.\ndt=0.0: Specifies the simulation time interval between each invocation of the callback.           If set to 0.0, the callback will not be triggered based on simulation time.           Either interval or dt must be set to something larger than 0.\nexclude_boundary=true: If set to true, boundary particles will be excluded from the post-processing.\nfilename=\"values\": The filename of the postprocessing files to be saved.\noutput_directory=\"out\": The path where the results of the post-processing will be saved.\nwrite_csv=true: If set to true, write a csv file.\nwrite_json=true: If set to true, write a json file.\nappend_timestep=false: If set to true, the current timestamp will be added to the filename.\nwrite_file_interval=1: Files will be written after every write_file_interval number of                          postprocessing execution steps. A value of 0 indicates that files                          are only written at the end of the simulation, eliminating I/O overhead.\n\nExamples\n\n# Create a callback that is triggered every 100 time steps\npostprocess_callback = PostprocessCallback(interval=100, example_quantity=kinetic_energy)\n\n# Create a callback that is triggered every 0.1 simulation time units\npostprocess_callback = PostprocessCallback(dt=0.1, example_quantity=kinetic_energy)\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#TrixiParticles.SolutionSavingCallback","page":"Callbacks","title":"TrixiParticles.SolutionSavingCallback","text":"SolutionSavingCallback(; interval::Integer=0, dt=0.0, save_times=Array{Float64, 1}([]),\n                       save_initial_solution=true, save_final_solution=true,\n                       output_directory=\"out\", append_timestamp=false, prefix=\"\",\n                       verbose=false, write_meta_data=true, max_coordinates=2^15,\n                       custom_quantities...)\n\nCallback to save the current numerical solution in VTK format in regular intervals. Either pass interval to save every interval time steps, or pass dt to save in intervals of dt in terms of integration time by adding additional tstops (note that this may change the solution).\n\nAdditional user-defined quantities can be saved by passing functions as keyword arguments, which map (v, u, t, system) to an Array where the columns represent the particles in the same order as in u. To ignore a custom quantity for a specific system, return nothing.\n\nKeywords\n\ninterval=0:                 Save the solution every interval time steps.\ndt:                         Save the solution in regular intervals of dt in terms                               of integration time by adding additional tstops                               (note that this may change the solution).\nsave_times=[]               List of times at which to save a solution.\nsave_initial_solution=true: Save the initial solution.\nsave_final_solution=true:   Save the final solution.\noutput_directory=\"out\":     Directory to save the VTK files.\nappend_timestamp=false:     Append current timestamp to the output directory.\n'prefix=\"\"':                  Prefix added to the filename.\ncustom_quantities...:       Additional user-defined quantities.\nwrite_meta_data=true:       Write meta data.\nverbose=false:              Print to standard IO when a file is written.\nmax_coordinates=2^15:       The coordinates of particles will be clipped if their                               absolute values exceed this threshold.\ncustom_quantities...:   Additional custom quantities to include in the VTK output.                           Each custom quantity must be a function of (system, data, t),                           which will be called for every system, where data is a named                           tuple with fields depending on the system type, and t is the                           current simulation time. Check the available data for each                           system with available_data(system).                           See Custom Quantities                           for a list of pre-defined custom quantities that can be used here.\n\nExamples\n\n# Save every 100 time steps\nsaving_callback = SolutionSavingCallback(interval=100)\n\n# Save in intervals of 0.1 in terms of simulation time\nsaving_callback = SolutionSavingCallback(dt=0.1)\n\n# Additionally store the kinetic energy of each system as \"my_custom_quantity\"\nsaving_callback = SolutionSavingCallback(dt=0.1, my_custom_quantity=kinetic_energy)\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#TrixiParticles.SteadyStateReachedCallback","page":"Callbacks","title":"TrixiParticles.SteadyStateReachedCallback","text":"SteadyStateReachedCallback(; interval::Integer=0, dt=0.0,\n                           interval_size::Integer=10, abstol=1.0e-8, reltol=1.0e-6)\n\nTerminates the integration when the change of kinetic energy between time steps falls below the threshold specified by abstol + reltol * ekin, where ekin is the total kinetic energy of the simulation.\n\nKeywords\n\ninterval=0:     Check steady state condition every interval time steps.\ndt=0.0:         Check steady state condition in regular intervals of dt in terms                   of integration time by adding additional tstops                   (note that this may change the solution).\ninterval_size:  The interval in which the change of the kinetic energy is considered.                   interval_size is a (integer) multiple of interval or dt.\nabstol:         Absolute tolerance.\nreltol:         Relative tolerance.\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#TrixiParticles.StepsizeCallback-Tuple{}","page":"Callbacks","title":"TrixiParticles.StepsizeCallback","text":"StepsizeCallback(; cfl::Real)\n\nSet the time step size according to a CFL condition if the time integration method isn't adaptive itself.\n\nThe current implementation is using the simplest form of CFL condition, which chooses a time step size that is constant during the simulation. The step size is therefore only applied once at the beginning of the simulation.\n\nThe step size Delta t is chosen as the minimum\n\n    Delta t = min(Delta t_eta Delta t_a Delta t_c)\n\nwhere\n\n    Delta t_eta = 0125  h^2  eta quad Delta t_a = 025 sqrth  lVert g rVert\n    quad Delta t_c = textCFL  h  c\n\nwith nu = alpha h c  (2n + 4), where alpha is the parameter of the viscosity and n is the number of dimensions.\n\nwarning: Experimental implementation\nThis is an experimental feature and may change in future releases.\n\nReferences\n\n[29], [15], [55], [56]\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.UpdateCallback-Tuple{}","page":"Callbacks","title":"TrixiParticles.UpdateCallback","text":"UpdateCallback(; interval::Integer, dt=0.0)\n\nCallback to update quantities either at the end of every interval time steps or in intervals of dt in terms of integration time by adding additional tstops (note that this may change the solution).\n\nKeywords\n\ninterval=1: Update quantities at the end of every interval time steps.\ndt: Update quantities in regular intervals of dt in terms of integration time       by adding additional tstops (note that this may change the solution).\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#custom_quantities","page":"Callbacks","title":"Custom Quantities","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks","title":"Callbacks","text":"The following pre-defined custom quantities can be used with the SolutionSavingCallback and PostprocessCallback.","category":"page"},{"location":"callbacks/#TrixiParticles.avg_density-Tuple{TrixiParticles.FluidSystem, Vararg{Any, 4}}","page":"Callbacks","title":"TrixiParticles.avg_density","text":"avg_density\n\nReturns the average_density over all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.avg_pressure-Tuple{TrixiParticles.FluidSystem, Vararg{Any, 4}}","page":"Callbacks","title":"TrixiParticles.avg_pressure","text":"avg_pressure\n\nReturns the average pressure over all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.kinetic_energy-NTuple{5, Any}","page":"Callbacks","title":"TrixiParticles.kinetic_energy","text":"kinetic_energy\n\nReturns the total kinetic energy of all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.max_density-Tuple{TrixiParticles.FluidSystem, Vararg{Any, 4}}","page":"Callbacks","title":"TrixiParticles.max_density","text":"max_density\n\nReturns the maximum density over all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.max_pressure-Tuple{TrixiParticles.FluidSystem, Vararg{Any, 4}}","page":"Callbacks","title":"TrixiParticles.max_pressure","text":"max_pressure\n\nReturns the maximum pressure over all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.min_density-Tuple{TrixiParticles.FluidSystem, Vararg{Any, 4}}","page":"Callbacks","title":"TrixiParticles.min_density","text":"min_density\n\nReturns the minimum density over all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.min_pressure-Tuple{TrixiParticles.FluidSystem, Vararg{Any, 4}}","page":"Callbacks","title":"TrixiParticles.min_pressure","text":"min_pressure\n\nReturns the minimum pressure over all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"callbacks/#TrixiParticles.total_mass-NTuple{5, Any}","page":"Callbacks","title":"TrixiParticles.total_mass","text":"total_mass\n\nReturns the total mass of all particles in a system.\n\n\n\n\n\n","category":"method"},{"location":"gpu/#gpu_support","page":"GPU Support","title":"GPU Support","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"GPU support is still an experimental feature that is actively being worked on. Currently, the WeaklyCompressibleSPHSystem, TotalLagrangianSPHSystem and BoundarySPHSystem support GPU execution. We have tested GPU support on Nvidia, AMD and Apple GPUs. Note that most Apple GPUs do not support Float64. See below on how to run single precision simulations.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"To run a simulation on a GPU, use the FullGridCellList as cell list for the GridNeighborhoodSearch. Unlike the default cell list, which assumes an unbounded domain, this cell list requires a bounding box for the domain. For simulations that are bounded by a closed tank, we can simply use the boundary of the tank to obtain the bounding box as follows.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"min_corner = minimum(tank.boundary.coordinates, dims=2)\nmax_corner = maximum(tank.boundary.coordinates, dims=2)\ncell_list = FullGridCellList(; min_corner, max_corner)","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"We then need to pass this cell list to the neighborhood search and the neighborhood search to the Semidiscretization.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"semi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=GridNeighborhoodSearch{2}(; cell_list))","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"At this point, we should run the simulation and make sure that it still works and that the bounding box is large enough. For some simulations where particles move outside the initial tank coordinates, for example when the tank is not closed or when the tank is moving, an appropriate bounding box has to be specified.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"Then, we only need to specify the parallelization backend that is used for the simulation. On an Nvidia GPU, we specify:","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"using CUDA\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=GridNeighborhoodSearch{2}(; cell_list),\n                          parallelization_backend=CUDABackend())","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"On an AMD GPU, we use:","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"using AMDGPU\nsemi = Semidiscretization(fluid_system, boundary_system,\n                          neighborhood_search=GridNeighborhoodSearch{2}(; cell_list),\n                          parallelization_backend=ROCBackend())","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"Now, we can run the simulation as usual. All data is transferred to the GPU during initialization and all loops over particles and their neighbors will be executed on the GPU as kernels generated by KernelAbstractions.jl. Data is only copied to the CPU for saving VTK files via the SolutionSavingCallback.","category":"page"},{"location":"gpu/#Run-an-existing-example-file-on-the-GPU","page":"GPU Support","title":"Run an existing example file on the GPU","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"The example file examples/fluid/dam_break_2d_gpu.jl demonstrates how to run an existing example file on a GPU. It first loads the variables from examples/fluid/dam_break_2d.jl without executing the simulation. This is achieved by overwriting the line that starts the simulation with trixi_include(..., sol=nothing). Next, a GPU-compatible neighborhood search is defined, and the original example file is included with the new neighborhood search. This requires the assignments neighborhood_search = ... and parallelization_backend = ... to be present in the original example file. Note that in examples/fluid/dam_break_2d.jl, we explicitly set parallelization_backend=PolyesterBackend(), even though this is the default value, so that we can use trixi_include to replace this value.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"To run this simulation on a GPU, simply update parallelization_backend to the backend of the installed GPU. We can run this simulation on an Nvidia GPU as follows.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"using CUDA\ntrixi_include(joinpath(examples_dir(), \"fluid\", \"dam_break_2d_gpu.jl\"), parallelization_backend=CUDABackend())","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"For AMD GPUs, use","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"using AMDGPU\ntrixi_include(joinpath(examples_dir(), \"fluid\", \"dam_break_2d_gpu.jl\"), parallelization_backend=ROCBackend())","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"For Apple GPUs (which don't support double precision, see below), use","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"using Metal\ntrixi_include_changeprecision(Float32,\n                              joinpath(examples_dir(), \"fluid\", \"dam_break_2d_gpu.jl\"),\n                              parallelization_backend=MetalBackend())","category":"page"},{"location":"gpu/#single_precision","page":"GPU Support","title":"Single precision simulations","text":"","category":"section"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"All GPU-supported features can also be used with single precision, which is significantly faster on most GPUs and required for many Apple GPUs.","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"To run a simulation with single precision, all Float64 literals in an example file must be converted to Float32 (e.g. 0.0 to 0.0f0). TrixiParticles provides a function to automate this conversion:","category":"page"},{"location":"gpu/#TrixiBase.trixi_include_changeprecision","page":"GPU Support","title":"TrixiBase.trixi_include_changeprecision","text":"trixi_include_changeprecision(T, [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the elixir elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments, similar to trixi_include.\n\nThe only difference to trixi_include is that the precision of floating-point numbers in the included elixir is changed to T. More precisely, the package ChangePrecision.jl is used to convert all Float64 literals, operations like / that produce Float64 results, and functions like ones that return Float64 arrays by default, to the desired type T. See the documentation of ChangePrecision.jl for more details.\n\nThe purpose of this function is to conveniently run a full simulation with Float32, which is orders of magnitude faster on most GPUs than Float64, by just including the elixir with trixi_include_changeprecision(Float32, elixir). Many constructors in the Trixi.jl framework are written in a way that changing all floating-point arguments to Float32 will change the element type to Float32 as well. In TrixiParticles.jl, including an elixir with this macro should be sufficient to run the full simulation with single precision.\n\n\n\n\n\n","category":"function"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"To run the previous example with single precision, use the following:","category":"page"},{"location":"gpu/","page":"GPU Support","title":"GPU Support","text":"using CUDA\ntrixi_include_changeprecision(Float32,\n                              joinpath(examples_dir(), \"fluid\", \"dam_break_2d_gpu.jl\"),\n                              parallelization_backend=CUDABackend())","category":"page"},{"location":"general/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"general/interpolation/#TrixiParticles.interpolate_line-Tuple{Any, Any, Any, Any, Any, ODESolution}","page":"Interpolation","title":"TrixiParticles.interpolate_line","text":"interpolate_line(start, end_, n_points, semi, ref_system, sol; endpoint=true,\n                 smoothing_length=initial_smoothing_length(ref_system), cut_off_bnd=true,\n                 clip_negative_pressure=false)\n\nInterpolates properties along a line in a TrixiParticles simulation. The line interpolation is accomplished by generating a series of evenly spaced points between start and end_. If endpoint is false, the line is interpolated between the start and end points, but does not include these points.\n\nSee also: interpolate_points, interpolate_plane_2d,           interpolate_plane_2d_vtk, interpolate_plane_3d.\n\nArguments\n\nstart:      The starting point of the line.\nend_:       The ending point of the line.\nn_points:   The number of points to interpolate along the line.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nendpoint=true: A boolean to include (true) or exclude (false) the end point in the interpolation.\nsmoothing_length=initial_smoothing_length(ref_system): The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\nclip_negative_pressure=false: One common approach in SPH models is to clip negative pressure                                 values, but this is unphysical. Instead we clip here during                                 interpolation thus only impacting the local interpolated value.\n\nReturns\n\nA NamedTuple of arrays containing interpolated properties at each point along the line.\n\nnote: Note\nThis function is particularly useful for analyzing gradients or creating visualizations along a specified line in the SPH simulation domain.\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating along a line from [1.0, 0.0] to [1.0, 1.0] with 5 points\nresults = interpolate_line([1.0, 0.0], [1.0, 1.0], 5, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_plane_2d-Tuple{Any, Any, Any, Any, Any, ODESolution}","page":"Interpolation","title":"TrixiParticles.interpolate_plane_2d","text":"interpolate_plane_2d(min_corner, max_corner, resolution, semi, ref_system, sol;\n                     smoothing_length=initial_smoothing_length(ref_system), cut_off_bnd=true,\n                     clip_negative_pressure=false)\n\nInterpolates properties along a plane in a TrixiParticles simulation. The region for interpolation is defined by its lower left and top right corners, with a specified resolution determining the density of the interpolation points.\n\nThe function generates a grid of points within the defined region, spaced uniformly according to the given resolution.\n\nSee also: interpolate_plane_2d_vtk, interpolate_plane_3d,           interpolate_line, interpolate_points.\n\nArguments\n\nmin_corner: The lower left corner of the interpolation region.\nmax_corner: The top right corner of the interpolation region.\nresolution: The distance between adjacent interpolation points in the grid.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nsmoothing_length=initial_smoothing_length(ref_system): The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\nclip_negative_pressure=false: One common approach in SPH models is to clip negative pressure                                 values, but this is unphysical. Instead we clip here during                                 interpolation thus only impacting the local interpolated value.\n\nReturns\n\nA NamedTuple of arrays containing interpolated properties at each point within the plane.\n\nnote: Note\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used, which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating across a plane from [0.0, 0.0] to [1.0, 1.0] with a resolution of 0.2\nresults = interpolate_plane_2d([0.0, 0.0], [1.0, 1.0], 0.2, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_plane_2d_vtk-Tuple{Any, Any, Any, Any, Any, ODESolution}","page":"Interpolation","title":"TrixiParticles.interpolate_plane_2d_vtk","text":"interpolate_plane_2d_vtk(min_corner, max_corner, resolution, semi, ref_system, sol;\n                         smoothing_length=initial_smoothing_length(ref_system), cut_off_bnd=true,\n                         clip_negative_pressure=false, output_directory=\"out\", filename=\"plane\")\n\nInterpolates properties along a plane in a TrixiParticles simulation and exports the result as a VTI file. The region for interpolation is defined by its lower left and top right corners, with a specified resolution determining the density of the interpolation points.\n\nThe function generates a grid of points within the defined region, spaced uniformly according to the given resolution.\n\nSee also: interpolate_plane_2d, interpolate_plane_3d,           interpolate_line, interpolate_points.\n\nArguments\n\nmin_corner: The lower left corner of the interpolation region.\nmax_corner: The top right corner of the interpolation region.\nresolution: The distance between adjacent interpolation points in the grid.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nsmoothing_length=initial_smoothing_length(ref_system): The smoothing length used in the interpolation.\noutput_directory=\"out\": Directory to save the VTI file.\nfilename=\"plane\":       Name of the VTI file.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\nclip_negative_pressure=false: One common approach in SPH models is to clip negative pressure                                 values, but this is unphysical. Instead we clip here during                                 interpolation thus only impacting the local interpolated value.\n\nnote: Note\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used, which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating across a plane from [0.0, 0.0] to [1.0, 1.0] with a resolution of 0.2\nresults = interpolate_plane_2d([0.0, 0.0], [1.0, 1.0], 0.2, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_plane_3d-Tuple{Any, Any, Any, Any, Any, Any, ODESolution}","page":"Interpolation","title":"TrixiParticles.interpolate_plane_3d","text":"interpolate_plane_3d(point1, point2, point3, resolution, semi, ref_system, sol;\n                     smoothing_length=initial_smoothing_length(ref_system), cut_off_bnd=true,\n                     clip_negative_pressure=false)\n\nInterpolates properties along a plane in a 3D space in a TrixiParticles simulation. The plane for interpolation is defined by three points in 3D space, with a specified resolution determining the density of the interpolation points.\n\nThe function generates a grid of points on a parallelogram within the plane defined by the three points, spaced uniformly according to the given resolution.\n\nSee also: interpolate_plane_2d, interpolate_plane_2d_vtk,           interpolate_line, interpolate_points.\n\nArguments\n\npoint1:     The first point defining the plane.\npoint2:     The second point defining the plane.\npoint3:     The third point defining the plane. The points must not be collinear.\nresolution: The distance between adjacent interpolation points in the grid.\nsemi:       The semidiscretization used for the simulation.\nref_system: The reference system for the interpolation.\nsol:        The solution state from which the properties are interpolated.\n\nKeywords\n\nsmoothing_length=initial_smoothing_length(ref_system): The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\nclip_negative_pressure=false: One common approach in SPH models is to clip negative pressure                                 values, but this is unphysical. Instead we clip here during                                 interpolation thus only impacting the local interpolated value.\n\nReturns\n\nA NamedTuple of arrays containing interpolated properties at each point within the plane.\n\nnote: Note\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used which is not as accurate as a real surface reconstruction.\n\nExamples\n\n# Interpolating across a plane defined by points [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], and [0.0, 1.0, 0.0]\n# with a resolution of 0.1\nresults = interpolate_plane_3d([0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], 0.1, semi, ref_system, sol)\n\n\n\n\n\n","category":"method"},{"location":"general/interpolation/#TrixiParticles.interpolate_points-Tuple{Any, Any, Any, ODESolution}","page":"Interpolation","title":"TrixiParticles.interpolate_points","text":"interpolate_points(point_coords::AbstractMatrix, semi, ref_system, sol;\n                   smoothing_length=initial_smoothing_length(ref_system),\n                   cut_off_bnd=true, clip_negative_pressure=false)\n\nPerforms interpolation of properties at specified points in a TrixiParticles simulation. The interpolation utilizes the same kernel function of the SPH simulation to weigh contributions from nearby particles.\n\nSee also: interpolate_line, interpolate_plane_2d,           interpolate_plane_2d_vtk, interpolate_plane_3d, .\n\nArguments\n\npoint_coords:   A matrix of point coordinates, where the i-th column holds the                   coordinates of particle i.\nsemi:           The semidiscretization used in the SPH simulation.\nref_system:     The reference system defining the properties of the SPH particles.\nsol:            The current solution state from which properties are interpolated.\n\nKeywords\n\nsmoothing_length=initial_smoothing_length(ref_system): The smoothing length used in the interpolation.\ncut_off_bnd=true: Boolean to indicate if quantities should be set to NaN when the point                     is \"closer\" to the boundary than to the fluid in a kernel-weighted sense.                     Or, in more detail, when the boundary has more influence than the fluid                     on the density summation in this point, i.e., when the boundary particles                     add more kernel-weighted mass than the fluid particles.\nclip_negative_pressure=false: One common approach in SPH models is to clip negative pressure                                 values, but this is unphysical. Instead we clip here during                                 interpolation thus only impacting the local interpolated value.\n\nReturns\n\nA NamedTuple of arrays containing interpolated properties at each point.\n\nExamples\n\n# For a single point create a 2x1 matrix\nresult = interpolate_points([1.0; 0.5;;], semi, ref_system, sol)\n\n# For multiple points\npoints = [1.0 1.0 1.0; 0.5 0.6 0.7]\nresults = interpolate_points(points, semi, ref_system, sol)\n\nnote: Note\nThis function is particularly useful for analyzing gradients or creating visualizations along a specified line in the SPH simulation domain.\nThe interpolation accuracy is subject to the density of particles and the chosen smoothing length.\nWith cut_off_bnd, a density-based estimation of the surface is used which is not asaccurate as a real surface reconstruction.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiParticles.jl","page":"Home","title":"TrixiParticles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TrixiParticles.jl is a high-performance particle simulation framework designed to overcome challenges of particle-based numerical methods in multiphysics applications. Existing frameworks often lack user-friendliness, involve complex configuration, and are not easily extensible for development of new methods. In the future we also want to provide seamless scalability from CPU to Exascale-level computing with GPU support. TrixiParticles.jl addresses these limitations with an intuitive interface, straightforward configuration, and an extensible design, facilitating efficient simulation setup and execution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"TrixiParticles.jl focuses on the following use cases:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Development of new particle-based methods and models. By providing an extensible architecture to incorporate additional particle methods easily and not focusing on a single model or numerical method.\nAccurate, reliable and efficient physics-based modelling of complex multiphysics problems by providing a flexible configuration system, tools, high performance and a wide range of validation and test cases.\nEasy setup of accessible simulations for educational purposes, including student projects, coursework, and thesis work through extensive documentation, community engagement and readable configuration files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Its features include:","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Incompressible Navier-Stokes\nMethods: Weakly Compressible Smoothed Particle Hydrodynamics (WCSPH), Entropically Damped Artificial Compressibility (EDAC)\nModels: Surface Tension\nSolid-body mechanics\nMethods: Total Lagrangian SPH (TLSPH)\nFluid-Structure Interaction\nOutput formats:\nVTK","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<table align=\"center\" border=\"0\">\n  <tr>\n    <td align=\"center\">\n      <img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/683e9363-5705-49cc-9a5c-3b47d73ea4b8\" style=\"width: 80% !important;\"/><br><figcaption>2D Dam Break</figcaption>\n    </td>\n    <td align=\"center\">\n      <img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/c10faddf-0400-47c9-b225-f5d286a8ecb8\" style=\"width: 80% !important;\"/><br><figcaption>Moving Wall</figcaption>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/e05ace63-e330-441a-a391-eda3d2764074\" style=\"width: 80% !important;\"/><br><figcaption>Oscillating Beam</figcaption>\n    </td>\n    <td align=\"center\">\n      <img src=\"https://github.com/trixi-framework/TrixiParticles.jl/assets/10238714/ada0d554-e0ba-44ed-923d-2b77ef252258\" style=\"width: 80% !important;\"/><br><figcaption>Dam Break with Elastic Plate</figcaption>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation\nGetting started","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have any questions concerning TrixiParticles.jl you can join our community on Slack or open an issue with your question.","category":"page"},{"location":"#Start-with-development","page":"Home","title":"Start with development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get started with development have a look at these pages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation\nDevelopment\nContributing","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Fluid","page":"Tutorial","title":"Fluid","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Setting up your simulation from scratch\nSetting up a dam break simulation","category":"page"},{"location":"tutorial/#Mechanics","page":"Tutorial","title":"Mechanics","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Deforming a beam","category":"page"},{"location":"tutorial/#Fluid-Structure-Interaction","page":"Tutorial","title":"Fluid-Structure Interaction","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Setting up a falling structure","category":"page"},{"location":"reference-pointneighbors/#pointneighbors","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.jl API","text":"","category":"section"},{"location":"reference-pointneighbors/#PointNeighbors.DictionaryCellList","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.DictionaryCellList","text":"DictionaryCellList{NDIMS}()\n\nA simple cell list implementation where a cell index (i, j) or (i, j, k) is mapped to a Vector{Int} by a Dict. By using a dictionary, which only stores non-empty cells, the domain is potentially infinite.\n\nThis implementation is very simple, but it neither uses an optimized hash function for integer tuples, nor does it use a contiguous memory layout. Consequently, this cell list is not GPU-compatible.\n\nArguments\n\nNDIMS: Number of dimensions.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.FullGridCellList","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.FullGridCellList","text":"FullGridCellList(; min_corner, max_corner, search_radius = 0.0,\n                 periodicity = false, backend = DynamicVectorOfVectors{Int32},\n                 max_points_per_cell = 100)\n\nA simple cell list implementation where each (empty or non-empty) cell of a rectangular (axis-aligned) domain is assigned a list of points. This cell list only works when all points are inside the specified domain at all times.\n\nOnly set min_corner and max_corner and use the default values for the other arguments to create an empty \"template\" cell list that can be used to create an empty \"template\" neighborhood search. See copy_neighborhood_search for more details.\n\nKeywords\n\nmin_corner: Coordinates of the domain corner in negative coordinate directions.\nmax_corner: Coordinates of the domain corner in positive coordinate directions.\nsearch_radius = 0.0: Search radius of the neighborhood search, which will determine the                        cell size. Use the default of 0.0 to create a template (see above).\nperiodicity = false: Set to true when using a PeriodicBox with the                        neighborhood search. When using copy_neighborhood_search,                        this option can be ignored an will be set automatically depending                        on the periodicity of the neighborhood search.\nbackend = DynamicVectorOfVectors{Int32}: Type of the data structure to store the actual   cell lists. Can be\nVector{Vector{Int32}}: Scattered memory, but very memory-efficient.\nDynamicVectorOfVectors{Int32}: Contiguous memory, optimizing cache-hits.\nmax_points_per_cell = 100: Maximum number of points per cell. This will be used to                              allocate the DynamicVectorOfVectors. It is not used with                              the Vector{Vector{Int32}} backend.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.GridNeighborhoodSearch","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.GridNeighborhoodSearch","text":"GridNeighborhoodSearch{NDIMS}(; search_radius = 0.0, n_points = 0,\n                              periodic_box = nothing,\n                              cell_list = DictionaryCellList{NDIMS}(),\n                              update_strategy = nothing)\n\nSimple grid-based neighborhood search with uniform search radius. The domain is divided into a regular grid. For each (non-empty) grid cell, a list of points in this cell is stored. Instead of representing a finite domain by an array of cells, a potentially infinite domain is represented by storing cell lists in a hash table (using Julia's Dict data structure), indexed by the cell index tuple\n\nleft( leftlfloor fracxd rightrfloor leftlfloor fracyd rightrfloor right) quad textor quad\nleft( leftlfloor fracxd rightrfloor leftlfloor fracyd rightrfloor leftlfloor fraczd rightrfloor right)\n\nwhere x y z are the space coordinates and d is the search radius.\n\nTo find points within the search radius around a position, only points in the neighboring cells are considered.\n\nSee also (Chalela et al., 2021), (Ihmsen et al. 2011, Section 4.4).\n\nAs opposed to (Ihmsen et al. 2011), we do not sort the points in any way, since not sorting makes our implementation a lot faster (although less parallelizable).\n\nArguments\n\nNDIMS: Number of dimensions.\n\nKeywords\n\nsearch_radius = 0.0:    The fixed search radius. The default of 0.0 is useful together                           with copy_neighborhood_search.\nn_points = 0:           Total number of points. The default of 0 is useful together                           with copy_neighborhood_search.\nperiodic_box = nothing: In order to use a (rectangular) periodic domain, pass a                           PeriodicBox.\ncell_list:              The cell list that maps a cell index to a list of points inside                           the cell. By default, a DictionaryCellList is used.\nupdate_strategy = nothing: Strategy to parallelize update!. Available options are:\nnothing: Automatically choose the best available option.\nParallelUpdate(): This is not available for all cell list implementations.\nSemiParallelUpdate(): This is available for all cell list implementations   and is the default when available.\nSerialIncrementalUpdate()\nSerialUpdate()\n\nReferences\n\nM. Chalela, E. Sillero, L. Pereyra, M.A. Garcia, J.B. Cabral, M. Lares, M. Merchán. \"GriSPy: A Python package for fixed-radius nearest neighbors search\". In: Astronomy and Computing 34 (2021). doi: 10.1016/j.ascom.2020.100443\nMarkus Ihmsen, Nadir Akinci, Markus Becker, Matthias Teschner. \"A Parallel SPH Implementation on Multi-Core CPUs\". In: Computer Graphics Forum 30.1 (2011), pages 99–112. doi: 10.1111/J.1467-8659.2010.01832.X\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.ParallelIncrementalUpdate","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.ParallelIncrementalUpdate","text":"ParallelIncrementalUpdate()\n\nLike ParallelUpdate, but only updates the cells that have changed. This is generally slower than a full reinitialization with ParallelUpdate, but is included for benchmarking purposes. This is not available for all cell list implementations, but is the default when available.\n\nSee GridNeighborhoodSearch for usage information.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.ParallelUpdate","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.ParallelUpdate","text":"ParallelUpdate()\n\nFully parallel initialization and update by using atomic operations to avoid race conditions when adding points into the same cell. This is not available for all cell list implementations.\n\nSee GridNeighborhoodSearch for usage information.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.PeriodicBox","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.PeriodicBox","text":"PeriodicBox(; min_corner, max_corner)\n\nDefine a rectangular (axis-aligned) periodic domain.\n\nKeywords\n\nmin_corner: Coordinates of the domain corner in negative coordinate directions.\nmax_corner: Coordinates of the domain corner in positive coordinate directions.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.PolyesterBackend","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.PolyesterBackend","text":"PolyesterBackend()\n\nPass as first argument to the @threaded macro to make the loop multithreaded with Polyester.@batch.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.PrecomputedNeighborhoodSearch","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.PrecomputedNeighborhoodSearch","text":"PrecomputedNeighborhoodSearch{NDIMS}(; search_radius = 0.0, n_points = 0,\n                                     periodic_box = nothing, update_strategy = nothing)\n\nNeighborhood search with precomputed neighbor lists. A list of all neighbors is computed for each point during initialization and update. This neighborhood search maximizes the performance of neighbor loops at the cost of a much slower update!.\n\nA GridNeighborhoodSearch is used internally to compute the neighbor lists during initialization and update.\n\nArguments\n\nNDIMS: Number of dimensions.\n\nKeywords\n\nsearch_radius = 0.0:    The fixed search radius. The default of 0.0 is useful together                           with copy_neighborhood_search.\nn_points = 0:           Total number of points. The default of 0 is useful together                           with copy_neighborhood_search.\nperiodic_box = nothing: In order to use a (rectangular) periodic domain, pass a                           PeriodicBox.\nupdate_strategy:        Strategy to parallelize update! of the internally used                           GridNeighborhoodSearch. See GridNeighborhoodSearch                           for available options.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.SemiParallelUpdate","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.SemiParallelUpdate","text":"SemiParallelUpdate()\n\nLoop over all cells in parallel to mark cells with points that now belong to a different cell. Then, move points of affected cells serially to avoid race conditions. This is available for all cell list implementations and is the default when ParallelUpdate is not available.\n\nSee GridNeighborhoodSearch for usage information.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.SerialBackend","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.SerialBackend","text":"SerialBackend()\n\nPass as first argument to the @threaded macro to run the loop serially.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.SerialIncrementalUpdate","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.SerialIncrementalUpdate","text":"SerialIncrementalUpdate()\n\nDeactivate parallelization in the neighborhood search update. Parallel neighborhood search update can be one of the largest sources of error variations between simulations with different thread numbers due to neighbor ordering changes. This strategy incrementally updates the cell lists in every update.\n\nSee GridNeighborhoodSearch for usage information.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.SerialUpdate","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.SerialUpdate","text":"SerialUpdate()\n\nDeactivate parallelization in the neighborhood search update. Parallel neighborhood search update can be one of the largest sources of error variations between simulations with different thread numbers due to neighbor ordering changes. This strategy reinitializes the cell lists in every update.\n\nSee GridNeighborhoodSearch for usage information.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.ThreadsDynamicBackend","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.ThreadsDynamicBackend","text":"ThreadsDynamicBackend()\n\nPass as first argument to the @threaded macro to make the loop multithreaded with Threads.@threads :dynamic.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.ThreadsStaticBackend","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.ThreadsStaticBackend","text":"ThreadsStaticBackend()\n\nPass as first argument to the @threaded macro to make the loop multithreaded with Threads.@threads :static.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.TrivialNeighborhoodSearch","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.TrivialNeighborhoodSearch","text":"TrivialNeighborhoodSearch{NDIMS}(; search_radius = 0.0, eachpoint = 1:0,\n                                 periodic_box = nothing)\n\nTrivial neighborhood search that simply loops over all points.\n\nArguments\n\nNDIMS: Number of dimensions.\n\nKeywords\n\nsearch_radius = 0.0:    The fixed search radius. The default of 0.0 is useful together                           with copy_neighborhood_search.\neachpoint = 1:0:        Iterator for all point indices. Usually just 1:n_points.                           The default of 1:0 is useful together with                           copy_neighborhood_search.\nperiodic_box = nothing: In order to use a (rectangular) periodic domain, pass a                           PeriodicBox.\n\n\n\n\n\n","category":"type"},{"location":"reference-pointneighbors/#PointNeighbors.copy_neighborhood_search-Tuple{PointNeighbors.AbstractNeighborhoodSearch, Any, Any}","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.copy_neighborhood_search","text":"copy_neighborhood_search(search::AbstractNeighborhoodSearch, search_radius, n_points;\n                         eachpoint = 1:n_points)\n\nCreate a new uninitialized neighborhood search of the same type and with the same configuration options as search, but with a different search radius and number of points.\n\nThe TrivialNeighborhoodSearch also requires an iterator eachpoint, which most of the time will be 1:n_points. If the TrivialNeighborhoodSearch is never going to be used, the keyword argument eachpoint can be ignored.\n\nThis is useful when a simulation code requires multiple neighborhood searches of the same kind. One can then just pass an empty neighborhood search as a template and use this function inside the simulation code to generate similar neighborhood searches with different search radii and different numbers of points.\n\n# Template\nnhs = GridNeighborhoodSearch{2}()\n\n# Inside the simulation code, generate similar neighborhood searches\nnhs1 = copy_neighborhood_search(nhs, 1.0, 100)\n\n# output\nGridNeighborhoodSearch{2, Float64, ...}(...)\n\n\n\n\n\n","category":"method"},{"location":"reference-pointneighbors/#PointNeighbors.default_backend-Tuple{AbstractArray}","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.default_backend","text":"default_backend(x)\n\nSelect the recommended backend for an array x. This allows to write generic code that works for both CPU and GPU arrays.\n\nThe default backend for CPU arrays is currently PolyesterBackend(). For GPU arrays, the respective KernelAbstractions.Backend is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference-pointneighbors/#PointNeighbors.foreach_point_neighbor-Union{Tuple{T}, Tuple{T, Any, Any, Any}} where T","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.foreach_point_neighbor","text":"foreach_point_neighbor(f, system_coords, neighbor_coords, neighborhood_search;\n                       parallelization_backend = default_backend(system_coords),\n                       points = axes(system_coords, 2))\n\nLoop for each point in system_coords over all points in neighbor_coords whose distances to that point are smaller than the search radius and execute the function f(i, j, pos_diff, d), where\n\ni is the column index of the point in system_coords,\nj the column index of the neighbor in neighbor_coords,\npos_diff the vector x - y where x denotes the coordinates of the point (system_coords[:, i]) and y the coordinates of the neighbor (neighbor_coords[:, j]),\nd the distance between x and y.\n\nNote that system_coords and neighbor_coords can be identical.\n\nwarning: Warning\nThe neighborhood_search must have been initialized or updated with system_coords as first coordinate array and neighbor_coords as second coordinate array. This can be skipped for certain implementations. See requires_update.\n\nArguments\n\nf: The function explained above.\nsystem_coords: A matrix where the i-th column contains the coordinates of point i.\nneighbor_coords: A matrix where the j-th column contains the coordinates of point j.\nneighborhood_search: A neighborhood search initialized or updated with system_coords                        as first coordinate array and neighbor_coords as second                        coordinate array.\n\nKeywords\n\npoints: Loop over these point indices. By default all columns of system_coords.\nparallelization_backend: Run the outer loop over points in parallel with the                            specified backend. By default, the backend is selected                            automatically based on the type of system_coords.                            See @threaded for a list of available backends.\n\nSee also initialize!, update!.\n\n\n\n\n\n","category":"method"},{"location":"reference-pointneighbors/#PointNeighbors.initialize!-Tuple{PointNeighbors.AbstractNeighborhoodSearch, Any, Any}","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.initialize!","text":"initialize!(search::AbstractNeighborhoodSearch, x, y;\n            parallelization_backend = default_backend(x),\n            eachindex_y = axes(y, 2))\n\nInitialize a neighborhood search with the two coordinate arrays x and y.\n\nIn general, the purpose of a neighborhood search is to find for one point in x all points in y whose distances to that point are smaller than the search radius. x and y are expected to be matrices, where the i-th column contains the coordinates of point i. Note that x and y can be identical.\n\nIf the neighborhood search type supports parallelization, the keyword argument parallelization_backend can be used to specify a parallelization backend. See @threaded for a list of available backends.\n\nOptionally, when points in y are to be ignored, the keyword argument eachindex_y can be passed to specify the indices of the points in y that are to be used.\n\nSee also update!.\n\n\n\n\n\n","category":"method"},{"location":"reference-pointneighbors/#PointNeighbors.requires_update-Tuple{PointNeighbors.AbstractNeighborhoodSearch}","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.requires_update","text":"requires_update(search::AbstractNeighborhoodSearch)\n\nReturns a tuple (x_changed, y_changed) indicating if this type of neighborhood search requires an update when the coordinates of the points in x or y change.\n\n\n\n\n\n","category":"method"},{"location":"reference-pointneighbors/#PointNeighbors.update!-Tuple{PointNeighbors.AbstractNeighborhoodSearch, Any, Any}","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.update!","text":"update!(search::AbstractNeighborhoodSearch, x, y; points_moving = (true, true),\n        parallelization_backend = default_backend(x),\n        eachindex_y = axes(y, 2))\n\nUpdate an already initialized neighborhood search with the two coordinate arrays x and y.\n\nLike initialize!, but potentially reusing the existing data structures of the already initialized neighborhood search. When the points only moved a small distance since the last update! or initialize!, this can be significantly faster than initialize!.\n\nNot all implementations support incremental updates. If incremental updates are not possible for an implementation, update! will fall back to a regular initialize!.\n\nSome neighborhood searches might not need to update when only x changed since the last update! or initialize! and y did not change. Pass points_moving = (true, false) in this case to avoid unnecessary updates. The first flag in points_moving indicates if points in x are moving. The second flag indicates if points in y are moving.\n\nIf the neighborhood search type supports parallelization, the keyword argument parallelization_backend can be used to specify a parallelization backend. See @threaded for a list of available backends.\n\nOptionally, when points in y are to be ignored, the keyword argument eachindex_y can be passed to specify the indices of the points in y that are to be used.\n\nSee also initialize!.\n\n\n\n\n\n","category":"method"},{"location":"reference-pointneighbors/#PointNeighbors.@threaded-Tuple{Any, Any}","page":"PointNeighbors.jl API Reference","title":"PointNeighbors.@threaded","text":"@threaded backend for ... end\n\nRun either a threaded CPU loop or launch a kernel on the GPU, depending on the backend. Semantically the same as Threads.@threads when iterating over a AbstractUnitRange but without guarantee that the underlying implementation uses Threads.@threads or works for more general for loops.\n\nPossible parallelization backends are:\n\nSerialBackend to disable multithreading\nPolyesterBackend to use Polyester.@batch\nThreadsDynamicBackend to use Threads.@threads :dynamic\nThreadsStaticBackend to use Threads.@threads :static\nAny KernelAbstractions.Backend to execute the loop as a GPU kernel\n\nUse default_backend(x) to select the recommended backend for an array x. This allows to write generic code that works for both CPU and GPU arrays.\n\nwarning: Warning\nThis macro does not necessarily work for general for loops. For example, it does not necessarily support general iterables such as eachline(filename).\n\n\n\n\n\n","category":"macro"}]
}
