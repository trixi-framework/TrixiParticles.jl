<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Particle Packing Tutorial · TrixiParticles.jl</title><meta name="title" content="Particle Packing Tutorial · TrixiParticles.jl"/><meta property="og:title" content="Particle Packing Tutorial · TrixiParticles.jl"/><meta property="twitter:title" content="Particle Packing Tutorial · TrixiParticles.jl"/><meta name="description" content="Documentation for TrixiParticles.jl."/><meta property="og:description" content="Documentation for TrixiParticles.jl."/><meta property="twitter:description" content="Documentation for TrixiParticles.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="https://cdn.jsdelivr.net/npm/asciinema-player@3.6.3/dist/bundle/asciinema-player.min.js"></script><link href="https://cdn.jsdelivr.net/npm/asciinema-player@3.6.3/dist/bundle/asciinema-player.min.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TrixiParticles.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../news/">News</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../development/">Development</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><span class="tocitem">Preprocessing</span><ul><li><a class="tocitem" href="../../preprocessing/preprocessing/">Sampling of Geometries</a></li></ul></li><li><a class="tocitem" href="../../gpu/">GPU Support</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../general/semidiscretization/">Semidiscretization</a></li><li><a class="tocitem" href="../../general/initial_condition/">Initial Condition and Setups</a></li><li><a class="tocitem" href="../../general/interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../general/density_calculators/">Density Calculators</a></li><li><a class="tocitem" href="../../general/smoothing_kernels/">Smoothing Kernels</a></li><li><a class="tocitem" href="../../general/neighborhood_search/">Neighborhood Search</a></li><li><a class="tocitem" href="../../general/util/">Util</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-11-3-1" type="checkbox"/><label class="tocitem" for="menuitem-11-3-1"><span class="docs-label">Fluid Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../systems/fluid/">Overview</a></li><li><a class="tocitem" href="../../systems/weakly_compressible_sph/">Weakly Compressible SPH (Fluid)</a></li><li><a class="tocitem" href="../../systems/entropically_damped_sph/">Entropically Damped Artificial Compressibility for SPH (Fluid)</a></li></ul></li><li><a class="tocitem" href="../../systems/dem/">Discrete Element Method (Solid)</a></li><li><a class="tocitem" href="../../systems/total_lagrangian_sph/">Total Lagrangian SPH (Elastic Structure)</a></li><li><a class="tocitem" href="../../systems/boundary/">Boundary</a></li></ul></li><li><a class="tocitem" href="../../time_integration/">Time Integration</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../reference-trixibase/">TrixiBase.jl API Reference</a></li><li><a class="tocitem" href="../../reference-pointneighbors/">PointNeighbors.jl API Reference</a></li></ul></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Particle Packing Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Particle Packing Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/TrixiParticles.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/TrixiParticles.jl/blob/main/docs/literate/src/tut_packing.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Particle-Packing-Tutorial"><a class="docs-heading-anchor" href="#Particle-Packing-Tutorial">Particle Packing Tutorial</a><a id="Particle-Packing-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-Packing-Tutorial" title="Permalink"></a></h1><p>In this tutorial, we will guide you through the complete particle packing pipeline. The algorithmic background is explained in <a href="../../preprocessing/preprocessing/#particle_packing">Particle Packing</a>. Throughout this tutorial, we will refer to the initially sampled particles as the &quot;initial configuration&quot;, and the configuration after packing as the &quot;packed configuration&quot;. The particles, created by an inside–outside segmentation of the geometry, are referred to as &quot;interior particles&quot;, whereas the particles on the surface of the geometry are called &quot;boundary particles&quot;.</p><h2 id="Loading-the-geometry"><a class="docs-heading-anchor" href="#Loading-the-geometry">Loading the geometry</a><a id="Loading-the-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-the-geometry" title="Permalink"></a></h2><p>As a first step, we will load a geometry. Supported file formats are described <a href="../../preprocessing/preprocessing/#read_geometries_from_file">in the documentation</a>.</p><pre><code class="language-julia hljs">using TrixiParticles
using Plots

file = pkgdir(TrixiParticles, &quot;examples&quot;, &quot;preprocessing&quot;, &quot;data&quot;, &quot;potato.asc&quot;)
geometry = load_geometry(file)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Polygon{2, Float64}                                                                              │
│ ═══════════════════                                                                              │
│ #edges: …………………………………………………………… 13                                                               │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>To get an overview, we can visualize this geometry.</p><pre><code class="language-julia hljs">plot(geometry, showaxis=false, label=nothing, color=:black)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="600" height="400" viewBox="0 0 2400 1600">
<defs>
  <clipPath id="clip490">
    <rect x="0" y="0" width="2400" height="1600"/>
  </clipPath>
</defs>
<path clip-path="url(%23clip490)" d="M0 1600 L2400 1600 L2400 0 L0 0  Z" fill="%23ffffff" fill-rule="evenodd" fill-opacity="1"/>
<defs>
  <clipPath id="clip491">
    <rect x="480" y="0" width="1681" height="1600"/>
  </clipPath>
</defs>
<path clip-path="url(%23clip490)" d="M224.098 1486.45 L2352.76 1486.45 L2352.76 47.2441 L224.098 47.2441  Z" fill="%23ffffff" fill-rule="evenodd" fill-opacity="1"/>
<defs>
  <clipPath id="clip492">
    <rect x="224" y="47" width="2130" height="1440"/>
  </clipPath>
</defs>
<circle clip-path="url(%23clip492)" cx="1439.33" cy="294.305" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="1860.18" cy="421.708" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="2099.32" cy="563.209" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="2292.51" cy="826.37" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="2245.52" cy="1106.76" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="1899.34" cy="1239.39" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="1553.68" cy="1233.12" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="1091.58" cy="995.546" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="686.395" cy="983.013" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="404.959" cy="844.123" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="284.343" cy="649.363" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="464.483" cy="424.841" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="795.523" cy="315.19" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<circle clip-path="url(%23clip492)" cx="1439.33" cy="294.305" r="14.4" fill="%23000000" fill-rule="evenodd" fill-opacity="1" stroke="none"/>
<polyline clip-path="url(%23clip492)" style="stroke:%23000000; stroke-linecap:round; stroke-linejoin:round; stroke-width:4; stroke-opacity:1; fill:none" points="1439.33,294.305 1860.18,421.708 2099.32,563.209 2292.51,826.37 2245.52,1106.76 1899.34,1239.39 1553.68,1233.12 1091.58,995.546 686.395,983.013 404.959,844.123 284.343,649.363 464.483,424.841 795.523,315.19 1439.33,294.305 "/>
</svg>
'/><p>As shown in the plot, the 2D geometry (<code>TrixiParticles.Polygon</code>) is represented by its edges. Similarly, 3D geometries (<code>TrixiParticles.TriangleMesh</code>), are represented by triangles. In this tutorial, we will stay with a 2D geometry, but the steps are identical for 3D geometries.</p><h2 id="Creating-a-signed-distance-field"><a class="docs-heading-anchor" href="#Creating-a-signed-distance-field">Creating a signed distance field</a><a id="Creating-a-signed-distance-field-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-signed-distance-field" title="Permalink"></a></h2><p>For the actual packing process, this geometry representation is not used directly. What we need is only the distance to the surface of the geometry. To obtain this, we create a signed distance field (SDF). The SDF is constructed within a band around the geometry&#39;s surface. The &quot;thickness&quot; of this band is controlled by <code>max_signed_distance</code>. For example, a <code>max_signed_distance</code> of 0.1 means that the SDF is created up to 0.1 units inside and 0.1 units outside of the geometry interface. It is a good practice to choose <code>max_signed_distance</code> equal to or larger than the compact support of the <a href="../../general/smoothing_kernels/#smoothing_kernel">smoothing kernel</a> that will be used in the later simulation. This ensures that particles near the geometry interface have full kernel support, maintaining accurate interpolation during the packing process. The resolution of the SDF is defined by <code>particle_spacing</code>, which should ideally be identical to the <code>particle_spacing</code> of the initial configuration.</p><pre><code class="language-julia hljs">particle_spacing = 0.05
boundary_thickness = 3 * particle_spacing

signed_distance_field = SignedDistanceField(geometry, particle_spacing;
                                            max_signed_distance=boundary_thickness)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ SignedDistanceField                                                                              │
│ ═══════════════════                                                                              │
│ #particles: ………………………………………………… 564                                                              │
│ max signed distance: ………………………… 0.15000000000000002                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We can also visualize the SDF by simply creating an <code>InitialCondition</code> from the sampled points and plot it. The color coding represents the signed distance to the geometry surface.</p><pre><code class="language-julia hljs">sdf_ic = InitialCondition(; coordinates=stack(signed_distance_field.positions),
                          density=1.0, particle_spacing=particle_spacing)

plot(sdf_ic, zcolor=signed_distance_field.distances, label=nothing, color=:coolwarm)
plot!(geometry, linestyle=:dash, label=nothing, showaxis=false, color=:black,
      seriestype=:path, linewidth=2)</code></pre><img src="6c3bd8ab.svg" alt="Example block output"/><p>Since we will later also pack boundary particles, we need to extend the SDF to the outside. For that, we set <code>use_for_boundary_packing=true</code>.</p><pre><code class="language-julia hljs">signed_distance_field = SignedDistanceField(geometry, particle_spacing;
                                            use_for_boundary_packing=true,
                                            max_signed_distance=boundary_thickness)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ SignedDistanceField                                                                              │
│ ═══════════════════                                                                              │
│ #particles: ………………………………………………… 929                                                              │
│ max signed distance: ………………………… 0.15000000000000002                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We can see in the plot that the SDF has been extended outwards to twice <code>max_signed_distance</code>.</p><pre><code class="language-julia hljs">sdf_ic = InitialCondition(; coordinates=stack(signed_distance_field.positions),
                          density=1.0, particle_spacing=particle_spacing)

plot(sdf_ic, zcolor=signed_distance_field.distances, label=nothing, color=:coolwarm)

plot!(geometry, linestyle=:dash, label=nothing, showaxis=false, color=:black,
      seriestype=:path, linewidth=2)</code></pre><img src="b8f13782.svg" alt="Example block output"/><h2 id="Creating-an-initial-configuration-of-boundary-particles"><a class="docs-heading-anchor" href="#Creating-an-initial-configuration-of-boundary-particles">Creating an initial configuration of boundary particles</a><a id="Creating-an-initial-configuration-of-boundary-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-initial-configuration-of-boundary-particles" title="Permalink"></a></h2><p>To create the initial configuration of the boundary particles, we use the sampled points of the SDF whose signed distance lies between 0 and <code>boundary_thickness</code>. Here, we need to specify the <code>density</code> of the boundary particles. As an example, we choose <code>1.0</code> for all particles. This gives us an <a href="../../general/initial_condition/#TrixiParticles.InitialCondition"><code>InitialCondition</code></a> for the boundary particles.</p><pre><code class="language-julia hljs">density = 1.0
boundary_sampled = sample_boundary(signed_distance_field; boundary_density=density,
                                   boundary_thickness)

# Plotting the initial configuration of the boundary particles
plot(boundary_sampled, label=nothing)
plot!(geometry, linestyle=:dash, label=nothing, showaxis=false, color=:black,
      seriestype=:path, linewidth=2)</code></pre><img src="740d5eec.svg" alt="Example block output"/><h2 id="Creating-an-initial-configuration-of-interior-particles"><a class="docs-heading-anchor" href="#Creating-an-initial-configuration-of-interior-particles">Creating an initial configuration of interior particles</a><a id="Creating-an-initial-configuration-of-interior-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-initial-configuration-of-interior-particles" title="Permalink"></a></h2><p>Next, we need to create the initial configuration of the interior particles. This step is independent of the other steps in the packing pipeline. For the later packing, any <a href="../../general/initial_condition/#TrixiParticles.InitialCondition"><code>InitialCondition</code></a> can be used. Later more on this. Different inside–outside segmentation algorithms can be applied here. In this tutorial, we will use a winding number approach. See also <a href="../../preprocessing/preprocessing/#sampling_of_geometries">Sampling of Geometries</a> for details. We initialize the winding number algorithm with the geometry.</p><pre><code class="language-julia hljs">point_in_geometry_algorithm = WindingNumberJacobson(; geometry)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ WindingNumberJacobson                                                                            │
│ ═════════════════════                                                                            │
│ winding number factor: …………………… 0.0                                                              │
│ winding: ………………………………………………………… HierarchicalWinding                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>The inside–outside segmentation of the geometry is performed by the <code>ComplexShape</code> function. This function creates an <a href="../../general/initial_condition/#TrixiParticles.InitialCondition"><code>InitialCondition</code></a> for the interior particles. Here, we need to specify <code>particle_spacing</code> and <code>density</code>. For further arguments, please refer to the documentation of <a href="../../general/initial_condition/#TrixiParticles.ComplexShape-Tuple{Any}">ComplexShape</a> or <a href="../../general/initial_condition/#TrixiParticles.InitialCondition">InitialCondition</a>.</p><pre><code class="language-julia hljs">shape_sampled = ComplexShape(geometry; particle_spacing, density=density,
                             point_in_geometry_algorithm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ InitialCondition{Float64}                                                                        │
│ ═════════════════════════                                                                        │
│ #dimensions: ……………………………………………… 2                                                                │
│ #particles: ………………………………………………… 515                                                              │
│ particle spacing: ………………………………… 0.05                                                             │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>If we want to assign the mass of each sampled particle consistently with its density, we can adjust it as follows:</p><pre><code class="language-julia hljs">shape_sampled.mass .= density * TrixiParticles.volume(geometry) / nparticles(shape_sampled);</code></pre><p>Now we can plot the initial configuration of the interior particles together with the boundary particles.</p><pre><code class="language-julia hljs">plot(shape_sampled, boundary_sampled, label=nothing)
plot!(geometry, linestyle=:dash, label=nothing, showaxis=false, color=:black,
      seriestype=:path, linewidth=2)</code></pre><img src="f49f9b18.svg" alt="Example block output"/><p>As shown in the plot, the interface of the geometry surface is not well resolved yet. In other words, there is no body-fitted configuration. This is where the particle packing will come into play.</p><h2 id="Particle-packing"><a class="docs-heading-anchor" href="#Particle-packing">Particle packing</a><a id="Particle-packing-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-packing" title="Permalink"></a></h2><p>In the following, we will essentially follow the same steps described in the fluid tutorials. That means we will generate systems that are then passed to the <a href="../../general/semidiscretization/#TrixiParticles.Semidiscretization"><code>Semidiscretization</code></a>. The difference from a typical physical simulation is that we use <a href="../../preprocessing/preprocessing/#TrixiParticles.ParticlePackingSystem"><code>ParticlePackingSystem</code></a>, which does not represent any physical law. Instead, we only use the simulation framework to time-integrate the packing process.</p><p>We first need to import <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq</code></pre><p>Next, we set a background pressure. This can be chosen arbitrarily. A higher value results in smaller time steps, but the final packed state will remain the same after running the same number of iterations.</p><pre><code class="language-julia hljs">background_pressure = 1.0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>For particle interaction, we select a <a href="../../general/smoothing_kernels/#smoothing_kernel">smoothing kernel</a> with a suitable smoothing length. Empirically, a factor of <code>0.8</code> times the particle spacing gives good results [<a href="../../references/#neher2025robustefficientpreprocessingtechniques">3</a>].</p><pre><code class="language-julia hljs">smoothing_kernel = SchoenbergQuinticSplineKernel{2}()
smoothing_length = 0.8 * particle_spacing</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.04000000000000001</code></pre><p>Now we can create the packing system. For learning purposes, let’s first try passing no signed distance field (SDF) and see what happens.</p><pre><code class="language-julia hljs">packing_system = ParticlePackingSystem(shape_sampled;
                                       smoothing_kernel=smoothing_kernel,
                                       smoothing_length=smoothing_length,
                                       signed_distance_field=nothing, background_pressure)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ ParticlePackingSystem{2}                                                                         │
│ ════════════════════════                                                                         │
│ neighborhood search: ………………………… Nothing                                                          │
│ #particles: ………………………………………………… 515                                                              │
│ smoothing kernel: ………………………………… SchoenbergQuinticSplineKernel                                    │
│ tlsph: ……………………………………………………………… no                                                               │
│ boundary: ……………………………………………………… no                                                               │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We now proceed with the familiar steps &quot;Semidiscretization&quot; and &quot;Time integration&quot; from the fluid tutorials.</p><pre><code class="language-julia hljs">semi = Semidiscretization(packing_system)

# Use a high `tspan` to guarantee that the simulation runs for at least `maxiters`
tspan = (0, 10000.0)
ode = semidiscretize(semi, tspan)

maxiters = 100
callbacks = CallbackSet(UpdateCallback())
time_integrator = RDPK3SpFSAL35()

sol = solve(ode, time_integrator;
            abstol=1e-7, reltol=1e-4, save_everystep=false, maxiters=maxiters,
            callback=callbacks)

packed_ic = InitialCondition(sol, packing_system, semi)

plot(packed_ic)
plot!(geometry, seriestype=:path, linewidth=2, color=:black, label=nothing)</code></pre><img src="195b2215.svg" alt="Example block output"/><p>As we can see in the plot, the particles are not constrained to the geometric surface.</p><p>We therefore add an SDF for the geometry and repeat the same procedure.</p><pre><code class="language-julia hljs">packing_system = ParticlePackingSystem(shape_sampled;
                                       smoothing_kernel=smoothing_kernel,
                                       smoothing_length=smoothing_length,
                                       signed_distance_field,
                                       background_pressure)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ ParticlePackingSystem{2}                                                                         │
│ ════════════════════════                                                                         │
│ neighborhood search: ………………………… GridNeighborhoodSearch                                           │
│ #particles: ………………………………………………… 515                                                              │
│ smoothing kernel: ………………………………… SchoenbergQuinticSplineKernel                                    │
│ tlsph: ……………………………………………………………… no                                                               │
│ boundary: ……………………………………………………… no                                                               │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Again, we follow the same steps for semidiscretization and time integration.</p><pre><code class="language-julia hljs">semi = Semidiscretization(packing_system)

tspan = (0, 10000.0)
ode = semidiscretize(semi, tspan)

maxiters = 1000
callbacks = CallbackSet(UpdateCallback())
time_integrator = RDPK3SpFSAL35()

sol = solve(ode, time_integrator;
            abstol=1e-7, reltol=1e-4, save_everystep=false, maxiters=maxiters,
            callback=callbacks)

packed_ic = InitialCondition(sol, packing_system, semi)

# Plotting the final configuration
plot(packed_ic)
plot!(geometry, seriestype=:path, color=:black, label=nothing, linewidth=2)</code></pre><img src="659b8c07.svg" alt="Example block output"/><p>We can see that the particles now stay inside the geometry, but their distribution near the surface can still be improved by adding boundary particles [<a href="../../references/#neher2025robustefficientpreprocessingtechniques">3</a>]. Therefore, we set up a dedicated boundary packing system by setting <code>is_boundary = true</code>. For convex geometries, it is useful to slightly compress the boundary layer thickness. The background for this is that the true geometric volume is often larger than what was assumed when sampling the boundary particles, because the mass was computed assuming an interior particle volume. A <code>boundary_compress_factor</code> of <code>0.8</code> or <code>0.9</code> works well for most shapes. Since we have a relatively large particle spacing compared to the geometry size in this example, we will choose <code>0.7</code>.</p><pre><code class="language-julia hljs">boundary_system = ParticlePackingSystem(boundary_sampled;
                                        is_boundary=true,
                                        smoothing_kernel=smoothing_kernel,
                                        smoothing_length=smoothing_length,
                                        boundary_compress_factor=0.7,
                                        signed_distance_field, background_pressure)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ ParticlePackingSystem{2}                                                                         │
│ ════════════════════════                                                                         │
│ neighborhood search: ………………………… GridNeighborhoodSearch                                           │
│ #particles: ………………………………………………… 313                                                              │
│ smoothing kernel: ………………………………… SchoenbergQuinticSplineKernel                                    │
│ tlsph: ……………………………………………………………… no                                                               │
│ boundary: ……………………………………………………… yes                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We can now couple the boundary system with the interior system:</p><pre><code class="language-julia hljs">semi = Semidiscretization(packing_system, boundary_system)

tspan = (0, 10000.0)
ode = semidiscretize(semi, tspan)

maxiters = 1000
callbacks = CallbackSet(UpdateCallback())
time_integrator = RDPK3SpFSAL35()

sol = solve(ode, time_integrator;
            abstol=1e-7, reltol=1e-4, save_everystep=false, maxiters=maxiters,
            callback=callbacks)

packed_ic = InitialCondition(sol, packing_system, semi)
packed_boundary_ic = InitialCondition(sol, boundary_system, semi)

# Plotting the final configuration
plot(packed_ic, packed_boundary_ic)
plot!(geometry, seriestype=:path, color=:black, linestyle=:dash, linewidth=2, label=nothing)</code></pre><img src="1ef45ff0.svg" alt="Example block output"/><h2 id="Multi-body-packing"><a class="docs-heading-anchor" href="#Multi-body-packing">Multi-body packing</a><a id="Multi-body-packing-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-body-packing" title="Permalink"></a></h2><p>So far, we have focused on packing a single body. However, it is often useful to also pack a surrounding (complex) body in a way that the interface between both domains is well represented. We will demonstrate this using a simple rectangular domain: first we will pack the entire domain, then only a selected (necessary) part of it.</p><p>We will reuse the final configuration of our geometry to create a packing system. Because we are satisfied with this particle distribution, we want it to remain unchanged. Therefore, we set <code>fixed_system=true</code> so that this system is not integrated further but instead serves as a static boundary for the packing of other domains.</p><pre><code class="language-julia hljs">fixed_system = ParticlePackingSystem(packed_ic;
                                     smoothing_kernel=smoothing_kernel,
                                     smoothing_length=smoothing_length,
                                     signed_distance_field=nothing,
                                     background_pressure,
                                     fixed_system=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ ParticlePackingSystem{2}                                                                         │
│ ════════════════════════                                                                         │
│ neighborhood search: ………………………… Nothing                                                          │
│ #particles: ………………………………………………… 515                                                              │
│ smoothing kernel: ………………………………… SchoenbergQuinticSplineKernel                                    │
│ tlsph: ……………………………………………………………… no                                                               │
│ boundary: ……………………………………………………… no                                                               │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Now we define a rectangular domain that we want to pack. In practice, you could create any <code>InitialCondition</code> that encloses your complex geometry.</p><pre><code class="language-julia hljs">tank_domain = RectangularTank(particle_spacing, (4, 4), (0, 0), min_coordinates=(-1, -2),
                              density)

sampled_outer_domain = setdiff(tank_domain.fluid, packed_ic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ InitialCondition{Float64}                                                                        │
│ ═════════════════════════                                                                        │
│ #dimensions: ……………………………………………… 2                                                                │
│ #particles: ………………………………………………… 5708                                                             │
│ particle spacing: ………………………………… 0.05                                                             │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>If we plot these two <code>InitialCondition</code>s, we can see that the geometry interface is not properly represented yet.</p><pre><code class="language-julia hljs">plot(sampled_outer_domain, packed_ic)</code></pre><img src="45b1652e.svg" alt="Example block output"/><p>Next, we create a packing system for the outer domain.</p><pre><code class="language-julia hljs">packing_system = ParticlePackingSystem(sampled_outer_domain;
                                       smoothing_kernel=smoothing_kernel,
                                       smoothing_length=smoothing_length,
                                       signed_distance_field=nothing,
                                       background_pressure)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ ParticlePackingSystem{2}                                                                         │
│ ════════════════════════                                                                         │
│ neighborhood search: ………………………… Nothing                                                          │
│ #particles: ………………………………………………… 5708                                                             │
│ smoothing kernel: ………………………………… SchoenbergQuinticSplineKernel                                    │
│ tlsph: ……………………………………………………………… no                                                               │
│ boundary: ……………………………………………………… no                                                               │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Since we do not want to sample a boundary for the outer domain, we can set up a periodic box to ensure that all outer particles have full kernel support.</p><pre><code class="language-julia hljs">periodic_box = PeriodicBox(min_corner=[-1.0, -2.0], max_corner=[3.0, 2.0])
neighborhood_search = GridNeighborhoodSearch{2}(; periodic_box)

semi = Semidiscretization(packing_system, fixed_system; neighborhood_search)

tspan = (0, 10000.0)
ode = semidiscretize(semi, tspan)

maxiters = 1000
callbacks = CallbackSet(UpdateCallback())
time_integrator = RDPK3SpFSAL35()

sol_1 = solve(ode, time_integrator; abstol=1e-7, reltol=1e-4,
              save_everystep=false, maxiters=maxiters, callback=callbacks)

packed_outer_domain = InitialCondition(sol_1, packing_system, semi)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ InitialCondition{Float64}                                                                        │
│ ═════════════════════════                                                                        │
│ #dimensions: ……………………………………………… 2                                                                │
│ #particles: ………………………………………………… 5708                                                             │
│ particle spacing: ………………………………… 0.05                                                             │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We see that after packing, the geometry interface is well represented.</p><pre><code class="language-julia hljs">plot(packed_outer_domain, packed_ic)</code></pre><img src="edbd5b19.svg" alt="Example block output"/><p>However, from the plot we can also see that the particles near the interface were primarily affected by the packing algorithm, while the rest of the domain remains almost unchanged. It is often more efficient to pack only a local region instead of the full domain. Therefore, we define a rectangle that encloses the complex geometry:</p><pre><code class="language-julia hljs">pack_window = TrixiParticles.Polygon(stack([
                                               [-0.5, -1.5],
                                               [2.5, -1.5],
                                               [2.5, 0.5],
                                               [-0.5, 0.5],
                                               [-0.5, -1.5]
                                           ]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Polygon{2, Float64}                                                                              │
│ ═══════════════════                                                                              │
│ #edges: …………………………………………………………… 4                                                                │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Then, we extract the particles that fall inside this window</p><pre><code class="language-julia hljs">pack_domain = intersect(sampled_outer_domain, pack_window)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ InitialCondition{Float64}                                                                        │
│ ═════════════════════════                                                                        │
│ #dimensions: ……………………………………………… 2                                                                │
│ #particles: ………………………………………………… 1867                                                             │
│ particle spacing: ………………………………… 0.05                                                             │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>and those outside the window</p><pre><code class="language-julia hljs">fixed_domain = setdiff(sampled_outer_domain, pack_window)

plot(pack_domain, fixed_domain, packed_ic)</code></pre><img src="1e952f74.svg" alt="Example block output"/><p>We can now treat the particles outside the window, along with the already finalized configuration of the complex geometry, as fixed systems:</p><pre><code class="language-julia hljs">fixed_system_1 = ParticlePackingSystem(fixed_domain;
                                       smoothing_kernel=smoothing_kernel,
                                       smoothing_length=smoothing_length,
                                       signed_distance_field=nothing,
                                       background_pressure, fixed_system=true)

fixed_system_2 = ParticlePackingSystem(packed_ic;
                                       smoothing_kernel=smoothing_kernel,
                                       smoothing_length=smoothing_length,
                                       signed_distance_field=nothing,
                                       background_pressure, fixed_system=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ ParticlePackingSystem{2}                                                                         │
│ ════════════════════════                                                                         │
│ neighborhood search: ………………………… Nothing                                                          │
│ #particles: ………………………………………………… 515                                                              │
│ smoothing kernel: ………………………………… SchoenbergQuinticSplineKernel                                    │
│ tlsph: ……………………………………………………………… no                                                               │
│ boundary: ……………………………………………………… no                                                               │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>The window that we want to pack is passed to a moving packing system:</p><pre><code class="language-julia hljs">packing_system = ParticlePackingSystem(pack_domain;
                                       smoothing_kernel=smoothing_kernel,
                                       smoothing_length=smoothing_length,
                                       signed_distance_field=nothing,
                                       background_pressure)

semi = Semidiscretization(packing_system, fixed_system_1, fixed_system_2)

tspan = (0, 10000.0)
ode = semidiscretize(semi, tspan)

maxiters = 1000
callbacks = CallbackSet(UpdateCallback())
time_integrator = RDPK3SpFSAL35()

sol_2 = solve(ode, time_integrator; abstol=1e-7, reltol=1e-4,
              save_everystep=false, maxiters=maxiters, callback=callbacks)

packed_fluid_domain = InitialCondition(sol_2, packing_system, semi)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ InitialCondition{Float64}                                                                        │
│ ═════════════════════════                                                                        │
│ #dimensions: ……………………………………………… 2                                                                │
│ #particles: ………………………………………………… 1867                                                             │
│ particle spacing: ………………………………… 0.05                                                             │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We see that this still gives us a good result</p><pre><code class="language-julia hljs">plot(fixed_domain, packed_fluid_domain, packed_ic)</code></pre><img src="c688e807.svg" alt="Example block output"/><p>Finally, we can show the size of our integration arrays:</p><pre><code class="language-julia hljs">@show length(sol_1.u[1].x[1]);
@show length(sol_2.u[1].x[1]);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">length((sol_1.u[1]).x[1]) = 11416
length((sol_2.u[1]).x[1]) = 3734</code></pre><p>This shows that we can avoid integrating unnecessary particles by restricting the packing to a relevant window.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 26 August 2025 08:04">Tuesday 26 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
